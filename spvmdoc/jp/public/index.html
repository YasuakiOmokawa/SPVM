<html>
  <head>
    <title>SPVM公式ドキュメント 1.0 ベータ</title>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="/images/spvm-logo.png">
    <link rel="stylesheet" type="text/css" href="/css/common.css">
    <script type="text/javascript" src="/js/jquery-1.9.0.min.js"></script>
    <script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
    <link  type="text/css" rel="stylesheet" href="/js/google-code-prettify/prettify.css"/>
    <script>
      $(function(){
        // google code prettifyの有効化
        $("pre").addClass("prettyprint");
        function init(event){
          prettyPrint();
        }
        if(window.addEventListener)window.addEventListener("load",init,false);
        else if(window.attachEvent)window.attachEvent("onload",init);
        
        
      });
    </script>

  </head>
  <body>
    <div class="header">
      <div class="container">
        <h1>
          <img src="/images/spvm-logo.png">
          SPVM公式ドキュメント 1.0 ベータ
        </h1>
      </div>
    </div>
    
    <div class="container">
      <p>
        昨日の記事は<a href="http://d.hatena.ne.jp/charsbar/20181207/1544189920">charsbar</a>さんでした。
      </p>
      <p>
        本日はyukikimotoが書きます。リレー形式でつなげていくのは、楽しいですね!
      </p>
      <p>
        この記事はSPVMの日本語公式ドキュメントです。書き始めですが、数時間で、書けるところまで書きます。
      </p>
      <p>
        <a href="https://qiita.com/advent-calendar/2018/perl">Perl Advent Calender 2018</a>をきっかけにに作成されました。
      </p>
      
      <h2>目次</h2>
      <ul class="toc">
        <li><a href="#purpose">目的</a></li>
        <li><a href="#user">ユーザー</a></li>
        <li><a href="#features">機能</a></li>
        <li><a href="#install">SPVMのインストール</a></li>
        <li><a href="#tutorial">チュートリアル</a></li>
        <li><a href="#language">言語仕様</a></li>
        <li><a href="#stdfunc">標準関数</a></li>
        <li><a href="#faq">FAQ</a></li>
        <li><a href="#devoloper">開発者</a></li>
      </ul>

      <h2 id="purpose">目的</h2>

      <h3>SPVMが開発された主な目的を教えてください。</h3>

      <p>
        SPVMは、<b>Perlの数値計算の遅さを改善</b>するために開発されました。<b>数値計算と配列の演算を高速化</b>することができます。
      </p>

      <h3>どれくらいの速度の改善を目指していますか</h3>

      <p>
        仕様が完成した後にベンチマークテストを始める予定ですが、数値計算と配列の演算に対して、Perlの30倍、C言語の1/2の速度を、最初の目標としています。
      </p>

      <h3>他の目的はありますか</h3>

      <p>
        二つ目の目的は、<b>C/C++のバインディングを簡単にする</b>ことです。XSやInline::Cは、C/C++のバインディングという点で、非常に難しいと感じています。
      </p>
      <p>
        簡単なAPIを使って、メモリ安全に、C/C++のバインディングができる機能を提供しています。
      </p>

      <h3>さらに、他の目的はありますか</h3>

      <p>
        三つ目の目的は、<b>単体で実行可能な実行ファイルを生成する</b>ことです。
      </p>
      <p>
        SPVMは、実行ファイルを生成する機能を持っているので、ランタイムなしに、プログラムの実行が可能で、配布することもできます。
      </p>
      <p>
        共有ライブラリ(ダイナミックリンクライブラリ)の読み込みにも対応しています。
      </p>

      <h3>生成された実行ファイルのライセンスはどうなりますか</h3>
      <p>
        SPVMのソースコードには、MITライセンスが適用されるので、MITライセンスの元で、商用利用が可能です。
      </p>

      <h3>実行ファイルを生成して、何ができますか</h3>
      <p>
        たとえば、ボタンなどのGUI部品を備えた、配布可能なWindowsアプリケーションが作成できる予定です。
      </p>

      <h2 id="user">ユーザー</h2>
      <p>
        どのような人をSPVMのユーザーとして想定していますか。
      </p>

      <h3>遺伝子解析などのビオテクノロジーの研究者</h3>
      <p>
        Perlは、遺伝子解析などのビオテクノロジーの分野で利用されていますが、配列操作の遅さに不満を感じている研究者の方がいます。
      </p>

      <p>
        配列操作を簡単に高速化でき、必要であればC/C++をバインディングし、openMPやSIMDなどの並列計算ができればと考えている研究者の方を想定しています。
      </p>

      <h3>Perlの数値計算を速くしたいが、XSやC言語は難しいと感じる方</h3>
      <p>
        SPVMを使うと、Perlの文法で、数値計算と配列演算を速くすることができます。
      </p>

      <h3>IoTの開発者</h3>

      <p>
        IoTの開発者は、ハードウェアからWebまでの幅広い知識が必要になります。大量の分野の知識が必要となるため、これを簡単に実現するライブラリがあれば便利です。
      </p>

      <p>
        C/C++、アセンブラを使って、センサーのデバイスドライバを作成。HTTPクライアントライブラリを使って、Webにアクセス。開発環境で、実行ファイルを作成して、それぞれの機器にそのままコピー。このような一連の機能をSPVMは提供する予定です。
      </p>

      <h3>グラフィックスエンジニア</h3>

      <p>
        画像処理には、大量の配列演算が必要です。Perlは、配列のデータ構造を言語仕様として持たないため、不満を感じている方がいます。
      </p>

      <p>
        SPVMは、連続した領域を持つ配列のデータ構造を提供しているので、DirectXやOpenGM、OpenCVなどと組み合わせて、画像処理をしたいユーザーに向いています。
      </p>

      <h3>AI・機械学習エンジニア</h3>

      <p>
        AI・機械学習には、配列演算が必要です。Perlは、配列のデータ構造を言語仕様として持たないため、不満を感じている方がいます。
      </p>

      <p>
        SPVMは、連続した領域を持つ配列のデータ構造を提供しているので、機械学習ライブラリとの相性が高いです。
      </p>

      <h3>マイクロサービスの提供者</h3>

      <p>
        SPVMは、JSONモジュール、非同期IOをサポートしたHTTPクライアント/サーバーをコアで提供する予定です。実行ファイルを生成可能なので、小さなLinuxサーバーを構築し、実行ファイルをコピーして、マイクロサービスを運用可能です。
      </p>

      <p>
        SPVMは、リファレンスカウント方式のGCを採用しているので、FullGCが起こらず、非同期IOの性能に大きく関わるレイテンシを小さくできます。
      </p>

      <h2 id="install">SPVMのインストール</h2>

      <p>
        SPVMはCPANモジュールです。cpanまたはcpanmを使ってインストールできます。
      </p>
<pre>
cpan SPVM
cpanm SPVM
</pre>

      <h2 id="features">機能</h2>
      <h3>連続したデータ領域を持つ配列型</h3>
      <p>
        SPVMは連続したデータ領域を持つ配列型を提供しています。
      </p>
      <h3 class="features-specification">仕様化された数値型と計算規則</h3>
      <p>
        Perlの数値計算の弱点の一つは、型を固定して計算することができないことです。ある操作によって浮動小数点に変換されたり、文字列型に変換されたりします。SPVMでは、仕様化された数値型と計算規則を持っているので、どの型によって計算されるかを正確把握することができます。
      </p>
      <h3 class="features-c99-math">C99で追加された数学関数</h3>
      <p>
        C99で追加された新しいC言語の数学関数がすべて利用できます。
      </p>
      
      <h3 class="features-specification">仕様化された言語仕様</h3>
      <p>
        SPVMの言語仕様は、メジャーバージョンごとに、仕様化されています。仕様を元に、独自にコンパイラを開発することが可能です。
      </p>
      <h3>サブルーチンの機械語へのコンパイル</h3>
      <p>
        SPVMのサブルーチンはコンパイル時に、機械語へコンパイルすることができます。
      </p>
      <h3>覚えやすく簡単な文法</h3>
      <p>
        SPVMの文法は覚えやすく簡単になるように設計されています。
      </p>
      <p>
        文法の95%以上はPerlの文法を採用しています。Perlをすでに学んでいるユーザーであれば、2時間あれば、すべての文法を覚えてしまうことができるでしょう。
      </p>
      <p>
        型の種類、型の規変換規則は、明確です。型推論は、常に右から左へ行われます。
      </p>
      <p>
        継承はなく「汎用オブジェクト型」と「インターフェース」を使って、ポリモーフィズムを実現します。
      </p>

      <h2 id="tutorial">SPVMのチュートリアル</h2>

      <p>
        SPVMのチュートリアルです。
      </p>
      
      <ul class="toc">
        <li>
          <a href="#tutorial-sum-array">配列の和を求める</a>
        </li>
      </ul>
      
      <h3 id="tutorial-sum-array">
        配列の和を求める
      </h3>
      
      <p>
        最初の簡単な例として配列の和を求めてみましょう。
      </p>
      <h4>SPVMモジュールの作成</h4>
      <p>
        「MyMath.spvm」というファイルファイルをlibディレクトリの中に作成してください。<b>SPVMのソースファイルの拡張子は「.spvm」</b>です。以下の内容を記述しましょう。
      </p>
<pre>
# lib/MyMath.spvm
package MyMath {
  sub sum : int ($nums : int[]) {
    
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }
    
    return $total;
  }
}
</pre>
      
      <p>
        SPVMでは<b>パッケージ構文</b>を使用して、パッケージを作成します。Perlのパッケージブロック構文と同じ文法です。
      </p>
<pre>
# パッケージ構文
package MyMath {

}
</pre>
      <p>
        パッケージのブロックの中では<b>サブルーチン定義</b>を行うことができます。
      </p>
<pre>
package MyMath {
  sub sum : int ($nums : int[]) {
    
  }
}
</pre>
      
      <p>
        SPVMは静的型言語ですので、<b>サブルーチンの宣言の中で、戻り値の型、引数名と引数の型を記述</b>します。
      </p>
      <p>
        戻り値は「int型」。引数は「int型の配列」です。<b>int型は、32bit符号付整数</b>を表現します。
      </p>
      <p>
        配列の和を計算している部分をみてみましょう。
      </p>
<pre>
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }

    return $total;
</pre>
      <p>
        和の計算方法の見た目は、Perlでfor文を使って書いたものとまったく同じです。
      </p>
      <p>
        このようにSPVMではM<b>Perlと同じ文法で記述</b>できるのがひとつの特徴です。Perlユーザーが、新しい文法を覚える負担ができるだけ小さくなるように設計されています。
      </p>
      <p>
        変数の宣言では<b>型推論</b>を使って、型を省略することができます。
      </p>
<pre>
    my $total = 0;
</pre>
      <p>
        SPVMの型推論は、右辺の型が確定しているときに、左辺の型宣言を省略することができます。
      </p>
      <p>
        数値リテラルの「0」は「int型」ですので、「$total」の型も「int型」になります。以下の記述と同じ意味になります。
      </p>
<pre>
    my $total : int = 0;
</pre>
      <p>
        <b>配列の長さ</b>は「@」を使うことで取得できます。
      </p>
<pre>
@$nums
</pre>
      <p>
        SPVMには、コンテキストはなく「@」は常に配列の長さを返します。
      </p>
      <p>
        次にSPVMで書かれたサブルーチンをPerlの側から呼び出してみましょう。
      <p>
      <h4>SPVMモジュールの呼び出し</h4>
      <p>
        「sum.pl」というファイルを作成して、以下の内容を記述してください。
      </p>
      <p>
        SPVMで書かれた「MyMath」パッケージの「sum」サブルーチンを呼び出して、配列の和を計算します。
      </p>
<pre>
use FindBin;
use lib "$FindBin::Bin/lib";

use SPVM 'MyMath';

my $sp_nums = SPVM::new_iarray([3, 6, 8, 9]);

my $total = MyMath->sum($sp_nums);

print $total . "\n";
</pre>
      <p>
        まず最初に<b>libディレクトリをモジュールの検索パスに追加</b>します。
      </p>
<pre>
# libディレクトリをモジュールの検索パスに追加
use FindBin;
use lib "$FindBin::Bin/lib";
</pre>
      <p>
        次に<b>SPVMモジュールを読み込み</b>ます。
      </p>
<pre>
# SPVMモジュールを読み込み
use SPVM 'MyMath';
</pre>
      <p>
        「use SPVM 'SPVMモジュール名'」という記述で、SPVMモジュールを読み込むことができます。
      </p>
      <p>
        次に<b>SPVMの配列を作成</b>します。
      </p>
<pre>
# int型配列の作成
my $sp_nums = SPVM::new_iarray([3, 6, 8, 9]);
</pre>
      <p>
        <b>SPVM::new_iarray関数</b>を使うと、配列のリファレンスを渡して、SPVMのint型の配列を作成することができます。
      </p>
      <p>
        <b>MyMathパッケージのsumサブルーチンを呼び出し</b>てみましょう。
      </p>
<pre>
# MyMathパッケージのsumサブルーチンを呼び出し
my $total = MyMath->sum($sp_nums);
</pre>
      <p>
        <b>SPVMのサブルーチン呼び出しは、Perlのクラスメソッド呼び出しになることに注意してください。</b>「絶対名 MyMath::sub」で呼び出すことはできません。
      </p>
      
      <p>
        sum関数の戻り値は「int型」ですが、SPVMの整数型は、自動的にPerlのスカラ型に変換されます。
      </p>
      
      <h2 id="language">言語仕様</h2>
      <p>
        SPVMの言語仕様の詳細です。
      </p>
      <ul class="toc">
        <li><a href="#language-parser">構文解析</a>
        <li><a href="#language-comment">コメント</a>
        <li><a href="#language-pod">POD</a>
        <li><a href="#language-package">パッケージ</a>
        <li><a href="#language-field">フィールド</a>
        <li><a href="#language-package-variable">パッケージ変数</a>
        <li><a href="#language-enum">列挙</a>
        <li><a href="#language-type">型</a></li>
        <li><a href="#language-block">ブロック</a></li>
        <li><a href="#language-statement">文</a></li>
        <li><a href="#language-type-convertion">型変換</a></li>
        <li><a href="#language-undef">未定義値</a></li>
        <li><a href="#language-literal">リテラル</a></li>
        <li><a href="#language-condition-part">条件部</a></li>
      </ul>
      <h3 id="language-parser">構文解析</h3>
      <ul class="toc">
        <li><a href="#language-parser-encoding">ソースコードの文字コード</a>
        <li><a href="#language-parser-lalr">LALR(1)法</a>
        <li><a href="#language-parser-component">構成要素</a>
        <li><a href="#language-parser-line-terminater">行終端</a>
        <li><a href="#language-parser-space-character">空白文字</a>
        <li><a href="#language-parser-identifier">識別子</a>
        <li><a href="#language-parser-separator">区切り文字</a>
        <li><a href="#language-parser-operator">演算子</a>
      </ul>
      <h4 id="language-parser-encoding">ソースコードの文字コード</h4>
      <p>
        SPVMのソースコードの文字コードは、BOMなしのUTF-8で記述されます。
      </p>
      <h4 id="language-parser-lalr">LALR(1)法</h4>
      <p>
        SPVMのソースコードは、LALR(1)法によって解析できます。yacc/bisonで生成されたパーサージェネレータによって解析することができます。
      </p>
      <h4 id="language-parser-component">構成要素</h4>
      <p>
        SPVMのソースコードは「<a href="#language-parser-space-character">空白文字</a>」「<a href="#language-comment">コメント</a>」「<a href="#language-literal">リテラル</a>」「<a href="#language-parser-keyword">キーワード</a>」「<a href="#language-parser-identifier">識別子</a>」「<a href="#language-parser-separator">区切り文字</a>」「<a href="#language-parser-operator">演算子</a>」で構成されます。
      </p>
      <h4 id="language-parser-line-terminater">行終端</h4>
      <p>
        SPVMのソースコードの行終端は、ASCIIコードの「LF」「CR」「CR LF」です。
      </p>
      <p>
        行終端が現れたときは、適切に行番号がインクリメントされます。
      </p>
      <h4 id="language-parser-space-character">空白文字</h4>
      <p>
        SPVMにおける空白文字はASCIIコードの「SP」「HT」「FF」と「<a href="#language-parser-line-terminater">行終端</a>」です。
      </p>
      <p>
        空白文字はソースコード上では意味を持ちません。
      </p>
      <h4 id="language-parser-keyword">キーワード</h4>
      <p>
        SPVMにおけるキーワードは以下です。
      </p>
<pre>
byte BEGIN case croak default double elsif else enum eq
eval for float gt ge has if interface isa int last length
lt le long my native ne next new our object package private
public precompile pointer_t return require rw ro self switch
sub string short scalar undef unless use void value_t while
weaken wo __END__ __PACKAGE__ __FILE__ __LINE__
</pre>
      <h4 id="language-parser-identifier">識別子</h4>
      <p>
        SPVMにおける識別子は「パッケージ名」「サブルーチン名」「フィールド名」「パッケージ変数名」「レキシカル変数名」です。
      </p>
      <h4 id="language-parser-separator">区切り文字</h4>
      <p>
        SPVMにおける区切り文字は以下です。
      </p>
<pre>
( ) { } [ ] ; , ->
</pre>

      <h4 id="language-parser-operator">演算子</h4>
      <p>
        SPVMにおける演算子は以下です。
      </p>
<pre>
=   >   <   !   ~
==  <=  >=  !=  &&  ||  ++  --
+   -   *   /   &   |   ^   %   <<   >>   >>>
+=  -=  *=  /=  &=  |=  ^=  %=  <<=  >>=  >>>=
\   $   @   .   .=
</pre>
      
      <h3 id="language-comment">コメント</h3>
      <p>
        コメントは「#」で始まり改行で終わります。
      </p>
<pre>
# コメント
</pre>
      <h3 id="language-pod">POD</h3>
      <p>
        POD(プレーンオールドドキュメント)を記述することができます。PODは行頭が「=」で始まる任意の文字列の行から始まり、行頭から行末まで「=cut」で終わる行までです。
      </p>
      <p>
        PODの内側に書かれた文字列はソースコードとして解釈されず、コメントとして扱われます。
      </p>
<pre>
=pod

複数行
コメント

=cut
</pre>

<pre>
=head1

複数行
コメント

=cut
</pre>

      <h3 id="language-package">パッケージ</h3>
      <ul class="toc">
        <li><a href="#language-package-definition">パッケージの定義</a></li>
      </ul>
      
      <h4 id="language-package-definition">パッケージの定義</h4>
      <p>
        パッケージを定義するには以下の構文を使用します。
      </p>
<pre>
package パッケージ名 {

}
</pre>
      <p>
        パッケージ名は「大文字」で始まる必要があります。
      </p>
      <p>
        「パッケージ名」の後に「:」をつなげてその後ろに「デスクリプタ」を指定することができます。
      </p>
<pre>
package パッケージ名 : デスクリプタ {

}
</pre>
      <p>
        パッケージの定義のサンプルです。
      </p>
<pre>
# パッケージ名のみ
package Point {

}
</pre>

<pre>
# パッケージ名とデスクリプタ
package Point : public {

}
</pre>
      
      <p>
        <b>パッケージデスクリプタ</b>
      </p>
      <p>
        パッケージで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このパッケージに対するnewキーワードが他のパッケージから利用できます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このパッケージに対するnewキーワードが他のパッケージから利用できません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>interface</b>
          </td>
          <td>
            このパッケージは「インターフェイス」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>value_t</b>
          </td>
          <td>
            このパッケージは「値型」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>pointer_t</b>
          </td>
          <td>
            このパッケージは「ポインタ型」になります。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイルエラーになります。
      </p>
      <p>
        「interface」「value_t」「pointer_t」のひとつより多くが同時に指定されている場合は、コンパイルエラーになります。
      </p>
      
      <p>
        <b>パッケージ内部で定義できるもの</b>
      </p>
      <p>
        パッケージ内部では<b>「use」</b><b>「パッケージ変数」</b><b>「フィールド」</b><b>「列挙」</b><b>「サブルーチン」</b>が定義できます。
      </p>
<pre>
package Foo {
  # use
  use Point;
  
  # パッケージ変数
  our $VAR int;
  
  # フィールド
  has var : int;
  
  # 列挙
  enum {
    CONST_VAL
  }
  
  # サブルーチン
  sub foo : int ($num : int) {
  
  }
}
</pre>
      <h3 id="language-field">フィールド</h3>
      <ul class="toc">
        <li><a href="#language-field-definition">フィールドの定義</a></li>
      </ul>
      <h4 id="language-field-definition">フィールドの定義</h4>
      <p>
        フィールドとは「new」を使ってオブジェクト生成した場合に、オブジェクトからアクセスできるデータ領域のことです。
      </p>
      <p>
        「has」キーワードを使用してフィールドを定義することができます。
      </p>
<pre>
has フィールド名 : 型名;
</pre>
      <p>
        フィールド定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        フィールド定義には「<a href="#language-type">型名</a>」が必要です。型名には「数値型」と「オブジェクト型」を指定できます。
      </p>
      <p>
        フィールド名は、1文字以上の「a～z」「A～Z」「0～9」「_」で構成する必要があります。先頭は、数字から始めることはできません。連続した「_」を使用することはできません。
      </p>
      <p>
        フィールド名には、<a href="#language-parser-keyword">キーワード</a>と同じ名前を使用することができます。
      </p>
      <p>
        フィールド定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
has フィールド名 : デスクリプタ 型名;
</pre>
      <p>
        <b>フィールドデスクリプタ</b>
      </p>
      <p>
        フィールドで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このフィールドは、外部のパッケージからアクセスできます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このフィールドは、外部のパッケージからアクセスできません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>ro</b>
          </td>
          <td>
            このフィールドは、読み込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は、フィールド名と同じです。フィールド名が「foo」の場合は、フィールドアクセッサ名は「foo」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>wo</b>
          </td>
          <td>
            このフィールドは、書き込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は、「set_フィールド名」になります。フィールド名が「foo」の場合は、フィールドアクセッサ名は「set_foo」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>rw</b>
          </td>
          <td>
            このフィールドは、読み込み用のフィールドアクセッサと書き込み用のフィールドアクセッサを持ちます。読み込み用のフィールドアクセッサ名は「ro」で説明したものと同じです。書き込み用のフィールドアクセッサ名は「wo」で説明したものと同じです。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイルエラーになります。
      </p>
      <p>
        「ro」「wo」「rw」のひとつより多くが同時に指定されている場合は、コンパイルエラーになります。
      </p>
      <p>
        フィールドアクセッサとは、フィールドにアクセスするためのメソッドのことです。
      </p>
      <p>
        書き込み用のフィールドアクセッサの戻り値は「void型」です。
      </p>
      <p>
        SPVMのソースコードの中からフィールドアクセッサが呼び出された場合は、フィールドアクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
      </p>
      <p>
        <b>フィールド定義のサンプル</b>
      </p>
      <p>
        フィールド定義のサンプルです。
      </p>
<pre>
package Foo {
  has num1 : byte;
  has num2 : short;
  has num3 : int;
  has num4 : long;
  has num5 : float;
  has num6 : double;

  has num_public : public int;
  has num_ro : ro int;
  has num_wo : wo int;
  has num_rw : rw int;
}
</pre>
      <p>
        不正なフィールドの定義は、コンパイルエラーになります。
      </p>

      <h3 id="language-package-variable">パッケージ変数</h3>
      <ul class="toc">
        <li>
          <a href="#language-package-variable-definition">パッケージ変数の定義</a>
        </li>
      </ul>
      <h4 id="language-package-variable-definition">パッケージ変数の定義</h4>
      <p>
        パッケージ変数とは、パッケージに属する、プログラムの開始から終了まで維持されるグローバル変数のことです。
      </p>
      <p>
        「our」キーワードを使用してパッケージ変数を定義することができます。
      </p>
<pre>
our パッケージ変数名 : 型名;
</pre>
      <p>
        パッケージ変数の定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        パッケージ変数の定義には「<a href="#language-type">型名</a>」が必要です。型名には「数値型」と「オブジェクト型」を指定できます。
      </p>
      <p>
        パッケージ変数名は「$」で始まり、次に「A-Z」、その後ろに、ひとつ以上の「a～z」「A～Z」「0～9」「_」を続けることができます。Perlと異なり、「$」の後ろには、必ず大文字の英数字が必要であることに注意してください。
      </p>
      <p>
        パッケージ変数定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
our パッケージ変数名 : デスクリプタ 型名;
</pre>
      <p>
        <b>パッケージ変数デスクリプタ</b>
      </p>
      <p>
        パッケージ変数で指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このパッケージ変数は、外部のパッケージからアクセスできます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このパッケージ変数は、外部のパッケージからアクセスできません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>ro</b>
          </td>
          <td>
            このパッケージ変数は、読み込み用のパッケージ変数アクセッサを持ちます。パッケージ変数アクセッサ名は、パッケージ変数名から「$」を除いたものです。パッケージ変数名が「$FOO」の場合は、パッケージ変数アクセッサ名は「FOO」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>wo</b>
          </td>
          <td>
            このパッケージ変数は、書き込み用のパッケージ変数アクセッサを持ちます。パッケージ変数アクセッサ名は、「SET_パッケージ変数名から$を除いたもの」になります。パッケージ変数名が「$FOO」の場合は、パッケージ変数アクセッサ名は「SET_FOO」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>rw</b>
          </td>
          <td>
            このパッケージ変数は、読み込み用のパッケージ変数アクセッサと書き込み用のパッケージ変数アクセッサを持ちます。読み込み用のパッケージ変数アクセッサ名は「ro」で説明したものと同じです。書き込み用のパッケージ変数アクセッサ名は「wo」で説明したものと同じです。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイルエラーになります。
      </p>
      <p>
        「ro」「wo」「rw」のひとつより多くが同時に指定されている場合は、コンパイルエラーになります。
      </p>
      <p>
        パッケージ変数アクセッサとは、パッケージ変数にアクセスするためのクラスメソッドのことです。
      </p>
      <p>
        書き込み用のパッケージ変数アクセッサの戻り値は「void型」です。
      </p>
      <p>
        SPVMのソースコードの中からパッケージ変数アクセッサが呼び出された場合は、パッケージ変数アクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
      </p>
      <p>
        <b>パッケージ変数定義のサンプル</b>
      </p>
      <p>
        パッケージ変数定義のサンプルです。
      </p>
<pre>
package Foo {
  our $NUM1 : byte;
  our $NUM2 : short;
  our $NUM3 : int;
  our $NUM4 : long;
  our $NUM5 : float;
  our $NUM6 : double;

  our $NUM_PUBLIC : public int;
  our $NUM_RO : ro int;
  our $NUM_WO : wo int;
  our $NUM_RW : rw int;
}
</pre>
      <h3 id="language-sub">サブルーチン</h3>
      <ul class="toc">
        <li><a href="#language-field-definition">サブルーチンの定義</a></li>
      </ul>
      <h4 id="language-field-definition">サブルーチンの定義</h4>
      <p>
        「sub」キーワードを使用してサブルーチンを定義することができます。
      </p>
<pre>
sub サブルーチン名 : 戻り値の型名 (引数名1 : 引数の型名1, 引数名2 : 引数の型名2, 以下続く) {
  
}
</pre>
      <p>
        サブルーチンの定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        サブルーチン名は、1文字以上の「a～z」「A～Z」「0～9」「_」で構成する必要があります。先頭は、数字から始めることはできません。連続した「_」を使用することはできません。
      </p>
      <p>
        サブルーチン名には、<a href="#language-parser-keyword">キーワード</a>と同じ名前を使用することができます。
      </p>
      <p>
        戻りの型名には、「void型」「数値型」「オブジェクト型」を指定することができます。
      </p>
      <p>
        サブルーチンの定義には「戻り値の型名」と「0個以上の引数の定義」が必要です。「引数の定義」は「引数名」と「引数の型名」からなります。
      </p>
      <p>
        引数名は、変数名である必要があります。
      </p>
      <p>
        引数の型名には、「数値型」「オブジェクト型」「リファレンス型」を指定することができます。
      </p>
      
      <p>
        サブルーチンのブロックの中には、0個以上のステートメントを記述できます。
      </p>
      
      <p>
        サブルーチン定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
デスクリプタ名 sub サブルーチン名 : 戻り値の型名 (引数の変数名1 : 引数の型名1, 引数の変数名2 : 引数の型名2, 以下続く) {
  
}
</pre>
      <p>
        <b>サブルーチンデスクリプタ</b>
      </p>
      <p>
        サブルーチンで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>native</b>
          </td>
          <td>
            このサブルーチンは、ネイティブサブルーチンです。
          </td>
        </tr>
        <tr>
          <td>
            <b>precompile</b>
          </td>
          <td>
            このサブルーチンはプリコンパイルされます。
          </td>
        </tr>
      </table>
      <p>
        「native」と「precompile」の両方のデスクリプタが指定された場合は、コンパイルエラーになります。
      </p>
      
      <p>
        引数の型名の後ろに「...」を続けると、可変長引数となります。最後の引数のみ可変長引数にすることができます。
      </p>
<pre>
# 可変長引数の定義
sub サブルーチン名 : 戻り値の型名 (引数名1 : 引数の型名1, 引数名2 : 引数の型名2...) {
  
}
</pre>
      <h3 id="language-enum">列挙</h3>
      <ul class="toc">
        <li>
          <a href="#language-enum-definition">列挙の定義</a>
        </li>
      </ul>
      <h4 id="language-enum-definition">列挙の定義</h4>
      <p>
        列挙は連続したint型の定数を定義したい場合に利用します。
      </p>
      <p>
        列挙は「enum」キーワードを使って定義することができます。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3
}
</pre>
      <p>
        列挙の定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        最初の値は「0」から始まります。値は「1」づつインクリメントされます。この例の場合は「FLAG1」は「0」、「FALG2」は「1」、「FLAG3は「2」になります。
      </p>
      <p>
        列挙の末尾の要素の後ろには「,」をつけることができます。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3,
}
</pre>
      <p>
        列挙はint型を戻り値とする「定数サブルーチン」のエイリアスです。次のサブルーチン定義と等価です。
      </p>
<pre>
sub FLAG1 : int () { return 0; }
sub FLAG2 : int () { return 1; }
sub FLAG3 : int () { return 2; }
</pre>
      <p>
        enumの要素には、int型の値を設定することができます。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2 = 4,
  FLAG3,
}
</pre>
      <p>
        上記の場合は「FLAG1」は「0」、「FALG2」は「4」、「FLAG3」は「5」になります。
      </p>
      <p>
        enumの定義が不正な場合は、コンパイルエラーになります。
      </p>
      
      <h3 id="language-type">型</h3>
      <ul class="toc">
        <li><a href="#language-type-integer">整数型</a></li>
        <li><a href="#language-type-floating-point">浮動小数点型</a></li>
        <li><a href="#language-type-object">オブジェクト型</a></li>
      </ul>
      <h4 id="language-type-integer">整数型</h3>
      <p>
        SPVMの整数型は以下の4つです。
      </p>
      <table>
        <tr>
          <th>
            <b>型名</b>
          </th>
          <th>
            説明
          </th>
          <th>
            範囲
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            8bit符号付整数
          </td>
          <td>
            -128～127
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            16bit符号付整数
          </td>
          <td>
            -32768～32767
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            32bit符号付整数
          </td>
          <td>
            -2147483648～2147483647
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            64bit符号付整数
          </td>
          <td>
            -9223372036854775808～9223372036854775807
          </td>
        </tr>
      </table>
      
      <h3 id="language-block">ブロック</h3>
      
      <p>
        ブロックは「{」で始まり「}」で終わります。
      </p>
<pre>
# ブロック
{

}
</pre>
      <p>
        ブロックは、「<a href="#language-block-statement">文ブロック</a>」と「<a href="#language-block-other">文ブロックではないブロック</a>」に分けられます。
      </p>
      <h4 id="language-block-statement">文ブロック</h4>
      <p>
        文ブロックは「<a href="#language-block-statement-simple">単純なブロック</a>」「<a href="#language-block-statement-sub">サブルーチンブロック</a>」「<a href="#language-block-statement-eval">evalブロック</a>」「<a href="#language-block-statement-if">ifブロック</a>」「<a href="#language-block-statement-elsif">elsifブロック</a>」「<a href="#language-block-statement-else">elseブロック</a>」「<a href="#language-block-statement-for">forブロック</a>」「<a href="#language-block-statement-while">whileブロック</a>」「<a href="#language-block-statement-switch">switchブロック</a>」です。
      </p>
      <p>
        文ブロックには、0個以上の<a href="#language-statement">文</a>を記述することができます。
      </p>
      <h5 id="language-block-statement-simple">単純なブロック</h5>
<pre>
# 単純なブロック
{

}
</pre>

      <h5 id="language-block-statement-sub">サブルーチンブロック</h5>
<pre>
# サブルーチンのブロック
sub : int () {

}
</pre>

      <h5 id="language-block-statement-eval">evalブロック</h5>
<pre>
# evalブロック
eval {

}
</pre>

      <h5 id="language-block-statement-if">ifブロック</h5>
<pre>
# ifブロック
if (条件1) {

}
</pre>

      <h5 id="language-block-statement-elsif">elsifブロック</h5>
<pre>
#elsifブロック
elsif (条件2) {

}
</pre>

      <h5 id="language-block-statement-else">elseブロック</h5>
<pre>
# elseブロック
else {

}
</pre>

      <h5 id="language-block-statement-for">forブロック</h5>
<pre>
# for ブロック
for (my $i = 0; $i < 3; $i++) {

}
</pre>

      <h5 id="language-block-statement-while">whileブロック</h5>
<pre>
# whileブロック
while (条件) {

}
</pre>

      <h5 id="language-block-statement-switch">switchブロック</h5>
<pre>
switch (条件) {

}
</pre>
      <p>
        文ブロックは、スコープを作ります。ブロックの中で宣言された変数に、オブジェクトが代入されている場合は、ブロックの終了の直後に、解放されます。
      </p>

      <h4 id="language-block-other">文ブロックではないブロック</h4>
      <p>
        「<a href="#language-block-statement-package">パッケージブロック</a>」「<a href="#language-block-statement-enum">列挙ブロック</a>」は「文ブロックではないブロック」です。
      </p>

      <h5 id="language-block-statement-package">パッケージブロック</h5>
<pre>
# パッケージブロック
package Foo {

}
</pre>

      <h5 id="language-block-statement-enum">列挙ブロック</h5>
<pre>
# 列挙ブロック
enum {

}
</pre>
      <h3 id="language-statement">文</h3>
      <p>
        文とは、ひとつの処理のことで「ブロック」の中に記述することができます。
      </p>
      <ul class="toc">
        <li><a href="#language-statement-next">next文</a></li>
        <li><a href="#language-statement-last">last文</a></li>
      </ul>
      <h4 id="language-statement-next">next文</h3>
      <p>
        「next文」によって「<a href="#language-block-statement-for">forブロック</a>」または「<a href="#language-block-statement-while">whileブロック</a>」を脱出して、次のループの先頭に移動することができます。
      </p>
<pre>
next;
</pre>
      <p>
        <b>next文のサンプル</b>
      </p>
<pre>
# for
for (my $i = 0; $i < 3; $i++) {
  if ($i == 1) {
    next;
  }
}

# while
my $i = 0;
while ($i < 3;) {
  if ($i == 1) {
    next;
  }
  $i++;
}

</pre>

      <h4 id="language-statement-last">last文</h3>
      <p>
        「last文」によって「<a href="#language-block-statement-for">forブロック</a>」または「<a href="#language-block-statement-while">whileブロック</a>」または「<a href="#language-block-statement-switch">switchブロック</a>」を脱出することができます。
      </p>
<pre>
last;
</pre>
      <p>
        <b>last文のサンプル</b>
      </p>
<pre>
# for
for (my $i = 0; $i < 3; $i++) {
  if ($i == 1) {
    last;
  }
}

# while
my $i = 0;
while ($i < 3;) {
  if ($i == 1) {
    next;
  }
  $i++;
}

# switch
my $num = 3;
switch ($num) {
  case 1 :
    # 処理1
    last;
  case 2 :
    # 処理2
    last;
  case 3 :
    # 処理3
    last;
  default:
    # デフォルト
}
</pre>
      
      <h3 id="language-type-convertion">型変換</h3>
      <ul class="toc">
        <li><a href="#language-type-convertion-narrwing">縮小型変換</a></li>
        <li><a href="#language-type-convertion-widning">拡大型変換</a></li>
      </ul>
      <h4 id="language-type-convertion-narrowing">縮小型変換</h4>
      <p>
        縮小型変換とは、数値型において広い型から狭い型への変換が行われる場合に適用される変換の規則のことです。
      </p>
      <p>
        型の順序は狭い方から「byte」「short」「int」「long」「float」「double」です。
      </p>
      <h4 id="language-type-convertion-widening">拡大型変換</h4>
      <p>
        拡大型変換とは、数値型において狭い型から広い型への変換が行われる場合に適用される変換の規則のことです。
      </p>
      <p>
        型の順序は狭い方から「byte」「short」「int」「long」「float」「double」です。
      </p>

      <h3 id="language-literal">リテラル</h3>
      <ul class="toc">
        <li><a href="#language-literal-integer">整数リテラル</a></li>
        <li><a href="#language-literal-floating-point">浮動小数点リテラル</a></li>
        <li><a href="#language-literal-character">文字リテラル</a></li>
        <li><a href="#language-literal-string">文字列リテラル</a></li>
      </ul>

      <h4 id="language-literal-integer">整数リテラル</h3>
      <p>
        <b>10進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は「0～9」の1つ以上の連続した文字で表現されます。
      </p>
      <p>
        先頭に「+」あるいは「-」の符号をつけることができます。
      </p>
      <p>
        整数リテラルの型は、デフォルトでは「int型」になります。
      </p>
      <p>
        整数リテラルがint型で表現できる数値の範囲を超えている場合は、コンパイルエラーになります。
      </p>
      <p>
        末尾に「L」あるいは「l」のサフィックスをつけることで「long型」の整数リテラルを表現できます。
      </p>
      <p>
        long型の整数リテラルの場合は、long型で表現できる数値の範囲を超えている場合は、コンパイルエラーになります。
      </p>
      <p>
        区切り文字として「_」を使用することができます。区切り文字は意味を持ちません。
      </p>
      <p>
        不正な整数リテラルの表現はコンパイルエラーになります。
      </p>
      <p>
        整数リテラルがbyte型の変数に代入される場合、あるいはbyte型のサブルーチンの引数として渡される場合で、byte型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-narrowing">縮小型変換</a>によって、byte型に自動的に変換されます。範囲を超えている場合は、コンパイルエラーとなります。
      </p>
      <p>
        整数リテラルがshort型の変数に代入される場合、あるいはshort型のサブルーチンの引数として渡される場合で、short型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-narrowing">縮小型変換</a>によって、short型に自動的に変換されます。範囲を超えている場合は、コンパイルエラーとなります。
      </p>
      <p>
        整数リテラルのサンプルです。
      </p>
<pre>
123
+123
-123
123L
123l
123_456_789
-123_456_789L
</pre>
      <p>
        <b>16進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>16進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を16進数を使って表現するときは「0x」から始めます。
      </p>
      <p>
        その後ろに「0～9」「a～f」「A～F」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な16進数表現は、コンパイルエラーになります。
      </p>
      <p>
        整数リテラルを16進数で表現したサンプルです。
      </p>
<pre>
0x3b4f
-0x3F1A
0xDeL
0xFFFFFFFF_FFFFFFFF
</pre>

      <p>
        <b>8進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>8進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を8進数を使って表現するときは「0」から始めます。
      </p>
      <p>
        その後ろに「0～7」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な8進数表現は、コンパイルエラーになります。
      </p>
      <p>
        整数リテラルを8進数で表現したサンプルです。
      </p>
<pre>
0755
-0644
0666L
0655_755
</pre>
      <p>
        <b>2進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>2進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を2進数を使って表現するときは「0b」から始めます。
      </p>
      <p>
        その後ろに「0」か「1」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な2進数表現は、コンパイルエラーになります。
      </p>
      <p>
        整数リテラルを2進数で表現したサンプルです。
      </p>
<pre>
0b0101
-0b1010
0b110000L
0b10101010_10101010
</pre>


      <h4 id="language-literal-floating-point">浮動小数点リテラル</h3>
      <p>
        浮動小数点リテラルは「符号部」「数値部」「指数部」「サフィックス」から構成されます。
      <p>
      <p>
        浮動小数点リテラルには「10進数浮動小数点リテラル」と「16進数浮動小数点リテラル」があります。
      </p>
      <p>
        「符号部」は「+」か「-」で表現されます。「符号部」の存在は、任意です。「符号部」が存在する場合は、先頭にある必要があります。
      </p>
      <p>
        「10進数浮動小数点リテラル」は、数値部が「一桁以上の10進数字」で始まる必要があります。
      </p>
      <p>
        「10進数字」とは「0～9」のことです。
      </p>
      <p>
        「10進数浮動小数点リテラル」は、数値部に「小数点」が含まれているか、含まれていない場合は「指数部」あるいは「サフィックス」が必要です。
      </p>
      <p>
        「小数点」とは「.」のことです。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、数値部が「0x」あるいは「0X」で始まり、その後ろに「一桁以上の16進数字」が続く必要があります。
      </p>
      <p>
        16進数字とは「0～9」「a～f」「A～F」のことです。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、「数値部」に「小数点」を含むことができます。
      </p>
      <p>
        「数値部」はアンダーライン「_」を含むことができます。これは単なる区切り文字で、無視されます。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、「指数部」が必要です。
      </p>
      <p>
        「指数部」は「指数表現」と「符号付10進整数」で構成されます。
      </p>
      <p>
        「指数表現」は「10進数浮動小数点リテラル」の場合は「e」あるいは「E」、「16進数浮動小数点リテラル」の場合は「p」あるいは「P」になります。
      </p>
      <p>
        「指数部」の意味は「10進数浮動小数点リテラル」の場合は、10進数による桁移動、「16進数浮動小数点リテラル」の場合は、2進数による桁移動になります。
      </p>
      <p>
        末尾に「f」あるいは「F」のサフィックスをつけると、浮動小数点リテラルの型は「float型」になります。
      </p>
      <p>
        末尾に「d」あるいは「D」のサフィックスをつけると、浮動小数点リテラルの型は「double型」になります。
      </p>
      <p>
        サフィックスが省略された場合は、浮動小数点リテラルの型は「double型」になります。
      </p>
      <p>
        浮動小数点リテラルが「float型」の場合はC標準の「strtof関数」を使って、文字列からfloat型への変換が行われます。変換が失敗した場合は、コンパイルエラーになります。
      </p>
      <p>
        浮動小数点リテラルが「double型」の場合はC標準の「strtod関数」を使って、文字列からdouble型への変換が行われます。変換が失敗した場合は、コンパイルエラーになります。
      </p>
      <p>
        無限大を表現する浮動小数点リテラルはありません。標準関数である「<a href="#stdfunc-INFINITY">INFINITY関数</a>」「<a href="#stdfunc-INFINITYF">INFINITYF関数</a>」を使用してください。
      </p>
      <p>
        非値を表現する浮動小数点リテラルはありません。標準関数である「<a href="#stdfunc-NAN">NAN関数</a>」「<a href="#stdfunc-NANF">NANF関数</a>」を使用してください。
      </p>
      <p>
        浮動小数点リテラルのサンプルです
      </p>
<pre>
1.32
-1.32
1.32f
1.32F
1.32e3
1.32e-3
1.32E+3
1.32E-3
0x3d3d.edp0
0x3d3d.edp3
0x3d3d.edP3
0x3d3d.edP-3f
</pre>

      <h4 id="language-literal-character">文字リテラル</h3>
      <p>
        文字リテラルは、シングルクォート「'」で囲まれます。
      </p>
      <p>
        文字リテラルの内容は「ひとつのAsciiの印字可能文字」あるいは「ひとつのエスケープ文字」です。
      </p>
      <p>
        文字リテラルの型は「byte型」になります。
      </p>
      <p>
        不正な文字リテラルの場合は、コンパイルエラーになります。
      </p>
      <p>
        <b>エスケープ文字</b>
      </p>
      <table class="toc">
        <tr>
          <th>
            エスケープ文字
          </th>
          <th>
            説明
          </th>
        </tr>
        <tr>
          <td>
            <b>\0</b>
          </td>
          <td>
            Asciiコードの0「NUL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\a</b>
          </td>
          <td>
            Asciiコードの7「BEL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\b</b>
          </td>
          <td>
            Asciiコードの8「BS」
          </td>
        </tr>
        <tr>
          <td>
            <b>\t</b>
          </td>
          <td>
            Asciiコードの9「HT」
          </td>
        </tr>
        <tr>
          <td>
            <b>\n</b>
          </td>
          <td>
            Asciiコードの10「LF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\f</b>
          </td>
          <td>
            Asciiコードの12「FF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\r</b>
          </td>
          <td>
            Asciiコードの13「CR」
          </td>
        </tr>
        <tr>
          <td>
            <b>\"</b>
          </td>
          <td>
            Asciiコードの34「"」
          </td>
        </tr>
        <tr>
          <td>
            <b>\'</b>
          </td>
          <td>
            Asciiコードの39「'」
          </td>
        </tr>
        <tr>
          <td>
            <b>\\</b>
          </td>
          <td>
            Asciiコードの92「\」
          </td>
        </tr>
        <tr>
          <td>
            <b>\xの後ろに二桁の16進数</b>
          </td>
          <td>
            直接Asciiコードを指定します。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
      </table>
      
      <p>
        <b>文字リテラルのサンプル</b>
      </p>
      <p>
        文字リテラルのサンプルです。
      </p>
<pre>
# 文字リテラル
'a'
'x'

# エスケープ文字を使った文字リテラル
'\a'
'\b'
'\t'
'\n'
'\f'
'\r'
'\"'
'\''
'\\'
'\x0D'
'\x0A'
</pre>
      
      <h4 id="language-literal-string">文字列リテラル</h3>
      <p>
        文字列リテラルは、ダブルクォート「"」で囲まれます。
      </p>
      <p>
        文字列リテラルの内容は「0個以上のAsciiの印字可能文字あるいはエスケープ文字」です。
      </p>
      <p>
        文字列リテラルの型は「string型」になります。
      </p>
      <p>
        不正な文字列リテラルの場合は、コンパイルエラーになります。
      </p>
      <p>
        <b>エスケープ文字</b>
      </p>
      <table class="toc">
        <tr>
          <th>
            エスケープ文字
          </th>
          <th>
            説明
          </th>
        </tr>
        <tr>
          <td>
            <b>\0</b>
          </td>
          <td>
            Asciiコードの0「NUL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\a</b>
          </td>
          <td>
            Asciiコードの7「BEL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\b</b>
          </td>
          <td>
            Asciiコードの8「BS」
          </td>
        </tr>
        <tr>
          <td>
            <b>\t</b>
          </td>
          <td>
            Asciiコードの9「HT」
          </td>
        </tr>
        <tr>
          <td>
            <b>\n</b>
          </td>
          <td>
            Asciiコードの10「LF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\f</b>
          </td>
          <td>
            Asciiコードの12「FF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\r</b>
          </td>
          <td>
            Asciiコードの13「CR」
          </td>
        </tr>
        <tr>
          <td>
            <b>\"</b>
          </td>
          <td>
            Asciiコードの34「"」
          </td>
        </tr>
        <tr>
          <td>
            <b>\'</b>
          </td>
          <td>
            Asciiコードの39「'」
          </td>
        </tr>
        <tr>
          <td>
            <b>\\</b>
          </td>
          <td>
            Asciiコードの92「\」
          </td>
        </tr>
        <tr>
          <td>
            <b>\xの後ろに二桁の16進数</b>
          </td>
          <td>
            直接Asciiコードを指定します。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
        <tr>
          <td>
            <b>\N{}の中の複数桁の16進数</b>
          </td>
          <td>
            Unicodeのコードポイントを16進数で指定します。UTF-8に変換されます。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
      </table>
      <p>
        Unicodeのコードポイントを指定するエスケープ文字以外は、<a href="#language-literal-character">文字リテラル</a>のエスケープ文字と共通です。
      </p>
      <p>
        <b>文字列リテラルのサンプル</b>
      </p>
      <p>
        文字列リテラルのサンプルです。
      </p>
<pre>
# 文字列リテラル
"abc"
"あいう"

# エスケープ文字を使った文字列リテラル
"abc\tdef\n"
"\x0D\x0A"
"\N{U+3042}\N{U+3044}\N{U+3046}"
</pre>
      
      <h3 id="language-undef">未定義値</h3>
      <p>
        未定義は「undef」で表現されます。
      </p>
<pre>
undef
</pre>
      <p>
        未定義値は、任意のオブジェクト型の変数に代入することができます。
      </p>
      <p>
        未定義値はオブジェクト型の値と「==」「!=」演算子を使用して、比較することができます。未定義値は、生成されたオブジェクトと等しくない事が保証されます。
      </p>
      <p>
        未定義は条件部で使われた場合は、偽になります。
      </p>
      <p>
        未定義値は、エクステンションにおいてC言語の値として利用された場合は、0と等しくなることが保証されます。
      </p>
      <h3 id="language-condition-part">条件部</h3>
      <p>
        条件部とは、条件判定が行われる部分のことです。SPVMでは、以下の部分が条件部となります。
      </p>
      <p>
        if文のかっこの中。
      </p>
<pre>
if (条件部) {

}
</pre>
      <p>
        unless文のかっこの中。
      </p>
<pre>
unless (条件部) {

}
</pre>
      <p>
        forのかっこの中の二つ目。
      </p>
<pre>
for (初期化;条件部;次の値;) {

}
</pre>
      <p>
        whileのかっこの中。
      </p>
<pre>
while (条件部) {

}
</pre>

      <h2 id="stdfunc">標準関数</h2>
      <p>
        SPVMの標準関数の一覧です。
      </p>
      <ul class="toc">
        <li><a href="#stdfunc-INFINITY">INFINITY</a></li>
        <li><a href="#stdfunc-INFINITYF">INFINITYF</a></li>
        <li><a href="#stdfunc-NAN">NAN</a></li>
        <li><a href="#stdfunc-NANF">NANF</a></li>
      </ul>
      <h3 id="stdfunc-INFINITY">INFINITY</h3>
<pre>
sub INFINITY : double ()
</pre>
      <p>
        無限大を「double型」で返します。C標準の「INFINITYマクロ」の単純なラッパーです。
      </p>
      
      <h3 id="stdfunc-INFINITYF">INFINITYF</h3>
<pre>
sub INFINITYF : float ()
</pre>      
      <p>
        無限大を「float型」で返します。C標準の「INFINITYマクロ」の単純なラッパーです。
      </p>
      <h3 id="stdfunc-NAN">NAN</h3>
<pre>
sub NAN : double ()
</pre>      
      <p>
        非値を「double型」で返します。C標準の「NANマクロ」の単純なラッパーです。
      </p>
      <h3 id="stdfunc-NANF">NANF</h3>
<pre>
sub NANF : float ()
</pre>
      <p>
        非値を「float型」で返します。C標準の「NANマクロ」の単純なラッパーです。
      </p>

      <h2 id="faq">FAQ</h2>
      <h3>
        SPVMの1.0はいつリリースされますか。
      </h3>
      <p>
        SPVMは柔軟で、十分な後方互換性を保つことを目標に現在、設計しています。
      </p>
      <p>
        いくつかの分野で、プログラムが正しく記述できること、パフォーマンスの要件を満たすことが必要です。1.0のリリースは、この要件が満たされた後になります。
      </p>
      <p>
        デバイスドライバや、Open CV、Open GL、SIMD、 Open MP、GPUなどのC/C++ライブラリとの連携の確認。
      </p>
      <p>
        HTTPSのリクエストを処理できるHTTPクライアント/サーバーライブラリ。
      </p>
      <p>
        Windows APIを利用したネイティブWindowsアプリケーションの作成。
      </p>
      <p>
       少なくとも<b>デバイスドライバやC/C++ライブラリと連携でき、WebにHTTPSで接続できる、ネイティブアプリケーション</b>が作成できることの確認が必要です。
      </p>
      <h3>
        SPVMを開発するにあたって参考にした言語を教えてください。
      </h3>
      <p>
        言語仕様と文法についてはPerlを主に参考にしています。必要な部分でPerl 6の文法・キーワードも採用しています。「has」「native」「ro」「rw」「wo」など。
      </p>
      <p>
        言語仕様とバーチャルマシンについては、Java言語とJavaVMの言語仕様を多くを参考にしています。
      </p>
      <p>
        数値型と数値計算においては、Javaの計算規則とほぼ同じです。数値型の種類、演算子の種類、拡張型変換、縮小型変換などです。
      </p>
      <p>
        言語仕様においては、ボクシング、アンボクシング、可変長引数については、Javaを参考に作りました。
      </p>
      <p>
        SPVMのバーチャルマシンの初期実装は、JavaVMを参考にして、可変長バイト命令を解釈するスタック型VMとして作成されました。現在のSPVMは、64bitの固定長命令を解釈するレジスター型VMとなっています。
      </p>
      <p>
        文字列がUTF-8であることと、インターフェースの実装については、go言語の言語仕様を参考にしています。
      </p>
      <h3>なぜレジスタ型VMを採用していますか</h3>
      <p>
        レジスタ型VMを採用している最も大きな理由は、SPVMのオペレーションコードを、C言語のソースコードに変換するときに、1対1で対応させることができるためです。gccの最適化が適用できます。
      </p>
      <h3>列挙にint型以外の型を利用することはできますか</h3>
      <p>
        残念なことですが、列挙に利用できるるのはint型だけです。
      <p>
      <p>
        他の型の定数を利用したい場合は、定数を返すサブルーチンを定義してください。
      </p>
<pre>
sub FOO : double () {
  return 3.14;
}
</pre>
      <p>
        一つの定数を返すサブルーチンは、定数としてインライン展開されることが仕様上で保証されているので、パフォーマンスを気にせず利用できます。
      </p>
      <h3>
        SPVMのサブルーチン呼び出しでかっこを省略できないのはなぜですか。
      </h3>
      <p>
        SPVMにおいては、メソッド呼び出し、クラスメソッド呼び出しについては、かっこの省略が可能です。サブルーチン名だけを指定した場合においては、かっこの省略ができません。
      </p>
      <p>
        これは、サブルーチン名だけでは、識別子名がサブルーチンであることを、ソースコードの中で、決定できないためです。パッケージ名やフィールド名との区別ができません。
      </p>
      <p>
        他のソースファイルを解析することによって、かっこを省略する構文は、理論的には可能ですが、SPVMでは、単一ファイルの中で、静的な構文解析を完了できるということを重要視しました。
      </p>
      <h3>サポートされるGCCのバージョンを教えてください</h3>
      <p>
        gcc 4.3で確認しており、保証される最低のバージョンはgcc 4.3です。C99がサポートされている必要があります。
      </p>
      <h3>符号なし整数型はありませんか</h3>
      <p>
        残念ながら、SPVMには、符号なし整数型はありません。
      </p>
      <h3>対応しているOSを教えてください。</h3>

      <p>
      Unix、Linux、macOS、Windowsに対応しています。
      </p>

      <h3>Perlと異なる点を教えてください。</h3>

      <p>
        コンテキストは存在しません。関数呼び出しには括弧が必要です。三項演算子はありません。シングルクォートは、文字定数です。
      </p>
      <p>
        標準関数や標準モジュールは、Perlとは完全に異なっています。
      </p>
      <p>
        サブルーチンは、必ずメソッドか、クラスメソッドになります。サブルーチンの絶対名での呼び出しはできません。
      </p>
      <p>
        モジュールの拡張子は「spvm」です。
      </p>
      <p>
        型はすべて静的型です。サブルーチン呼び出しは、コンパイル時に解決されます。配列は静的です。動的配列とハッシュは、モジュールとして提供されます。
      </p>

      <h3>スレッドは利用できますか</h3>
      <p>
        スレッドは、コアではサポートされていませんが、エクステンションを使ったユーザーモジュールを作成することで、間接的に利用できます。
      </p>
      <p>
        SPVMはシングルスレッドで動くように設計されています。シングルスレッドは、利用者にとって簡単で安全な設計です。
      </p>
      <p>
        スレッドの機能はSPVMのコアにはありませんが、CやC++のスレッドライブラリを利用して、エクステンションから利用することはできます。
      </p>
      <p>
        エクステンションでは、スレッド用のSPVMの実行環境を生成して、スレッド上で、利用できます。
      </p>
      <p>
        SPVMのモジュールとして作成すれば、SPVMからサブルーチンを通して、間接的にスレッドを利用できます。
      </p>

      <h3>エクステンションとは何ですか</h3>
      <p>
        エクステンションとは、SPVMからC/C++の関数を呼び出すための仕組みのことです。
      </p>

      <h3>プリコンパイルとは何ですか</h3>
      <p>
        プリコンパイルとは、SPVMのサブルーチンを、コンパイル時に機械語に変換する仕組みのことです。機械語に変換されたサブルーチンは、高速に実行できます。</p>
      <p>
        precompileが指定されたサブルーチンを含むモジュールファイルは、コンパイル時に、Cのソースコードに変換されます。
      </p>
<pre>
precompile sub sum : int ($num1 : int, $num2 : int) {
  return $num1 + $num2;
}
</pre>
      <p>
        Cのソースコードは、ビルドディレクトリの中に作成されます。
      </p>
      <p>
        生成されたCのソースコードは、Perlをコンパイルしたコンパイラ(通常はgccかclang)によって、機械語(.oの拡張子を持つオブジェクトファイル)にコンパイルされます。
      </p>
      <p>
        機械語に変換された後、各OSで呼び出すことのできる共有ライブラリ(.soや.dll)にリンクされます。
      </p>

      <h3>ビルドディレクトリとは何ですか</h3>
      <p>
        プリコンパイルする場合に、必要となるディレクトリのことです。
      </p>
      <p>
        ビルドディレクトリを利用することをSPVMに教えるにはSPVM::BuildDirモジュールを使用する必要があります。
      </p>
<pre>
use SPVM::BuildDir;
</pre>
      <p>
        スクリプトがあるディレクトリの「spvm_build」というディレクトリがデフォルトのビルドディレクトリ名になります。
      </p>
      <p>
        ビルドディレクトリ名を自分で指定したい場合は、次のようにします。
      </p>
<pre>
use FindBin;
use SPVM::BuildDir "$FindBin::Bin/mydir;
</pre>

      <h3>インターフェースとは何ですか</h3>
      <p>
        SPVMでは、インターフェスとは、実装を持たないメソッドが一つだけ定義されているパッケージのことをいいます。
      </p>
      <p>
        インターフェースのひとつの例は、標準モジュールである「SPVM::Comparable」です。
      </p>
<pre>
package SPVM::Comparable : interface {
  sub compare : int ($self : self, $object1 : object, $object2 : object);
}
</pre>
      <p>
        機能としては、C言語の関数ポインタに似ています。
      </p>

      <h3>ジェネリクスはありますか</h3>
      <p>
        残念なことですが、SPVMにはジェネリクスはありません。SPVMは、コンパイル時の型決定性よりも、型の簡単さを選択しました。
      </p>
      <p>
        コンテナの要素は、汎用オブジェクト型で定義してください。汎用オブジェクトから実際のオブジェクトを取得するためには、型キャストが必要です。
      </p>
<pre>
sub add : void ($self : self, $object : ojbect) { ... }
sub get : object ($self : self, $index : int) { ... }
</pre>

<pre>
my $list = SPVM::List->new;
$list->add("hello!");
my $str = (string)$list->get(0);
</pre>

      <h3>継承はありますか</h3>
      <p>
        残念ですが、継承はありません。SPVMでは「汎用オブジェクト型」と「インターフェース」を使って、ポリモーフィズムを実現します。
      </p>
      
      <h3>サブルーチンのオーバーロードはありますか。</h3>
      <p>
        サブルーチンのオーバーロードはありません。サブルーチンは、サブルーチン名で一意的に識別されます。
      </p>
      <p>
        採用されていない最も大きな理由は、Perl自体が型を持たないために、PerlからSPVMのサブルーチンへ渡す値の型が決定できないためです。
      </p>
      <p>
        このためSPVMでは、サブルーチン名によって、戻り値と引数の型がわかるように設計されています。
      </p>
      
      <h3>浮動小数点の演算は処理系依存ですか</h3>
      <p>
        はい、浮動小数点の表現方法、および演算は、処理系に依存します。
      </p>
      
      <h3>パッケージ名、フィールド名、サブルーチン名などの識別子に連続したアンダーラインが使えないのはなぜですか</h3>
      <p>
        二つの連続したアンダーラインは、エクステンションにおいて、パッケージ名とサブルーチン名の区切りとして利用されるためです。
      </p>
      <p>
        エクステンションはC言語で書かれます。
      </p>
<pre>
# SPVMのサブルーチン
package Foo::Bar {
  sub baz : void () { }
}
</pre>

<pre>
// エクステンションにおける関数名
SPVM_NATIVE_Foo__Bar__baz(SPVM_ENV* env, SPVM_VALUE* stack) {

}
</pre>
      <p>
        SPVMの「Foo::Barパッケージのbazサブルーチン」はエクステンションの「SPVM_NATIVE_Foo__Bar__baz」に対応します。これは1対1に対応し、相互に名前の変換が可能です。
      </p>
      
      <h3>SPVMからPerlのサブルーチンを呼び出すことはできますか</h3>
      <p>
        残念ながら、SPVMからPerlのサブルーチンを呼び出すことはできません。
      </p>
      <h3>C言語のconstやJavaのfinalのような機能はありますか。</h3>
      <p>
        一度代入した値を変更できなくする機能はありませんが、他の機能の組み合わせで実現することができます。
      </p>
      <p>
        <b>コンパイル時定数で数値型の場合</b>
      </p>
      <p>
        定数サブルーチンを使用します。
      </p>
<pre>
package Foo {
  sub VAL : double () {
    return 5.1234;
  }
}
</pre>
      
      <p>
        <b>コンパイル時定数でオブジェクト型の場合</b>
      </p>
      <p>
        パッケージ変数を定義します。パッケージ変数に読み込み用のアクセッサを定義します。BEGINブロックを使って、パッケージ変数を初期化します。
      </p>
<pre>
package Foo {
  our $POINT : ro int;
  
  BEGIN {
    $POINT = Point->new;
  }
}
</pre>
      <h3>シングルトンを生成することはできますか。</h3>
      <p>
        はいできます。
      </p>
      <p>
        パッケージ変数を定義します。BEGINブロックを使って、パッケージ変数を初期化します。singletonメソッドで、オブジェクトを返します。
      </p>
<pre>
package Foo {
  our $SINGLETON : Foo;
  BEGIN {
    $SINGLETON = new Foo;
  }
  
  sub singleton : Foo () {
    return $SINGLETON;
  }
}
</pre>
      <h3>SPVMの開発に参加することはできますか。</h3>

      <p>
        コア機能、標準関数、標準モジュールについては、作者が決定を行っています。その範囲の中であれば、開発への参加が可能です。
      </p>
      
      <p>
        バグ報告、ベンチマーク、言語評価、ブログなどでの紹介は歓迎です。
      </p>
      <h2 id="developer">開発情報</h2>
      <h3>SPVMの開発に参加</h3>
      <p>
        「README」の中に開発手順が記載されています。
      </p>
      <h3>著者</h3>
      <p>
        木本裕紀(kimoto.yuki@gmail.com)
      </p>
      <p>
        <img src="https://www.gravatar.com/avatar/0475497bcea869ee3d091edc3d06ced7?s=130&d=identicon">
      </p>
      <h3>コアデベロッパー</h3>
      <p>
        moti(motohiko.ave@gmail.com)
      </p>
      <h3>リポジトリ</h3>
      <p>
        <a href="https://github.com/yuki-kimoto/SPVM">SPVM(GitHub)</a>
      </p>
      <h3>CPAN</h3>
      <p>
        <a href="https://metacpan.org/pod/distribution/SPVM/lib/SPVM.pm">SPVM(CPAN)</a>
      </p>
      </p>
      <h3>バグ報告</h3>
      <p>
        バグ報告はGitHubのIssueで行うことができます。
      </p>
      <p>
        <a href="https://github.com/yuki-kimoto/SPVM/issues">GitHub Issue</a>
      </p>
      <h3>ドキュメント最終更新日</h3>
      <p>
        2018年12月12日
      </p>
      <h2>明日は</h2>
      
      <p>
        明日は<a href="https://qiita.com/yumlonne">aeroastro</a>さんです。
      </p>
      <p>
        <a href="https://qiita.com/advent-calendar/2018/perl">Perl Advent Calendar 2018</a>
      </p>
    </div>
    <div class="footer">
      <a href="https://github.com/yuki-kimoto/SPVM">SPVMプロジェクト</a>
    </div>
  </body>
</html>
