<html>
  <head>
    <title>SPVM公式ドキュメント 1.0 ベータ</title>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="/images/spvm-logo.png">
    <link rel="stylesheet" type="text/css" href="/css/common.css">
    <script type="text/javascript" src="/js/jquery-1.9.0.min.js"></script>
    <script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
    <link  type="text/css" rel="stylesheet" href="/js/google-code-prettify/prettify.css"/>
    <script>
      $(function(){
        // google code prettifyの有効化
        $("pre").addClass("prettyprint");
        function init(event){
          prettyPrint();
        }
        if(window.addEventListener)window.addEventListener("load",init,false);
        else if(window.attachEvent)window.attachEvent("onload",init);
        
        $(".to-top").click(function() {
          // ページの一番上までスクロールさせます。
          $('body, html').animate({scrollTop: 0}, 300, 'linear');;
        });
      });
    </script>
  </head>
  <body>
    <div class="header">
      <div class="container">
        <h1>
          <img src="/images/spvm-logo.png">
          SPVM公式ドキュメント 1.0 ベータ
        </h1>
      </div>
    </div>
    
    <div class="container">
      <div>
        最終更新日 2019年2月6日
      </div>
      <h2>目次</h2>
      <ul class="toc">
        <li><a href="#purpose">目的</a></li>
        <li><a href="#user">ユーザー</a></li>
        <li><a href="#features">機能</a></li>
        <li><a href="#install">SPVMのインストール</a></li>
        <li><a href="#tutorial">チュートリアル</a></li>
        <li><a href="#language">言語仕様</a></li>
        <li><a href="#stdfunc">標準関数</a></li>
        <li><a href="#faq">FAQ</a></li>
        <li><a href="#devoloper">開発者</a></li>
      </ul>

      <h2 id="purpose">目的</h2>

      <h3>SPVMが開発された主な目的を教えてください。</h3>

      <p>
        SPVMは、<b>Perlの数値計算の遅さを改善</b>するために開発されました。<b>数値計算と配列の演算を高速化</b>することができます。
      </p>

      <h3>どれくらいの速度の改善を目指していますか</h3>

      <p>
        仕様が完成した後にベンチマークテストを始める予定ですが、数値計算と配列の演算に対して、Perlの30倍、C言語の1/2の速度を、最初の目標としています。
      </p>

      <h3>他の目的はありますか</h3>

      <p>
        二つ目の目的は、<b>C/C++のバインディングを簡単にする</b>ことです。XSやInline::Cは、C/C++のバインディングという点で、非常に難しいと感じています。
      </p>
      <p>
        簡単なAPIを使って、メモリ安全に、C/C++のバインディングができる機能を提供しています。
      </p>

      <h3>さらに、他の目的はありますか</h3>

      <p>
        三つ目の目的は、<b>単体で実行可能な実行ファイルを生成する</b>ことです。
      </p>
      <p>
        SPVMは、実行ファイルを生成する機能を持っているので、ランタイムなしに、プログラムの実行が可能で、配布することもできます。
      </p>
      <p>
        共有ライブラリ(ダイナミックリンクライブラリ)の読み込みにも対応しています。
      </p>

      <h3>生成された実行ファイルのライセンスはどうなりますか</h3>
      <p>
        SPVMのソースコードには、MITライセンスが適用されるので、MITライセンスの元で、商用利用が可能です。
      </p>

      <h3>実行ファイルを生成して、何ができますか</h3>
      <p>
        たとえば、ボタンなどのGUI部品を備えた、配布可能なWindowsアプリケーションが作成できる予定です。
      </p>

      <h2 id="user">ユーザー</h2>
      <p>
        どのような人をSPVMのユーザーとして想定していますか。
      </p>
      
      <p>
        Perlで予想可能な数値演算を行いたい人
      </p>
      <p>
        Perlは本当に型のない言語です。Perlは内部的には型を持っていますが、数値型と文字列型は、コンテキストに応じて、簡単に変換されてしまいます。
      </p>
      <p>
        Perlの整数演算はオーバーフローが発生すると、浮動小数点型に変換されてしまいます。これは、便利ですが、数値計算における起こるであろうことの予測はしづらくなります。
      </p>
      <p>
        Perlの整数演算は、コンパイラオプションによって、32bitあるいは64bitになります。浮動小数点演算は、double型しか持ちません。
      </p>
      <p>
        Perlの数値演算は正しい結果を返しますが、内部の動作に依存し、予想がしづらいものとなっています。これはPerlがテキスト処理言語であるメリットの裏返しです。
      </p>
      <p>
        SPVMは、静的型言語あり、32bit,64bitの整数演算、float,doubleの浮動小数点演算を区別して行うことができます。
      </p>
      <p>
        数値計算におけるPerlのデメリットを緩和します。
      </p>

      <h3>遺伝子解析などのビオテクノロジーの研究者</h3>
      <p>
        Perlは、遺伝子解析などのビオテクノロジーの分野で利用されていますが、配列操作の遅さに不満を感じている研究者の方がいます。
      </p>

      <p>
        配列操作を簡単に高速化でき、必要であればC/C++をバインディングし、openMPやSIMDなどの並列計算ができればと考えている研究者の方を想定しています。
      </p>

      <h3>Perlの数値計算を速くしたいが、XSやC言語は難しいと感じる方</h3>
      <p>
        SPVMを使うと、Perlの文法で、数値計算と配列演算を速くすることができます。
      </p>

      <h3>IoTの開発者</h3>

      <p>
        IoTの開発者は、ハードウェアからWebまでの幅広い知識が必要になります。大量の分野の知識が必要となるため、これを簡単に実現するライブラリがあれば便利です。
      </p>

      <p>
        C/C++、アセンブラを使って、センサーのデバイスドライバを作成。HTTPクライアントライブラリを使って、Webにアクセス。開発環境で、実行ファイルを作成して、それぞれの機器にそのままコピー。このような一連の機能をSPVMは提供する予定です。
      </p>

      <h3>グラフィックスエンジニア</h3>

      <p>
        画像処理には、大量の配列演算が必要です。Perlは、配列のデータ構造を言語仕様として持たないため、不満を感じている方がいます。
      </p>

      <p>
        SPVMは、連続した領域を持つ配列のデータ構造を提供しているので、DirectXやOpenGM、OpenCVなどと組み合わせて、画像処理をしたいユーザーに向いています。
      </p>

      <h3>AI・機械学習エンジニア</h3>

      <p>
        AI・機械学習には、配列演算が必要です。Perlは、配列のデータ構造を言語仕様として持たないため、不満を感じている方がいます。
      </p>

      <p>
        SPVMは、連続した領域を持つ配列のデータ構造を提供しているので、機械学習ライブラリとの相性が高いです。
      </p>

      <h3>マイクロサービスの提供者</h3>

      <p>
        SPVMは、JSONモジュール、非同期IOをサポートしたHTTPクライアント/サーバーをコアで提供する予定です。実行ファイルを生成可能なので、小さなLinuxサーバーを構築し、実行ファイルをコピーして、マイクロサービスを運用可能です。
      </p>

      <p>
        SPVMは、リファレンスカウント方式のGCを採用しているので、FullGCが起こらず、非同期IOの性能に大きく関わるレイテンシを小さくできます。
      </p>

      <h2 id="install">SPVMのインストール</h2>

      <p>
        SPVMはCPANモジュールです。cpanまたはcpanmを使ってインストールできます。
      </p>
<pre>
cpan SPVM
cpanm SPVM
</pre>

      <h2 id="features">機能</h2>
      <h3>連続したデータ領域を持つ配列型</h3>
      <p>
        SPVMは連続したデータ領域を持つ配列型を提供しています。
      </p>
      <h3 class="features-specification">仕様化された数値型と計算規則</h3>
      <p>
        Perlの数値計算の弱点の一つは、型を固定して計算することができないことです。ある操作によって浮動小数点に変換されたり、文字列型に変換されたりします。SPVMでは、仕様化された数値型と計算規則を持っているので、どの型によって計算されるかを正確把握することができます。
      </p>
      <h3 class="features-c99-math">C99で追加された数学関数</h3>
      <p>
        C99で追加された新しいC言語の数学関数がすべて利用できます。
      </p>
      
      <h3 class="features-specification">仕様化された言語仕様</h3>
      <p>
        SPVMの言語仕様は、メジャーバージョンごとに、仕様化されています。仕様を元に、独自にコンパイラを開発することが可能です。
      </p>
      <h3>サブルーチンの機械語へのコンパイル</h3>
      <p>
        SPVMのサブルーチンはコンパイル時に、機械語へコンパイルすることができます。
      </p>
      <h3>覚えやすく簡単な文法</h3>
      <p>
        SPVMの文法は覚えやすく簡単になるように設計されています。
      </p>
      <p>
        文法の95%以上はPerlの文法を採用しています。Perlをすでに学んでいるユーザーであれば、2時間あれば、すべての文法を覚えてしまうことができるでしょう。
      </p>
      <p>
        型の種類、型の規変換規則は、明確です。型推論は、常に右から左へ行われます。
      </p>
      <p>
        継承はなく「汎用オブジェクト型」と「インターフェース」を使って、ポリモーフィズムを実現します。
      </p>

      <h2 id="tutorial">SPVMのチュートリアル</h2>

      <p>
        SPVMのチュートリアルです。
      </p>
      
      <ul class="toc">
        <li>
          <a href="#tutorial-sum-array">配列の和を求める</a>
        </li>
      </ul>
      
      <h3 id="tutorial-sum-array">
        配列の和を求める
      </h3>
      
      <p>
        最初の簡単な例として配列の和を求めてみましょう。
      </p>
      <h4>SPVMモジュールの作成</h4>
      <p>
        「MyMath.spvm」というファイルファイルをlibディレクトリの中に作成してください。<b>SPVMのソースファイルの拡張子は「.spvm」</b>です。以下の内容を記述しましょう。
      </p>
<pre>
# lib/MyMath.spvm
package MyMath {
  sub sum : int ($nums : int[]) {
    
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }
    
    return $total;
  }
}
</pre>
      
      <p>
        SPVMでは<b>パッケージ構文</b>を使用して、パッケージを作成します。Perlのパッケージブロック構文と同じ文法です。
      </p>
<pre>
# パッケージ構文
package MyMath {

}
</pre>
      <p>
        パッケージのブロックの中では<b>サブルーチンの定義</b>を行うことができます。
      </p>
<pre>
package MyMath {
  sub sum : int ($nums : int[]) {
    
  }
}
</pre>
      
      <p>
        SPVMは静的型言語ですので、<b>サブルーチンの宣言の中で、戻り値の型、引数名と引数の型を記述</b>します。
      </p>
      <p>
        戻り値は「int型」。引数は「int型の配列」です。<b>int型は、32bit符号付整数</b>を表現します。
      </p>
      <p>
        配列の和を計算している部分をみてみましょう。
      </p>
<pre>
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }

    return $total;
</pre>
      <p>
        和の計算方法の見た目は、Perlでfor文を使って書いたものとまったく同じです。
      </p>
      <p>
        このようにSPVMではM<b>Perlと同じ文法で記述</b>できるのがひとつの特徴です。Perlユーザーが、新しい文法を覚える負担ができるだけ小さくなるように設計されています。
      </p>
      <p>
        変数の宣言では<b>型推論</b>を使って、型を省略することができます。
      </p>
<pre>
    my $total = 0;
</pre>
      <p>
        SPVMの型推論は、右辺の型が確定しているときに、左辺の型宣言を省略することができます。
      </p>
      <p>
        数値リテラルの「0」は「int型」ですので、「$total」の型も「int型」になります。以下の記述と同じ意味になります。
      </p>
<pre>
    my $total : int = 0;
</pre>
      <p>
        <b>配列の長さ</b>は「@」を使うことで取得できます。
      </p>
<pre>
@$nums
</pre>
      <p>
        SPVMには、コンテキストはなく「@」は常に配列の長さを返します。
      </p>
      <p>
        次にSPVMで書かれたサブルーチンをPerlの側から呼び出してみましょう。
      <p>
      <h4>SPVMモジュールの呼び出し</h4>
      <p>
        「sum.pl」というファイルを作成して、以下の内容を記述してください。
      </p>
      <p>
        SPVMで書かれた「MyMath」パッケージの「sum」サブルーチンを呼び出して、配列の和を計算します。
      </p>
<pre>
use FindBin;
use lib "$FindBin::Bin/lib";

use SPVM 'MyMath';

my $sp_nums = SPVM::new_iarray([3, 6, 8, 9]);

my $total = MyMath->sum($sp_nums);

print $total . "\n";
</pre>
      <p>
        まず最初に<b>libディレクトリをモジュールの検索パスに追加</b>します。
      </p>
<pre>
# libディレクトリをモジュールの検索パスに追加
use FindBin;
use lib "$FindBin::Bin/lib";
</pre>
      <p>
        次に<b>SPVMモジュールを読み込み</b>ます。
      </p>
<pre>
# SPVMモジュールを読み込み
use SPVM 'MyMath';
</pre>
      <p>
        「use SPVM 'SPVMモジュール名'」という記述で、SPVMモジュールを読み込むことができます。
      </p>
      <p>
        次に<b>SPVMの配列を作成</b>します。
      </p>
<pre>
# int型配列の作成
my $sp_nums = SPVM::new_iarray([3, 6, 8, 9]);
</pre>
      <p>
        <b>SPVM::new_iarray関数</b>を使うと、配列のリファレンスを渡して、SPVMのint型の配列を作成することができます。
      </p>
      <p>
        <b>MyMathパッケージのsumサブルーチンを呼び出し</b>てみましょう。
      </p>
<pre>
# MyMathパッケージのsumサブルーチンを呼び出し
my $total = MyMath->sum($sp_nums);
</pre>
      <p>
        <b>SPVMのサブルーチン呼び出しは、Perlのクラスメソッドの呼び出しになることに注意してください。</b>「絶対名 MyMath::sub」で呼び出すことはできません。
      </p>
      
      <p>
        sum関数の戻り値は「int型」ですが、SPVMの整数型は、自動的にPerlのスカラ型に変換されます。
      </p>
      
      <h2 id="language">言語仕様</h2>
      <p>
        SPVMの言語仕様の詳細です。
      </p>
      <ul class="toc">
        <li><a href="#language-c99">C99準拠</a></li>
        <li><a href="#language-parser">構文解析</a></li>
        <li><a href="#language-comment">コメント</a></li>
        <li><a href="#language-pod">POD</a></li>
        <li><a href="#language-package">パッケージ</a></li>
        <li><a href="#language-module">モジュール</a></li>
        <li><a href="#language-package-var">パッケージ変数</a></li>
        <li><a href="#language-field">フィールド</a></li>
        <li><a href="#language-sub">サブルーチン</a></li>
        <li><a href="#language-enum">列挙</a></li>
        <li><a href="#language-begin-block">BEGINブロック</a></li>
        <li><a href="#language-lex-var">レキシカル変数</a></li>
        <li><a href="#language-block">ブロック</a></li>
        <li><a href="#language-scope">スコープ</a></li>
        <li><a href="#language-array">配列</a></li>
        <li><a href="#language-value">値</a></li>
        <li><a href="#language-value-array">値の配列</a></li>
        <li><a href="#language-ref">リファレンス</a></li>
        <li><a href="#language-exception">例外処理</a></li>
        <li><a href="#language-interface">インターフェース</a></li>
        <li><a href="#language-weak-ref">ウィークリファレンス</a></li>
        <li><a href="#language-term">項</a></li>
        <li><a href="#language-expression">式</a></li>
        <li><a href="#language-condition">条件</a></li>
        <li><a href="#language-condition-part">条件部</a></li>
        <li><a href="#language-literal">リテラル</a></li>
        <li><a href="#language-string">文字列</a></li>
        <li><a href="#language-undef">未定義値</a></li>
        <li><a href="#language-operator">演算子</a></li>
        <li><a href="#language-operator-precedence">演算子の優先順位</a></li>
        <li><a href="#language-statement">文</a></li>
        <li><a href="#language-type">型</a></li>
        <li><a href="#language-type-inference">型推論</a></li>
        <li><a href="#language-type-convertion">型変換</a></li>
      </ul>
      <h3 id="language-c99">C99準拠</h3>
      <ul class="list">
        <li><a href="#language-c99-source">ソースコード</a>
        <li><a href="#language-c99-type">型</a>
      </ul>
      <h4 id="language-c99-source">C99準拠のソースコード</h3>
      <p>
        SPVM自体のソースコードは、C言語で書かれ、C99に準拠します。
      </p>
      <p>
        数値演算における仕様は、C99に準拠します。C99で、未定義・処理系依存のものは、SPVMにおいても未定義・処理系依存です。
      </p>
      <p>
        <a href="#language-operator-add">加算演算子</a>、<a href="#language-operator-subtract">減算演算子</a>、乗算演算子、除算演算子、剰余演算子、シフト演算子、ビット演算子においては、C99における演算との対応が仕様化されます。
      </p>
      <p>
        数値から文字列への型変換における仕様は、C99のsrpintfの「%g」フォーマットが仕様になります。
      </p>
      <h4 id="language-c99-type">C99との型の対応</h3>
      <p>
        SPVMの型は、C99の次の型と完全に一致します。
      </p>
      <table>
        <tr>
          <th>
            <b>SPVMの型</b>
          </th>
          <th>
            <b>C99の型</b>
          </th>
          <th>
            <b>説明</b>
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            int8_t
          </td>
          <td>
            SPVMのbyte型はC99のint8_t型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            int16_t
          </td>
          <td>
            SPVMのshort型はC99のint16_t型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            <b>int32_t</b>
          </td>
          <td>
            SPVMのint型はC99のint32_t型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            <b>int64_t</b>
          </td>
          <td>
            SPVMのlong型はC99のint64_t型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            <b>float</b>
          </td>
          <td>
            SPVMのfloat型はC99のfloat型に一致します。
          </td>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            <b>double</b>
          </td>
          <td>
            SPVMのdouble型はC99のdouble型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>オブジェクト型</b>
          </td>
          <td>
            <b>void*</b>
          </td>
          <td>
            SPVMのオブジェクト型はC99のvoid*型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>byte&</b>
          </td>
          <td>
            int8_t*
          </td>
          <td>
            SPVMのbyte&型はC99のint8_t*型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>short&</b>
          </td>
          <td>
            int16_t*
          </td>
          <td>
            SPVMのshort&型はC99のint16_t*型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>int&</b>
          </td>
          <td>
            <b>int32_t*</b>
          </td>
          <td>
            SPVMのint&型はC99のint32_t*型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>long&</b>
          </td>
          <td>
            <b>int64_t*</b>
          </td>
          <td>
            SPVMのlong&型はC99のint64_t*型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>float&</b>
          </td>
          <td>
            <b>float*</b>
          </td>
          <td>
            SPVMのfloat&型はC99のfloat*型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>double&</b>
          </td>
          <td>
            <b>double*</b>
          </td>
          <td>
            SPVMのdouble&型はC99のdouble*型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>値型</b>
          </td>
          <td>
            <b>値型のフィールドの個数を要素数とし、対応した型を持つ配列型 </b>
          </td>
          <td>
            たとえば「package Point_2i : value_t { has x : int; has y : int; }」で定義されていた場合は、Point_2i型は、int32_t[2]型に一致します。
          </td>
        </tr>
      </table>
      
      <h3 id="language-parser">構文解析</h3>
      <ul class="list">
        <li><a href="#language-parser-encoding">ソースコードの文字コード</a>
        <li><a href="#language-parser-lalr">LALR(1)法</a>
        <li><a href="#language-parser-component">構成要素</a>
        <li><a href="#language-parser-line-terminater">行終端</a>
        <li><a href="#language-parser-space-character">空白文字</a>
        <li><a href="#language-parser-identifier">識別子</a>
        <li><a href="#language-parser-separator">区切り文字</a>
        <li><a href="#language-parser-operator">演算子</a>
      </ul>
      
      <h4 id="language-parser-encoding">ソースコードの文字コード</h4>
      <p>
        SPVMのソースコードの文字コードは、BOMなしのUTF-8で記述されます。
      </p>
      
      <h4 id="language-parser-lalr">LALR(1)法</h4>
      <p>
        SPVMのソースコードは、LALR(1)法によって解析できます。yacc/bisonで生成されたパーサージェネレータによって解析することができます。
      </p>
      
      <h4 id="language-parser-component">構成要素</h4>
      <p>
        SPVMのソースコードは「<a href="#language-parser-space-character">空白文字</a>」「<a href="#language-comment">コメント</a>」「<a href="#language-literal">リテラル</a>」「<a href="#language-parser-keyword">キーワード</a>」「<a href="#language-parser-identifier">識別子</a>」「<a href="#language-parser-separator">区切り文字</a>」「<a href="#language-parser-operator">演算子</a>」で構成されます。
      </p>
      
      <h4 id="language-parser-line-terminater">行終端</h4>
      <p>
        SPVMのソースコードの行終端は、ASCIIコードの「LF」「CR」「CR LF」です。
      </p>
      <p>
        行終端が現れたときは、適切に行番号がインクリメントされます。
      </p>
      
      <h4 id="language-parser-space-character">空白文字</h4>
      <p>
        SPVMにおける空白文字はASCIIコードの「SP」「HT」「FF」と「<a href="#language-parser-line-terminater">行終端</a>」です。
      </p>
      <p>
        空白文字はソースコード上では意味を持ちません。
      </p>
      
      <h4 id="language-parser-keyword">キーワード</h4>
      <p>
        SPVMにおけるキーワードは以下です。
      </p>
<pre>
byte BEGIN case croak default double elsif else enum eq
eval for float gt ge has if interface_t isa int last length
lt le long my native ne next new our object package private
public precompile pointer_t return require rw ro self switch
sub string short scalar undef unless use void value_t while
weaken wo __END__ __PACKAGE__ __FILE__ __LINE__
</pre>
      <h4 id="language-parser-identifier">識別子</h4>
      <p>
        SPVMにおける識別子は「パッケージ名」「サブルーチン名」「フィールド名」「パッケージ変数名」「レキシカル変数名」です。
      </p>
      <h4 id="language-parser-separator">区切り文字</h4>
      <p>
        SPVMにおける区切り文字は以下です。
      </p>
<pre>
( ) { } [ ] ; , ->
</pre>

      <h4 id="language-parser-operator">演算子</h4>
      <p>
        SPVMにおける演算子は以下です。
      </p>
<pre>
=   >   <   !   ~
==  <=  >=  !=  &&  ||  ++  --
+   -   *   /   &   |   ^   %   <<   >>   >>>
+=  -=  *=  /=  &=  |=  ^=  %=  <<=  >>=  >>>=
\   $   @   .   .=
</pre>

      <h4 id="language-parser-table">構文解析表</h4>
      <p>
        yacc/bisonにおける、SPVM文法の構文解析表です。
      </p>
<pre>
%token <opval> PACKAGE HAS SUB OUR ENUM MY SELF USE REQUIRE
%token <opval> DESCRIPTOR
%token <opval> IF UNLESS ELSIF ELSE FOR WHILE LAST NEXT SWITCH CASE DEFAULT EVAL
%token <opval> NAME VAR_NAME CONSTANT PACKAGE_VAR_NAME EXCEPTION_VAR
%token <opval> UNDEF VOID BYTE SHORT INT LONG FLOAT DOUBLE STRING OBJECT
%token <opval> DOT3 FATCAMMA RW RO WO BEGIN NEW
%token <opval> RETURN WEAKEN CROAK CURRENT_PACKAGE UNWEAKEN '[' '{' '('

%type <opval> grammar
%type <opval> opt_packages packages package package_block
%type <opval> opt_declarations declarations declaration
%type <opval> enumeration enumeration_block opt_enumeration_values enumeration_values enumeration_value
%type <opval> sub anon_sub opt_args args arg invocant has use require our string_length
%type <opval> opt_descriptors descriptors sub_names opt_sub_names
%type <opval> opt_statements statements statement if_statement else_statement 
%type <opval> for_statement while_statement switch_statement case_statement default_statement
%type <opval> block eval_block begin_block if_require_statement
%type <opval> unary_op binary_op comparison_op num_comparison_op str_comparison_op isa logical_op
%type <opval> call_sub opt_vaarg
%type <opval> array_access field_access weaken_field unweaken_field isweak_field convert array_length
%type <opval> deref ref assign inc dec
%type <opval> new array_init
%type <opval> my_var var package_var_access
%type <opval> term opt_expressions expressions expression condition opt_expression
%type <opval> field_name sub_name
%type <opval> type basic_type array_type array_type_with_length ref_type  type_or_void

%right <opval> ASSIGN SPECIAL_ASSIGN
%left <opval> LOGICAL_OR
%left <opval> LOGICAL_AND
%left <opval> BIT_OR BIT_XOR
%left <opval> '&'
%nonassoc <opval> NUMEQ NUMNE STREQ STRNE
%nonassoc <opval> NUMGT NUMGE NUMLT NUMLE STRGT STRGE STRLT STRLE ISA
%left <opval> SHIFT
%left <opval> '+' '-' '.'
%left <opval> MULTIPLY DIVIDE REMAINDER
%right <opval> LOGICAL_NOT BIT_NOT '@' REF DEREF PLUS MINUS CONVERT SCALAR LENGTH ISWEAK
%nonassoc <opval> INC DEC
%left <opval> ARROW

%%

grammar
  : opt_packages

opt_packages
  :	/* Empty */
  |	packages
  
packages
  : packages package
  | package

package
  : PACKAGE basic_type package_block
  | PACKAGE basic_type ':' opt_descriptors package_block

package_block
  : '{' opt_declarations '}'

opt_declarations
  :	/* Empty */
  |	declarations

declarations
  : declarations declaration
  | declaration

declaration
  : has
  | sub
  | enumeration
  | our ';'
  | use
  | begin_block

begin_block
  : BEGIN block
    
use
  : USE basic_type ';'
  | USE basic_type '(' opt_sub_names ')' ';'

require
  : REQUIRE basic_type

enumeration
  : ENUM enumeration_block

enumeration_block 
  : '{' opt_enumeration_values '}'

opt_enumeration_values
  :	/* Empty */
  |	enumeration_values
    
enumeration_values
  : enumeration_values ',' enumeration_value 
  | enumeration_values ','
  | enumeration_value
  
enumeration_value
  : sub_name
  | sub_name ASSIGN CONSTANT

our
  : OUR PACKAGE_VAR_NAME ':' opt_descriptors type
has
  : HAS field_name ':' opt_descriptors type ';'

sub
  : opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' block
  | opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' ';'

anon_sub
  : opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block
  | '[' args ']' opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block

opt_args
  :	/* Empty */
  |	args
  | invocant
  | invocant ',' args

args
  : args ',' arg
  | arg

arg
  : var ':' type

opt_vaarg
  : /* Empty */
  | DOT3

invocant
  : var ':' SELF

opt_descriptors
  :	/* Empty */
  |	descriptors
    
descriptors
  : descriptors DESCRIPTOR
  | DESCRIPTOR

opt_statements
  :	/* Empty */
  |	statements
    
statements
  : statements statement 
  | statement

statement
  : if_statement
  | for_statement
  | while_statement
  | block
  | switch_statement
  | case_statement
  | default_statement
  | eval_block
  | if_require_statement
  | expression ';'
  | LAST ';'
  | NEXT ';'
  | RETURN ';'
  | RETURN expression ';'
  | CROAK ';'
  | CROAK expression ';'
  | weaken_field ';'
  | unweaken_field ';'
  | ';'

for_statement
  : FOR '(' opt_expression ';' term ';' opt_expression ')' block

while_statement
  : WHILE '(' term ')' block

switch_statement
  : SWITCH '(' expression ')' block

case_statement
  : CASE expression ':'

default_statement
  : DEFAULT ':'

if_require_statement
  : IF '(' require ')' block

if_statement
  : IF '(' term ')' block else_statement
  | UNLESS '(' term ')' block else_statement

else_statement
  : /* NULL */
  | ELSE block
  | ELSIF '(' term ')' block else_statement

block 
  : '{' opt_statements '}'

eval_block
  : EVAL block ';'

opt_expressions
  :	/* Empty */
  |	expressions
term
  : expression
  | condition

opt_expression
  : /* Empty */
  | expression

expression
  : var
  | EXCEPTION_VAR
  | package_var_access
  | CONSTANT
  | UNDEF
  | call_sub
  | field_access
  | array_access
  | convert
  | new
  | array_init
  | array_length
  | string_length
  | my_var
  | binary_op
  | unary_op
  | ref
  | deref
  | assign
  | inc
  | dec
  | '(' expressions ')'
  | CURRENT_PACKAGE

expressions
  : expressions ',' expression
  | expressions ','
  | expression

unary_op
  : '+' expression %prec PLUS
  | '-' expression %prec MINUS
  | BIT_NOT expression

inc
  : INC expression
  | expression INC

dec
  : DEC expression
  | expression DEC

binary_op
  : expression '+' expression
  | expression '-' expression
  | expression MULTIPLY expression
  | expression DIVIDE expression
  | expression REMAINDER expression
  | expression BIT_XOR expression
  | expression '&' expression
  | expression BIT_OR expression
  | expression SHIFT expression
  | expression '.' expression

condition
  : comparison_op
  | logical_op
  | isweak_field ';'
  | '(' condition ')'

comparison_op
  : num_comparison_op
  | str_comparison_op
  | isa

num_comparison_op
  : expression NUMEQ expression
  | expression NUMNE expression
  | expression NUMGT expression
  | expression NUMGE expression
  | expression NUMLT expression
  | expression NUMLE expression

str_comparison_op
  : expression STREQ expression
  | expression STRNE expression
  | expression STRGT expression
  | expression STRGE expression
  | expression STRLT expression
  | expression STRLE expression
    
isa
  : expression ISA type

logical_op
  : term LOGICAL_OR term
  | term LOGICAL_AND term
  | LOGICAL_NOT term

assign
  : expression ASSIGN expression
  | expression SPECIAL_ASSIGN expression

new
  : NEW basic_type
  | NEW array_type_with_length
  | anon_sub

array_init
  : '[' opt_expressions ']'

convert
  : '(' type ')' expression %prec CONVERT

array_access
  : expression ARROW '[' expression ']'
  | array_access '[' expression ']'
  | field_access '[' expression ']'

call_sub
  : NAME '(' opt_expressions  ')'
  | basic_type ARROW sub_name '(' opt_expressions  ')'
  | basic_type ARROW sub_name
  | expression ARROW sub_name '(' opt_expressions ')'
  | expression ARROW sub_name
  | expression ARROW '(' opt_expressions ')'

field_access
  : expression ARROW '{' field_name '}'
  | field_access '{' field_name '}'
  | array_access '{' field_name '}'

weaken_field
  : WEAKEN field_access

unweaken_field
  : UNWEAKEN field_access

isweak_field
  : ISWEAK field_access

array_length
  : '@' expression
  | '@' '{' expression '}'
  | SCALAR '@' expression
  | SCALAR '@' '{' expression '}'

string_length
  : LENGTH expression
    
deref
  : DEREF var

ref
  : REF var

my_var
  : MY var ':' type
  | MY var

var
  : VAR_NAME

package_var_access
  : PACKAGE_VAR_NAME

type
  : basic_type
  | array_type
  | ref_type

basic_type
  : NAME
  | BYTE
  | SHORT
  | INT
  | LONG
  | FLOAT
  | DOUBLE
  | OBJECT
  | STRING

ref_type
  : basic_type '&'

array_type
  : basic_type '[' ']'
  | array_type '[' ']'

array_type_with_length
  : basic_type '[' expression ']'
  | array_type '[' expression ']'

type_or_void
  : type
  | VOID

field_name
  : NAME

sub_name
  : NAME

opt_sub_names
  :	/* Empty */
  |	sub_names

sub_names
  : sub_names ',' sub_name
  | sub_name

%%
</pre>
      <h3 id="language-comment">コメント</h3>
      <p>
        コメントは「#」で始まり改行で終わります。
      </p>
<pre>
# コメント
</pre>
      <h3 id="language-pod">POD</h3>
      <p>
        POD(プレーンオールドドキュメント)を記述することができます。PODは行頭が「=」で始まる任意の文字列の行から始まり、行頭から行末まで「=cut」で終わる行までです。
      </p>
      <p>
        PODの内側に書かれた文字列はソースコードとして解釈されず、コメントとして扱われます。
      </p>
<pre>
=pod

複数行
コメント

=cut
</pre>

<pre>
=head1

複数行
コメント

=cut
</pre>
      <h3 id="language-package">パッケージ</h3>
      <ul class="list">
        <li><a href="#language-package-definition">パッケージの定義</a></li>
        <li><a href="#language-package-destructor">デストラクタ</a></li>
      </ul>
      
      <h4 id="language-package-definition">パッケージの定義</h4>
      <p>
        パッケージを定義するには以下の構文を使用します。
      </p>
<pre>
package パッケージ名 {

}
</pre>
      <p>
        パッケージ名は「大文字」で始まる必要があります。パッケージ名には「::」を使用することができます。
      </p>
<p>
Foo
Foo::Bar
Foo::Bar::Baz
</p>
      <p>
        「パッケージ名」の後に「:」をつなげてその後ろに「デスクリプタ」を指定することができます。
      </p>
<pre>
package パッケージ名 : デスクリプタ {

}
</pre>
      <p>
        パッケージの定義のサンプルです。
      </p>
<pre>
# パッケージ名のみ
package Point {

}
</pre>

<pre>
# パッケージ名とデスクリプタ
package Point : public {

}
</pre>
      
      <p id="language-package-descriptor">
        <b>パッケージデスクリプタ</b>
      </p>
      <p>
        パッケージで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このパッケージに対するnewキーワードが他のパッケージから利用できます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このパッケージに対するnewキーワードが他のパッケージから利用できません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>interface_t</b>
          </td>
          <td>
            このパッケージは「インターフェイス型」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>value_t</b>
          </td>
          <td>
            このパッケージは「<a href="#language-type-value">値型</a>」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>pointer_t</b>
          </td>
          <td>
            このパッケージは「ポインタ型」になります。「ポインタ型」は「クラス型」の一種です。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        「interface_t」「value_t」「pointer_t」のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
      </p>
      
      <p>
        <b>パッケージ内部で定義できるもの</b>
      </p>
      <p>
        パッケージ内部では<b>「use」</b><b>「パッケージ変数」</b><b>「フィールド」</b><b>「列挙」</b><b>「サブルーチン」</b>が定義できます。
      </p>
<pre>
package Foo {
  # use
  use Point;
  
  # パッケージ変数
  our $VAR int;
  
  # フィールド
  has var : int;
  
  # 列挙
  enum {
    CONST_VAL
  }
  
  # サブルーチン
  sub foo : int ($num : int) {
  
  }
}
</pre>

      <h4 id="language-package-destructor">デストラクタ</h4>
      <p>
        パッケージが<a href="#language-type-class">クラス型</a>である場合は、デストラクタを定義することができます。
      </p>
      <p>
        デストラクタとは、オブジェクトが解放されるときに実行される特別な<a href="#language-sub">サブルーチン</a>のことです。
      </p>
      <p>
        デストラクタの名前は「DESTROY」でなければなりません。
      </p>
      <p>
        デストラクタの戻り値の型は、<a href="#language-type-void">void型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デストラクタの引数は、ひとつで、<a href="#language-type-self">self型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
<pre>
sub DESTROY : void ($self : self) {
  
}
</pre>
      <p>
        デストラクタの中で<a href="#language-exception-occur">例外の発生</a>が起こった場合は、プログラムは終了せず、例外メッセージが、標準エラーに出力されます。
      </p>
      <p>
        <b>デストラクタのサンプル</b>
      </p>
      <p>
        デストラクタのサンプルです。
      </p>
<pre>
package Foo {
  sub new : Foo {
    return new Foo;
  }
  
  sub DESTROY : void ($self : self) {
    print("DESTROY");
  }
}
</pre>
      
      <h3 id="language-module">モジュール</h3>
      <ul>
        <li>モジュールの概要</li>
        <li>モジュールの読み込み</li>
      </ul>
      <h4 class="language-module-summary">モジュールの概要</h4>
      <p>
        モジュールとは、SPVMのソースコードとして読み込むことができるひとつのファイルのことをいいます。
      </p>
<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}
</pre>
      <p>
        モジュールには、複数のパッケージを含むことができます。
      </p>
<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}

package Foo::Bar::Baz {

}
</pre>
      <h4 class="language-module-path">モジュールのファイル名</h4>
      <p>
        モジュールは、モジュールの読み込みパスに、以下のファイル名で配置される必要があります。
      </p>
      <p>
        「::」を「/」に変更。末尾に「.spvm」をつける。
      </p>
<pre>
Foo.spvm
Foo/Bar.spvm
Foo/Bar/Baz.spvm
</pre>
      <h4 class="language-module-load">モジュールの読み込み</h4>
      <p>
        モジュールを読み込むには、useキーワードを使用します。
      </p>
<pre>
use Foo;
use Foo::Bar;
</pre>
      <p>
        モジュールはコンパイル時に読み込まれます。
      </p>
      <p>
        モジュールが存在しなかった場合は、コンパイルエラーになります。
      </p>
      <p>
        useキーワードは、パッケージの定義の直下で定義する必要があります。
      </p>
<pre>
package Foo {
  use Foo;
}
</pre>
      <h4 class="language-module-load-if-require">選択的なモジュールの読み込み</h4>
      <p>
        SPVMでは、モジュールが、検索パスに存在する場合だけ読み込み、そうでない場合は、ブロックの内部が存在しないことにできるif require文があります。これはC言語の「#ifdef」の一部の機能を実現するために設計されました。
      </p>
<pre>
if (require Foo) {
  
}
</pre>
      <p>
        if require文では、elsifやelseを続けることができないので注意してください。
      </p>
      <p>
        一つの例を見てみましょう。以下の例で、Fooが存在しない場合は、コンパイルエラーにはならず、ifブロックの中身が存在しないことになります。そのため「my $foo = new Foo;」は、存在しないことになっているので、コンパイルエラーになりません。
      </p>
<pre>
if (require Foo) {
  my $foo = new Foo;
}
</pre>
     <p>
       ひとつのテクニックとして、if require構文と<a href="#language-type-interface">インターフェース型</a>と<a href="#language-sub-anon">無名サブルーチン</a>を使うと、モジュールを選択的に利用することができます。以下の例では、Foo->method1とBar->mehtod2を選択的に選んで実行しています。
     </p>
<pre>
package SomeInterface : interface_t {
  sub foo : int ($self : self, $arg : int);
}

# 別の関数内
my $interface : SomeInterface;

unless ($inteface) {
  if (require Foo) {
    $interface = sub : int ($self : self, $arg : int) {
      Foo->method1($arg);
    };
  }
}

unless ($inteface) {
  if (require Bar) {
    $interface = sub : int ($self : self, $arg : int) {
      Bar->method2($arg);
    }
  }
}

my $result = $interface->foo(3);
</pre>

      <h3 id="language-package-var">パッケージ変数</h3>
      <ul class="list">
        <li><a href="#language-package-var-definition">パッケージ変数の定義</a></li>
        <li><a href="#language-package-var-initial-value">パッケージ変数の初期値</a></li>
        <li><a href="#language-package-var-access">パッケージ変数へのアクセス</a></li>
      </ul>
      <h4 id="language-package-var-definition">パッケージ変数の定義</h4>
      <p>
        パッケージ変数とは、パッケージに属する、プログラムの開始から終了まで維持されるグローバル変数のことです。
      </p>
      <p>
        「our」キーワードを使用してパッケージ変数を定義することができます。
      </p>
<pre>
our パッケージ変数名 : 型名;
</pre>
      <p>
        パッケージ変数の定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        パッケージ変数の定義には「<a href="#language-type">型名</a>」が必要です。型名には「数値型」と「オブジェクト型」を指定できます。
      </p>
      <p>
        パッケージ変数名は「$」で始まり、次に「A-Z」、その後ろに、ひとつ以上の「a～z」「A～Z」「0～9」「_」を続けることができます。Perlと異なり、「$」の後ろには、必ず大文字の英数字が必要であることに注意してください。
      </p>
      <p>
        パッケージ変数定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
our パッケージ変数名 : デスクリプタ 型名;
</pre>
      <p>
        <b>パッケージ変数デスクリプタ</b>
      </p>
      <p>
        パッケージ変数で指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このパッケージ変数は、外部のパッケージからアクセスできます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このパッケージ変数は、外部のパッケージからアクセスできません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>ro</b>
          </td>
          <td>
            このパッケージ変数は、読み込み用のパッケージ変数アクセッサを持ちます。パッケージ変数アクセッサ名は、パッケージ変数名から「$」を除いたものです。パッケージ変数名が「$FOO」の場合は、パッケージ変数アクセッサ名は「FOO」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>wo</b>
          </td>
          <td>
            このパッケージ変数は、書き込み用のパッケージ変数アクセッサを持ちます。パッケージ変数アクセッサ名は、「SET_パッケージ変数名から$を除いたもの」になります。パッケージ変数名が「$FOO」の場合は、パッケージ変数アクセッサ名は「SET_FOO」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>rw</b>
          </td>
          <td>
            このパッケージ変数は、読み込み用のパッケージ変数アクセッサと書き込み用のパッケージ変数アクセッサを持ちます。読み込み用のパッケージ変数アクセッサ名は「ro」で説明したものと同じです。書き込み用のパッケージ変数アクセッサ名は「wo」で説明したものと同じです。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        「ro」「wo」「rw」のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        パッケージ変数アクセッサとは、パッケージ変数にアクセスするためのクラスメソッドのことです。
      </p>
      <p>
        書き込み用のパッケージ変数アクセッサの戻り値は「void型」です。
      </p>
      <p>
        SPVMのソースコードの中からパッケージ変数アクセッサが呼び出された場合は、パッケージ変数アクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
      </p>
      <p>
        <b>パッケージ変数定義のサンプル</b>
      </p>
      <p>
        パッケージ変数定義のサンプルです。
      </p>
<pre>
package Foo {
  our $NUM1 : byte;
  our $NUM2 : short;
  our $NUM3 : int;
  our $NUM4 : long;
  our $NUM5 : float;
  our $NUM6 : double;

  our $NUM_PUBLIC : public int;
  our $NUM_RO : ro int;
  our $NUM_WO : wo int;
  our $NUM_RW : rw int;
}
</pre>
      <h4 id="language-package-var-initial-value">パッケージ変数の初期値</h4>
      <p>
        パッケージ変数は、コンパイルが終了して、実行時に入る前に、<a href="#language-type-initial-value">型の初期値</a>で初期化されます。
      </p>
      <p>
        この初期値は、<a href="#language-begin-block">BEGINブロック</a>を使うことで、変更することができます。
      </p>
<pre>
package Foo {
  our $VAR : int;
  
  BEGIN {
    $VAR = 3;
  }
}
</pre>
      <h4 id="language-package-var-access">パッケージ変数へのアクセス</h4>
      <p>
        パッケージ変数へのアクセスとは、パッケージ変数にアクセスして、値を取得したり、設定したりする操作のことです。
      </p>
      <p>
        パッケージ変数の値の取得については、<a href="#language-expression-get-package-var">パッケージ変数の値の取得</a>を見てください。
      </p>
      <p>
        パッケージ変数の値の設定については、<a href="#language-expression-set-package-var">パッケージ変数の値の設定</a>を見てください。
      </p>
      
      <h3 id="language-field">フィールド</h3>
      <ul class="list">
        <li><a href="#language-field-definition">フィールドの定義</a></li>
        <li><a href="#language-field-access">フィールドへのアクセス</a></li>
      </ul>
      <h4 id="language-field-definition">フィールドの定義</h4>
      <p>
        フィールドとは「new」を使ってオブジェクト生成した場合に、オブジェクトからアクセスできるデータ領域のことです。
      </p>
      <p>
        「has」キーワードを使用してフィールドを定義することができます。
      </p>
<pre>
has フィールド名 : 型名;
</pre>
      <p>
        フィールド定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        フィールド定義には「<a href="#language-type">型名</a>」が必要です。型名には「数値型」と「オブジェクト型」を指定できます。
      </p>
      <p>
        フィールド名は、1文字以上の「a～z」「A～Z」「0～9」「_」で構成する必要があります。先頭は、数字から始めることはできません。連続した「_」を使用することはできません。
      </p>
      <p>
        フィールド名には、<a href="#language-parser-keyword">キーワード</a>と同じ名前を使用することができます。
      </p>
      <p>
        フィールド定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
has フィールド名 : デスクリプタ 型名;
</pre>
      <p>
        <b>フィールドデスクリプタ</b>
      </p>
      <p>
        フィールドで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このフィールドは、外部のパッケージからアクセスできます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このフィールドは、外部のパッケージからアクセスできません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>ro</b>
          </td>
          <td>
            このフィールドは、読み込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は、フィールド名と同じです。フィールド名が「foo」の場合は、フィールドアクセッサ名は「foo」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>wo</b>
          </td>
          <td>
            このフィールドは、書き込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は、「set_フィールド名」になります。フィールド名が「foo」の場合は、フィールドアクセッサ名は「set_foo」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>rw</b>
          </td>
          <td>
            このフィールドは、読み込み用のフィールドアクセッサと書き込み用のフィールドアクセッサを持ちます。読み込み用のフィールドアクセッサ名は「ro」で説明したものと同じです。書き込み用のフィールドアクセッサ名は「wo」で説明したものと同じです。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        「ro」「wo」「rw」のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドアクセッサとは、フィールドにアクセスするためのメソッドのことです。
      </p>
      <p>
        書き込み用のフィールドアクセッサの戻り値は「void型」です。
      </p>
      <p>
        SPVMのソースコードの中からフィールドアクセッサが呼び出された場合は、フィールドアクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
      </p>
      <p>
        <b>フィールド定義のサンプル</b>
      </p>
      <p>
        フィールド定義のサンプルです。
      </p>
<pre>
package Foo {
  has num1 : byte;
  has num2 : short;
  has num3 : int;
  has num4 : long;
  has num5 : float;
  has num6 : double;

  has num_public : public int;
  has num_ro : ro int;
  has num_wo : wo int;
  has num_rw : rw int;
}
</pre>
      <h4 id="language-field-access">フィールドへのアクセス</h4>
      <p>
        フィールドへのアクセスとは、フィールドにアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
      </p>
<pre>
インボカント->{フィールド名}
</pre>
      <p>
        フィールドへのアクセスは、一種類の構文で、三つの異なる意味を持ちます。
      </p>
      <p>
        <b>1. クラス型のフィールドへのアクセス</b>
      </p>
      <p>
        <a href="#language-type-class">クラス型</a>を元に<a href="#language-expression-new-object">オブジェクトの生成</a>が行われた場合は、オブジェクトからフィールドにアクセスすることができます。
      </p>
<pre>
my $point = new Point;
$point->{x} = 1;
</pre>

      <p>
        クラス型のフィールドの取得については、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>を見てください。
      </p>
      <p>
        クラス型のフィールドの設定については、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>を見てください。
      </p>
      <p>
        <b>2. 値型のフィールドへのアクセス</b>
      </p>
      <p>
        2. <a href="#language-type-value">値型</a>におけるフィールドは、値型の変数の宣言をすれば、その変数からフィールドにアクセスできます。これは、レキシカル変数領域におけるアクセスです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
$z->{re} = 1;
$z->{im} = 3;
</pre>
      <p>
        値型のフィールドの取得については、<a href="#language-expression-get-field-value">値型のフィールドの値の取得</a>を見てください。
      </p>
      <p>
        値型のフィールドの設定については、<a href="#language-expression-set-field-value">値型のフィールドの値の設定</a>を見てください。
      </p>
      <p>
        <b>3. デリファレンスによる値型のフィールドのアクセス</b>
      </p>
      <p>
        値型の変数に対するリファレンス型から、デリファレンスを行って直接に値型のフィールドにアクセスできます。
      </p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{re} = 1;
$z_ref->{im} = 3;
</pre>
      <p>
        デリファレンスによる値型のフィールドの取得については、<a href="#language-expression-get-field-value-deref">デリファレンスによる値型のフィールドの取得</a>を見てください。
      </p>
      <p>
        デリファレンスによる値型のフィールドの設定については、<a href="#language-expression-set-field-value-deref">デリファレンスによる値型のフィールドの設定</a>を見てください。
      </p>

      <h3 id="language-sub">サブルーチン</h3>
      <ul class="list">
        <li><a href="#language-sub-definition">サブルーチンの定義</a></li>
        <li><a href="#language-sub-constant">定数サブルーチン</a></li>
        <li><a href="#language-sub-anon">無名サブルーチン</a></li>
        <li><a href="#language-sub-method">メソッド</a></li>
        <li><a href="#language-sub-signature">シグネチャ</a></li>
        <li><a href="#language-sub-invocant">インボカント</a></li>
        <li><a href="#language-sub-stack">サブルーチンのコールスタック</a></li>
      </ul>
      <h4 id="language-sub-definition">サブルーチンの定義</h4>
      <p>
        「sub」キーワードを使用してサブルーチンを定義することができます。
      </p>
<pre>
sub サブルーチン名 : 戻り値の型名 (引数名1 : 引数の型名1, 引数名2 : 引数の型名2, 以下続く) {
  
}
</pre>
      <p>
        サブルーチンの定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        サブルーチン名は、1文字以上の「a～z」「A～Z」「0～9」「_」で構成する必要があります。先頭は、数字から始めることはできません。連続した「_」を使用することはできません。
      </p>
      <p>
        サブルーチン名には、<a href="#language-parser-keyword">キーワード</a>と同じ名前を使用することができます。
      </p>
      <p>
        戻りの型名には、「void型」「数値型」「オブジェクト型」を指定することができます。
      </p>
      <p>
        サブルーチンの定義には「戻り値の型名」と「0個以上の引数の定義」が必要です。「引数の定義」は「引数名」と「引数の型名」からなります。
      </p>
      <p>
        引数名は、変数名でなければなりません。
      </p>
      <p>
        引数の型名には、「数値型」「オブジェクト型」「リファレンス型」を指定することができます。
      </p>
      
      <p>
        サブルーチンのブロックの中には、0個以上のステートメントを記述できます。
      </p>
      
      <p>
        サブルーチンの定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
デスクリプタ名 sub サブルーチン名 : 戻り値の型名 (引数の変数名1 : 引数の型名1, 引数の変数名2 : 引数の型名2, 以下続く) {
  
}
</pre>
      <p>
        <b>サブルーチンデスクリプタ</b>
      </p>
      <p>
        サブルーチンで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>native</b>
          </td>
          <td>
            このサブルーチンは、ネイティブサブルーチンです。
          </td>
        </tr>
        <tr>
          <td>
            <b>precompile</b>
          </td>
          <td>
            このサブルーチンはプリコンパイルされます。
          </td>
        </tr>
      </table>
      <p>
        「native」と「precompile」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      
      <p>
        引数の型名の後ろに「...」を続けると、可変長引数となります。最後の引数のみ可変長引数にすることができます。
      </p>
<pre>
# 可変長引数の定義
sub サブルーチン名 : 戻り値の型名 (引数名1 : 引数の型名1, 引数名2 : 引数の型名2...) {
  
}
</pre>
      <p>
        定義されたサブルーチンは、呼び出すことができます。サブルーチンの呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
      </p>

      <h4 id="language-sub-constant">定数サブルーチン</h4>
      <p>
        数値型の戻り値を持つサブルーチンで、戻り値が定数であるサブルーチンを定数サブルーチンといいます。
      </p>
<pre>
sub foo : int () { return 5; }
sub foo : long () { return 5L; }
sub foo : float () { return 5.0f; }
sub foo : double () { return 5.0; }
</pre>
      <p>
        定数サブルーチンは、インライン展開されます。
      </p>
      <p>
        SPVMは定数畳み込み最適化を行わないので、定数が演算されている場合は、定数サブルーチンにならず、インライン展開されないことに注意してください。
      </p>
<pre>
# 定数サブルーチンではなくインライン展開されない
sub foo : int () { return 5 + 3; }
</pre>
      <h4 id="language-sub-anon">無名サブルーチン</h4>
      <p>
        無名サブルーチンとは、名前を持たないサブルーチンのことです。
      </p>
<pre>
sub : 型名 ($self : self, 引数1, 引数2, ..., 引数n) {
  
}
</pre>
      <p>
        無名サブルーチンを定義すると、内部的に、パッケージの定義がおこなわれ、そのパッケージを元にしたオブジェクトが生成され、<a href="#language-expression">式</a>として返されます。以下のように変数に代入することが可能です。
      </p>
<pre>
my $anon_sub = sub : 型名 ($self : self, 引数1, 引数2, ..., 引数n) {
  
};
</pre>
      <p>
        無名サブルーチンは、<a href="#language-sub-method">メソッド</a>でなければなりません。
      </p>
      <p>
        <b>無名サブルーチンのサンプル</b>
      </p>
<pre>
my $comparator = sub : int ($self : self, $x1 : object, $x2 : object) {
  
}
</pre>
      <p>
        無名サブルーチンは、呼び出すことができます。無名サブルーチンの呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
      <p>
      
      <h4 id="language-sub-method">メソッド</h4>
      <p>
        メソッドとは、第一引数に<a href="#language-type-self">self型</a>を持つサブルーチンのことです。
      </p>
<pre>
sub サブルーチン名 : 型名 ($self : self, 引数1 : 型1, 引数2 : 型2, ..., 引数n : 型n) {
  
}
</pre>
      <p>
        メソッドは、<a href="#language-expression-new-object">オブジェクトの生成</a>によって生成されたオブジェクトから呼び出すことができます。メソッドの呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
      </p>

      <h4 id="language-sub-invocant">インボカント</h4>
      <p>
        インボカントとは、self型が指定された第一引数のことをいいます。
      </p>
<pre>
sub サブルーチン名 : 型名 ($self : self, 引数1 : 型1, 引数2 : 型2, ..., 引数n : 型n) {
  
}
</pre>
      <p>
        上記の例では$selfは、インボカントと呼ばれます。
      </p>

      <h4 id="language-sub-anon">シグネチャ</h4>
      <p>
        シグネチャとは、サブルーチンの戻り値と引数を次の規則で並べたものをいいます。引数は、存在しなくても構いません。間に空白を含むことはできません。
      </p>
      <p>
        1. 戻り値の型名
      </p>
      <p>
        2. (
      </p>
      <p>
        3. 引数1,引数2, 引数3, 引数n
      </p>
      <p>
        4. )
      </p>
      <p>
        シグネチャのサンプルです。
      </p>
<pre>
# サブルーチン定義
sub foo : int ($num1 : double, $num2 : long[])

# シグネチャ
int(double,long[])

# サブルーチン定義
sub foo : void ()

# シグネチャ
void()
</pre>
      <p>
        シグネチャは、SPVMを記述しているときには、意識する必要はありません。ネイティブからSPVMのサブルーチンを呼び出すときに使用します。
      </p>
      
      <h4 id="language-sub-stack">サブルーチンのコールスタック</h4>
      <p>
        サブルーチンのコールスタックとは、<a href="#language-expression-callsub">サブルーチンの呼び出し</a>が行われるときに、確保されるメモリ領域のことを指します。
      </p>
      <p>
        サブルーチンのコールスタックには、以下の情報が保存されます。
      </p>
      <p>
        1. <a href="#language-lex-var">レキシカル変数</a>のためのメモリ領域
      </p>
      <p>
        2. モータル変数の場所
      </p>

      <h3 id="language-enum">列挙</h3>
      <ul class="list">
        <li>
          <a href="#language-enum-definition">列挙の定義</a>
        </li>
        <li>
          <a href="#language-enum-call">列挙の呼び出し</a>
        </li>
      </ul>
      <h4 id="language-enum-definition">列挙の定義</h4>
      <p>
        列挙はint型の定数を定義したい場合に利用します。連続したint型の定数を簡単に定義できます。「enum」キーワードを使って定義します。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3
}
</pre>
      <p>
        列挙の定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
<pre>
package Foo {
  enum {
    FLAG1,
    FLAG2,
    FLAG3
  }
}
</pre>

      <p>
        最初の値は「0」から始まります。値は「1」づつインクリメントされます。この例の場合は「FLAG1」は「0」、「FALG2」は「1」、「FLAG3は「2」になります。
      </p>
      <p>
        列挙の末尾の要素の後ろには「,」をつけることができます。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3,
}
</pre>
      <p>
        列挙はint型を戻り値とする「定数サブルーチン」のエイリアスです。次のサブルーチンの定義と等価です。
      </p>
<pre>
sub FLAG1 : int () { return 0; }
sub FLAG2 : int () { return 1; }
sub FLAG3 : int () { return 2; }
</pre>
      <p>
        enumの要素には、int型の値を設定することができます。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2 = 4,
  FLAG3,
}
</pre>
      <p>
        上記の場合は「FLAG1」は「0」、「FALG2」は「4」、「FLAG3」は「5」になります。
      </p>
      <p>
        enumの定義が不正な場合は、コンパイル時エラーが発生します。
      </p>
      <h4 id="language-enum-call">列挙の呼び出し</h4>
      <p>
        列挙は、定数サブルーチンのエイリアスなので、サブルーチン呼び出しとまったく同じ方法で呼び出すことができます。
      </p>
<pre>
my $flag1 = Foo->FLAG1;
my $flag2 = Foo->FLAG2;
my $flag3 = Foo->FLAG3;
</pre>
      <p>
        switch文のcase文において利用することもできます。
      </p>
<pre>
switch ($num) {
  case Foo->FLAG1:
  
    last;
  case Foo->FLAG2:
    
    last:
  case Foo->FLAG3:
  
    last:
  default:
  
}
</pre>
      <h3 id="language-begin-block">BEGINブロック</h3>
      <p>
        BEGINブロックとは、コンパイル時が終了し、実行時に入る前に、実行されるブロックのことです。
      </p>
      <p>
        BEGINキーワードを使用してBEGINブロックを定義することができます。
      </p>
<pre>
BEGIN {

}
</pre>
      <p>
        BEGINブロックは、パッケージの定義の直下にある必要があります。
      </p>
<pre>
package Foo {
  BEGIN {

  }
}
</pre>
      <p>
        BEGINブロックの中には、0個以上の<a href="#language-statement">文</a>を書くことができます。
      </p>
<pre>
BEGIN {
  my $foo = 1 + 1;
  my $bar;
}
</pre>
      <p>
        return文を書くことはできません。BEGINブロックは、引数がなく、戻り値がvoidのサブルーチンとして定義されます。
      </p>
      <p>
        BEGINブロックは、いくつでも定義できます。
      </p>
      <p>
        BEGINブロックの実行順序は、保証されません。他のパッケージにBEGINブロックが定義されている場合は、そのBEGINブロックが先に実行されることを想定しないでください。
      </p>
      <p>
        BEGINブロックの一般的な用途は、<a href="#language-package-var">パッケージ変数</a>を初期化することです。
      </p>
<pre>
package Foo {
  our $NUM : int;
  our $POINT : Point;
  BEGIN {
    $NUM = 3;
    $POINT = Point->new;
  }
}
</pre>

      <h3 id="language-lex-var">レキシカル変数</h3>
      <ul class="list">
        <li><a href="#language-lex-var-declaration">レキシカル変数の宣言</a></li>
        <li><a href="#language-lex-var-initial-value">レキシカル変数の初期値</a></li>
        <li><a href="#language-lex-var-access">レキシカル変数へのアクセス</a></li>
      </ul>
      <h4 id="language-lex-var-declaration">レキシカル変数の宣言</h4>
      <p>
        レキシカル変数とは、<a href="#language-scope-block">スコープブロック</a>の中で利用できる、<a href="#language-scope">スコープ</a>を持つ変数のことです。C言語のローカル変数に該当します。
      </p>
<pre>
{
  my $num : int;
}
</pre>
      <p>
        レキシカル変数は「my」キーワードによって宣言します。「:」の後ろに「<a href="#language-type">型</a>」を指定する必要があります。
      </p>
<pre>
my $num : int;
</pre>
      <p>
        レキシカル変数は、<a href="#language-lex-var-initial-value">レキシカル変数の初期値</a>によって初期化されます。
      </p>
<pre>
# 0で初期化される
my $num : int;

# 0で初期化される
my $num : double;

# undefで初期化される
my $point : Point;

# reは0, imは0で初期化される
my $z : SPVM::Complex_2d;
</pre>
      <p>
        レキシカル変数の宣言と同時に初期化を行うことができます。
      </p>
<pre>
# 1で初期化される
my $num : int = 1;

# 2.5で初期化される
my $num : double = 2.5;

# Pointオブジェクトで初期化される
my $point : Point = new Point;
</pre>
      <p>
        <a href="#language-type-inference">型推論</a>を使うと、宣言するときに、型の指定を省略することができます。
      </p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;
</pre>
      <p>
        レキシカル変数の宣言は、レキシカル変数の値を返します。これは、<a href="#language-expression">式</a>として利用できます。
      </p>
<pre>
my $ppp = my $bar = 4;

if (my $bar = 1) {
  
}

while (my $bar = 1) {
  
}
</pre>

      <p>
        レキシカル変数の宣言は、レキシカル変数が<a href="#language-type-object">オブジェクト型</a>であった場合に、レキシカル変数を、モータル変数として、実行時に登録します。モータル変数として登録されたレキシカル変数に代入されているオブジェクトは、<a href="#language-scope">スコープ</a>の末尾で、リファレンスカウントが自動的に1減らされます。
      </p>

      <h4 id="language-lex-var-initial-value">レキシカル変数の初期値</h4>
      <p>
        レキシカル変数は、<a href="#language-type-initial-value">型の初期値</a>で初期化されます。
      </p>

      <h4 id="language-lex-var-access">レキシカル変数へのアクセス</h4>
      <p>
        レキシカル変数へのアクセスとは、レキシカル変数にアクセスして、値を取得したり、設定したりする操作のことです。
      </p>
      <p>
        <b>レキシカル変数の値の取得</b>については、<a href="#language-expression-get-lex-var">レキシカル変数の値の取得</a>を見てください。
      </p>
      <p>
        <b>レキシカル変数の値の設定</b>については、<a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a>を見てください。
      </p>
      
      <h3 id="language-block">ブロック</h3>
      <p>
        「{」と「}」で囲まれた部分のことをブロックと呼びます。
      </p>
<pre>
# ブロック
{

}
</pre>
      <p>
        ブロックの中には、スコープを作る<a href="#language-scope-block">スコープブロック</a>があります。
      </p>

      <h3 id="language-scope">スコープ</h3>
      <ul class="list">
        <li><a href="#language-scope-role">スコープの役割</a>
        <li><a href="#language-scope-block">スコープブロック</a>
      </ul>

      <h4 id="language-scope-role">スコープの役割</h4>
      <p>
        スコープとは<a href="#language-scope-block">スコープブロック</a>に囲まれた範囲のことをいいます。
      </p>
<pre>
# スコープブロック
{

}
</pre>
      <p>
        スコープの中で宣言されたレキシカル変数は、実行時に、宣言されている位置で、モータルなレキシカル変数として登録されます。
      </p>
<pre>
{
  # レキシカル変数をモータルとして登録
  my $num = new Foo;
}
</pre>
      <p>
        モータルなレキシカル変数に代入されたオブジェクトが、未定義値ではない場合は、リファレンスカウントが1増やされます。
      </p>
      <p>
        スコープの終わりに到達すると、モータルなレキシカル変数に代入されているオブジェクトは、未定義値でない場合、リファレンスカウントが1減らされ、0になった場合は、解放されます。
      </p>
      <h4 id="language-scope-block">スコープブロック</h4>
      <p>
        スコープブロックとは、スコープを作るブロックのことです。スコープブロックには、0個以上の<a href="#language-statement">文</a>を記述することができます。
      </p>
<pre>
# スコープブロック
{
  my $num = 1;
  $num++;
}
</pre>
      <p>
        <b>スコープブロックの一覧</b>
      <p>
      <ul class="list">
        <li><a href="#language-block-statement-simple">単純なブロック</a></li>
        <li><a href="#language-block-statement-sub">サブルーチンブロック</a></li>
        <li><a href="#language-block-statement-eval">evalブロック</a></li>
        <li><a href="#language-block-statement-if">ifブロック</a></li>
        <li><a href="#language-block-statement-elsif">elsifブロック</a></li>
        <li><a href="#language-block-statement-else">elseブロック</a></li>
        <li><a href="#language-block-statement-for">forブロック</a></li>
        <li><a href="#language-block-statement-while">whileブロック</a></li>
        <li><a href="#language-block-statement-switch">switchブロック</a></li>
      </ul>

      <h5 id="language-block-statement-simple">単純なブロック</h5>
<pre>
# 単純なブロック
{

}
</pre>

      <h5 id="language-block-statement-sub">サブルーチンブロック</h5>
<pre>
# サブルーチンのブロック
sub : int () {

}
</pre>

      <h5 id="language-block-statement-eval">evalブロック</h5>
<pre>
# evalブロック
eval {

}
</pre>

      <h5 id="language-block-statement-if">ifブロック</h5>
<pre>
# ifブロック
if (条件1) {

}
</pre>

      <h5 id="language-block-statement-elsif">elsifブロック</h5>
<pre>
#elsifブロック
elsif (条件2) {

}
</pre>

      <h5 id="language-block-statement-else">elseブロック</h5>
<pre>
# elseブロック
else {

}
</pre>

      <h5 id="language-block-statement-for">forブロック</h5>
<pre>
# for ブロック
for (my $i = 0; $i < 3; $i++) {

}
</pre>

      <h5 id="language-block-statement-while">whileブロック</h5>
<pre>
# whileブロック
while (条件) {

}
</pre>

      <h5 id="language-block-statement-switch">switchブロック</h5>
<pre>
switch (条件) {

}
</pre>

      <h3 id="language-exception">例外処理</h3>
      <ul class="list">
        <li><a href="#language-exception-summary">例外処理の概要</a></li>
        <li><a href="#language-exception-occur">例外の発生</a></li>
        <li><a href="#language-exception-catch">例外変数のキャッチ</a></li>
        <li><a href="#language-exception-var">例外変数</a></li>
      </ul>
      
      <h4 id="language-exception-summary">例外処理の概要</h4>
      <p>
        SPVMは例外処理の仕組みを持っています。例外処理は、例外の発生と例外のキャッチからなります。
      </p>

      <h4 id="language-exception-occur">例外の発生</h4>
      <p>
        例外の発生を行うには、croak文を使用します。
      </p>
<pre>
croak 式;
</pre>
      <p>
        式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
      </p>
      <p>
        croak文が実行されると、スタックトレースと式で指定された文字列を表示して、プログラムは終了します。スタックトレースは、パッケージ名、サブルーチン名、ファイル名、行番号を含みます。ファイル名は、モジュールをロードしたパスからの相対ファイル名です。
      </p>
<pre>
Error
  from TestCase::Minimal->sum2 at TestCase/Minimal.spvm line 1640
  from TestCase->main at TestCase.spvm line 1198
</pre>

      <h4 id="language-exception-occur">例外のキャッチ</h4>
      <p>
        例外のキャッチとは、例外がスローされた場合に、プログラムが終了するのを止め、エラーメッセージを取得できる機能のことです。
      </p>
      <p>
        例外のキャッチは、evalブロック文を使って行います。evalブロック文は、末尾にセミコロンが必要なので気をつけてください。
      </p>
<pre>
eval {
  # 例外を投げる可能性のある処理
};
</pre>
      <p>
        evalブロックで例外をキャッチした場合は、プログラムの終了は止められ、<a href="#language-exception-var">例外変数</a>に<a href="#language-exception-occur">例外の発生</a>で指定したメッセージが代入されます。
      </p>
      
      <h4 id="language-exception-var">例外変数</h4>
      <p>
        例外変数は「$@」で表現されるグローバル変数のことです。
      </p>
<pre>
$@
</pre>
      <p>
        例外変数は、本当の意味では、グローバル変数ではありません。例外変数は、実は、スレッド変数です。SPVMはシングルスレッド設計なので、例外変数は、グローバル変数として振舞うように見えます。ネイティブにおいてスレッドを利用する場合に、違いがあります。
      </p>
      <p>
        例外変数の値の取得については、<a href="#language-expression-get-exception-var">例外変数の値の取得</a>を見てください。
      </p>
      <p>
        例外変数の値の設定については、<a href="#language-expression-set-exception-var">例外変数の値の設定</a>を見てください。
      </p>

      <h3 id="language-weak-ref">ウィークリファレンス</h3>
      <p>
        ウィークリファレンスとは、リファレンスカウントを増やさない参照のことです。ウィークリファレンスを使用すると、循環参照の問題を解決することができます。
      </p>
      <p>
        SPVMは、リファレンスカウント型のGCを持ちます。リファレンスカウント型のGCにおいては、リファレンスカウントが0になった場合に、オブジェクトは自動的に開放されますが、循環参照が発生した場合は、リファレンスカウントが0にならず、オブジェクトが自動的に解放されません。
      </p>
      <p>
        オブジェクトのフィールドが、循環参照している場合のサンプルです。
      </p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;

  $foo->{bar} = $bar;
  $bar->{foo} = $foo;
}
</pre>
      <p>
        この場合は、スコープが終了しても、両方のオブジェクトは解放されません。なぜなら、循環参照が発生しており、リファレンスカウントが0にならないためです。
      </p>
      <p>
        ウィークリファレンスは、リファレンスカウントGCを持つプログラミング言語において、循環参照が発生した場合に、オブジェクトの破棄を正しく行うための機能です。
      </p>
      <p>
        このような場合は、ひとつのフィールドを、<a href="#language-statement-weaken">weaken文</a>を使って、ウィークリファレンスに設定することで、正しく解放することができます。
      </p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;

  $foo->{bar} = $bar;
  $bar->{foo} = $foo;
  
  weaken $foo->{bar};
}
</pre>
      <p>
        weaken文が実行される前の、$fooのリファレンスカウントは2、$barのリファレンスカウントは2です。
      </p>
      <p>
        もしweaken文がない場合は、スコープが終了したとしても、$fooのリファレンスカウントも、$barのリファレンスカウントも0にならず、解放されません。
      </p>
      <p>
        weaken文が実行されるとは、$fooのリファレンスカウントは2、$barのリファレンスカウントは1になります。
      </p>
      <p>
        スコープが終了すると、$barのリファレンスカウントが1減らされ0になるので、正しく解放されます。
      </p>
      <p>
        3つの循環参照の場合でも、ひとつのフィールドにウィークリファレンスを設定すれば、正しく解放できます。
      </p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;
  my $baz = new Baz;

  $foo->{bar} = $bar;
  $bar->{baz} = $baz;
  $baz->{foo} = $foo;
  
  weaken $foo->{bar};
}
</pre>
      <p>
        ウィークリファレンス関連の文法として、ウィークリファレンスを解除できる<a href="#language-statement-weaken">weaken文</a>と、フィールドがウィークリファレンスかどうかを確認できる<a href="#language-operator-isweak">isweak演算子</a>があります。
      </p>
      
      <h3 id="language-interface">インターフェース</h3>
      <p>
        SPVMにおけるインターフェースとは、実装を持たないメソッドが一つだけ定義されたパッケージ型のことをいいます。<a href="#language-package-definition">パッケージの定義</a>においてinterface_tデスクリプタを指定すると、インターフェースになります。
      </p>
      <p>
        インターフェースは、<a href="#language-type-interface">インターフェース型</a>と同じ意味です。
      </p>
      <p>
        インターフェース型の目的は、異なるオブジェクトが、同じメソッド定義を持つときに、どちらも代入できる型を提供することにあります。C言語の関数ポインタに該当する機能をSPVMにおいて実現するものと考えてください。
      </p>
<pre>
package Foo1 : public {
  sub bar : int ($self : self, $num : int) {
    return $num * 2;
  }
  
  sub xxx : int () {
    
  }
}

package Foo2 : public {
  sub bar : int ($self : self, $num : int) {
    return $num * 3;
  }
  sub yyy : int () {
    
  }
}

package FooInterface : interface_t {
  sub bar : int ($self : self, $num : int);
}
</pre>
      
      <p>
        Foo1とFoo2は同じメソッド定義「sub bar : int ($self : self, $num : int)」を持ちます。ここで、選択的にFoo1またはFoo2のメソッドを呼び出したいとします。
      </p>
      <p>
        この場合に、同じメソッド定義を持つインターフェース型FooInterfaceを定義すると、この型にどちらのオブジェクトも代入できます。そして、このオブジェクトから、メソッドを呼び出すことができます。
      </p>
<pre>
my $foo1 = new Foo1;
my $foo2 = new Foo2;

my $foo : FooInterface;

my $flag = 1;
if ($flag) {
  $foo = $foo1;
}
else {
  $foo = $foo2;
}

my $ret = $foo->bar(2);
</pre>
      <p>
        $flagが1の場合は、Foo1のbarが、そうでない場合はFoo2のbarが呼び出されます。
      </p>
      <p>
        インターフェース型の詳細については、<a href="#language-type-interface">インターフェース型</a>を見てください。
      </p>
      
      <h4 id="language-exception-summary">例外処理の概要</h4>
      
      <h3 id="language-array">配列</h3>
      <ul class="list">
        <li><a href="#language-array-summary">配列の概要</a></li>
        <li><a href="#language-array-new">配列の生成</a></li>
        <li><a href="#language-array-access">配列へのアクセス</a></li>
      </ul>
      <h4 id="language-array-summary">配列の概要</h4>
      <p>
        配列とは、複数の値の連続領域を表現するためのデータ構造です。
      </p>
      <p>
        配列には次の種類があります。
      </p>
      <ul class="list">
        <li>
          数値型の配列
        </li>
        <li>
          オブジェクト型の配列
        </li>
        <li>
          値型の配列
        </li>
      </ul>
      <p>
        数値型の配列とは、<a href="#language-type-numeric">数値型</a>の値が連続に並んだ配列のことです。
      </p>
      <p>
        オブジェクト型の配列とは、<a href="#language-type-object">オブジェクト型</a>の値が連続に並んだ配列のことです。
      </p>
      <p>
        値型の配列とは、<a href="#language-type-value">値型</a>の値が連続に並んだ配列のことです。
      </p>
      
      <h4 id="language-array-summary">配列の生成</h4>
      <p>
        配列を生成については、<a href="#language-expression-new-array">配列の生成</a>を見てください。
      </p>
      
      <h4 id="language-array-access">配列へのアクセス</h4>
      <p>
        配列へのアクセスとは、配列にアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
      </p>
<pre>
配列->[添え字]
</pre>

      <p>
        配列の取得については、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>を見てください。
      </p>
      <p>
        配列の設定については、<a href="#language-expression-set-set-array-element">配列の要素の値の設定</a>を見てください。
      </p>

      <h3 id="language-value">値</h3>
      <ul class="list">
        <li><a href="#language-value-definition">値型の定義</a></li>
        <li><a href="#language-value-usage">値型の使用</a></li>
        <li><a href="#language-value-access">値型のフィールドへのアクセス</a></li>
      </ul>
      
      <h4 id="language-value-definition">値型の定義</h3>
      <p>
        SPVMには、他の言語ではあまり見ることのない値というものがあります。
      </p>
      <p>
        値は、連続した数値を表現します。たとえば、連続した32bit符号付整数が3つであるとか、連続した倍精度浮動小数点が2つなどです。3次元の点、複素数、四元数などを表現することが想定されています。
      </p>
      <p>
        値を使用するには、最初に、値型を定義します。値型は、<a href="#language-package-definition">パッケージの定義</a>において、value_tデスクリプタを指定することで定義できます。
      </p>
<pre>
# 連続した32bit符号付整数が3つ
package Point_3i : value_t {
  has x : int;
  has y : int;
  has z : int;
}

連続した倍精度浮動小数点が2つ
package Complex_2d : value_t {
  re : double;
  im : double;
}
</pre>
      <p>
        すべてのフィールドは同じ<a href="#language-type-numeric">数値型</a>でなければなりません。
      </p>
      <p>
        値型の末尾は「_」「フィールドの個数」「値型のサフィックス」でなければなりません。
      </p>
      <p>
        <b>値型のサフィクスの一覧</b>
      </p>
      <table>
        <tr>
          <th>
            <b>数値型</b>
          </th>
          <th>
            サフィックス
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            b
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            s
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            i
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            l
          </td>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            f
          </td>
        </tr>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            d
          </td>
        </tr>
      </table>
      <p>
        サフィックスは、実際に定義されている数値型と対応している必要があります。
      </p>
      <p>
        数値型の定義において、フィールドの個数の最大は16です。
      </p>
      <p>
        不正な値型の定義の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        値型は、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>の型として利用することができます。
      </p>
      <p>
        値型は、<a href="#language-sub-definition">サブルーチンの定義</a>における引数の型として利用することができます。
      </p>
      <p>
        値型は、<a href="#language-sub-definition">サブルーチンの定義</a>における戻り値の型として利用することができます。
      </p>
      <p>
        値型は<a href="#language-type-array">配列型</a>の<a href="#language-type-basic">基本型</a>として利用することができます。
      </p>
<pre>
my $points = new Point_3i[5];
</pre>
      <p>
        値型は、フィールドの型として利用することはできません。
      </p>
      <p>
        値型は、パッケージ変数の型として利用することはできません。
      </p>
      <p>
        値型の値に対しては、リファレンスを生成することができます。
      </p>
<pre>
my $point : Point_3i;
my $point_ref = \$point;
</pre>
      <p>
        値型の値に、未定義値を代入することはできません。代入しようとした場合は、コンパイル時エラーが発生します。
      </p>

      <h3 id="language-value-array">値の配列</h3>
      <ul class="list">
        <li><a href="language-array-summary">値の配列の概要</a></li>
        <li><a href="language-array-access">値の配列へのアクセス</a></li>
      </ul>
      
      <h4 id="language-array-summary">値の配列の概要</h4>
      <p>
        値型の値は、<a href="#language-array">配列</a>にすることができます。
      </p>
<pre>
my $points = new Point_3i[5];

my $zs = new Complex_2d[5];
</pre>
      <p>
        値の配列は、値型の値が、連続したデータ構造をとります。配列の要素は、オブジェクトではなく、数値がメモリ上に一直線に並んで、配置されます。
      </p>
      <p>
        たとえば、Point_3i型の5の長さの配列であれば、Point_3i型は、int型の数値が3つ並んだ型で、長さが5なので、「5 * 3 = 15」個のint型の数値が、メモリ上に一直線に並んだデータになります。
      </p>
      <p>
        値の配列の型は、<a href="#language-type-array">配列型</a>です。
      </p>
      <p>
        値の配列の要素の型は、<a href="#language-type-value">値型</a>です。
      </p>
      
      <h4 id="language-array-access">値の配列へのアクセス</h4>
      <p>
        値の配列へのアクセスとは、値の配列にアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
      </p>
<pre>
配列->[添え字]
</pre>
      <p>
        値の配列へのアクセスは、配列のアクセスと同じ構文で行うことができます。
      </p>
      <p>
        配列の取得については、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>を見てください。
      </p>
      <p>
        配列の設定については、<a href="#language-expression-set-set-array-element">配列の要素の値の設定</a>を見てください。
      </p>

      <h4 id="language-value-usage">値型の使用</h3>
      <p>
        値型を使用するにはuse文を使って、モジュールをロードします。
      </p>
<pre>
use Point_3i;
use Complex_2d;
</pre>
      <p>
        次に、レキシカル変数の宣言を行います。レキシカル変数の宣言を行うと、連続した領域が、<a href="#language-sub-stack">サブルーチンのコールスタック</a>上に確保されます。フィールドのすべての値は、<a href="language-type-initial-value">型の初期値</a>で初期化されます。
      </p>
<pre>
my $point : Point_3i;
my $z : Complex_2d;
</pre>
      <p>
        値型の値は、オブジェクトではないので、<a href="#language-expression-new-object">オブジェクトの生成</a>の構文では生成できないことに注意してください。
      </p>

      <h4 id="language-value-access">値型のフィールドへのアクセス</h3>
      <p>
        値型のフィールドへのアクセスとは、値型のフィールドにアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
      </p>
<pre>
インボカント->{フィールド名}
</pre>
      <p>
        値型のフィールドの取得については、<a href="#language-expression-get-field-value">値型のフィールドの値の取得</a>を見てください。
      </p>
      <p>
        値型のフィールドの設定については、<a href="#language-expression-set-field-value">値型のフィールドの値の設定</a>を見てください。
      </p>
      <p>
        <b>値型のフィールドの値の取得・設定のサンプル</b>
      </p>
      <p>
        値型のフィールドの値の取得・設定のサンプルです。
      </p>
<pre>
$ival2->{x} = 1;
my $y = $ival2->{y};

$dval4->{t} = 2.5;
my $z = $dval4->{z};
</pre>

      <h4 id="language-array-summary">配列の生成</h4>
      
      <h3 id="language-term">項</h3>
      <p>
        算術演算子の両辺、サブルーチンの引数、ifの条件部などになることができる文法の最小の単位を「項」と呼びます。
      </p>
      <p>
        「項」には、「<a href="#language-expression">式</a>」と、<a href="#language-condition-part">条件部</a>のみに記述できる「<a href="#language-condition">条件</a>」があります。
      </p>
      <p>
        式と条件の違いは、条件は、式として利用できないということだけです。
      </p>
      <p>
        項は、代入演算子を除く、ほとんどの場合に、左から右の順番で評価されます。たとえば、以下の例では、3 * 3 が実行され結果は9になります。
      </p>
<pre>
  my $i = 2;
  my $j = ($i = 3）* $i;
</pre>
      <p>
        exceptionサブルーチンが例外を発生させた場合は、$jの値は、10のままです。
      </p>
<pre>
  my $j = 10;
  eval {
    excpetion() / ($j = 3);
  };
}
</pre>

      <h3 id="language-ref">リファレンス</h3>
      <ul>
        <li><a href="language-ref-summary">リファレンスの概要</a></li>
        <li><a href="language-ref-deref">デリファレンス</a></li>
      </ul>
      
      <h4 id="language-ref">リファレンスの概要</h4>
      <p>
        リファレンスとは、レキシカル変数のアドレスのことをいいます。リファレンスは、C言語のポインタに該当する機能を実現するために、設計されました。
      </p>
      <p>
        レキシカル変数のアドレスは、<a href="#language-operator-ref">リファレンス演算子</a>を使用して取得できます。<a href="#language-type-ref">リファレンス型</a>は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-value">値型</a>の後ろに「&」を続けたものになります。
      </p>
<pre>
# 数値型の変数のリファレンス
my $num : int;
my $num_ref : int& = \$num;

# 値型の変数のリファレンス
my $point : Point_3d;
my $point_ref : Point_3d& = \$point;
</pre>
      <p>
        $num_refの値は、レキシカル変数「$num」のアドレスになります。$point_refの値は、レキシカル変数「$point」のアドレスになります。
      </p>
      <p>
        リファレンス演算子の対象は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-value">値型</a>の値が格納された変数だけです。オブジェクト型の変数や定数に対して、使うことはできません。
      </p>
      <p>
        <a href="#language-type-ref">リファレンス型</a>の値は、サブルーチンの引数として利用することができます。
      </p>
<pre>
# サブルーチンの定義
sub sum : void ($out_ref : int&, $in1 : int, $in2 : int) {
  $$out_ref = $in1 + $in2;
}

# サブルーチンの利用
my $num1 = 1;
my $num2 = 2;
my $out : int;
my $out_ref = \$out;
sum($out_ref, $num1, $num2);
</pre>

      <h4 id="language-ref-deref">デリファレンス</h4>
      <p>
        デリファレンスとは、アドレスの場所にあるレキシカル変数の値を取得・設定する操作をいいます。
      </p>
      <p>
        デリファレンスすることで、アドレスを通して値を取得したり、変更することができます。
      </p>
<pre>
# 数値型の値を取得
my $num2 = $$num_ref;

# 数値型の値を変更
$$num_ref = 3;

# 値型の値を取得
my $point2 = $$point_ref;

# 値型の値を設定
$$point_ref = $point2;
</pre>

      <p>
        リファレンス型の対象が値型であった場合に、値型のフィールドの設定と取得は、アロー演算子で行うことができます。
      </p>
<pre>
# リファレンス型の対象が値型であった場合に、値型のフィールドを取得
my $x = $point_ref->{x};

# リファレンス型の対象が値型であった場合に、値型のフィールドを設定
$point_ref->{x} = 1;
</pre>

      <h4 id="language-type-ref-numeric">数値のリファレンス型</h4>
      <p>
        数値のリファレンス型とは、<a href="#language-type-numeric">数値型</a>の変数に対する<a href="#language-type-ref">リファレンス型</a>のことをいいます。
      </p>
      <h4 id="language-type-ref-value">値のリファレンス型</h4>
      <p>
        値のリファレンス型とは、<a href="#language-type-value">値型</a>の変数に対する<a href="#language-type-ref">リファレンス型</a>のことをいいます。
      </p>
      
      </p>
      
      <h3 id="language-expression">式</h3>
      <ul class="list">
        <li class="language-expression-summary">式とは</li>
        <li class="language-expression-current-package">現在のパッケージ名の取得</li>
        <li class="language-expression-current-file">現在のファイル名の取得</li>
        <li class="language-expression-current-line">現在の行番号の取得</li>
      </ul>
      
      <h4 id="language-expression">式とは</h4>
      <p>
        式とは、値の評価が可能な<a href="#language-term">項</a>のことです。
      </p>
      <p>
        <b>式の一覧</b>
      </p>
      <ul class="list">
        <li><a href="#language-expression-get-lex-var">レキシカル変数の値の取得</a></li>
        <li><a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a></li>
        <li><a href="#language-expression-get-package-var">パッケージ変数の値の設定</a></li>
        <li><a href="#language-expression-set-package-var">パッケージ変数の値の取得</a></li>
        <li><a href="#language-expression-get-exception-var">例外変数の値の設定</a></li>
        <li><a href="#language-expression-set-exception-var">例外変数の値の取得</a></li>
        <li><a href="#language-literal">リテラル</a></li>
        <li><a href="#language-undef">未定義値</a></li>
        <li><a href="#language-expression-callsub">サブルーチンの呼び出し</a></li>
        <li><a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a></li>
        <li><a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a></li>
        <li><a href="#language-expression-get-field-value">値型のフィールドの値の取得</a></li>
        <li><a href="#language-expression-set-field-value">値型のフィールドの値の設定</a></li>
        <li><a href="#language-expression-get-field-value-deref">デリファレンスによる値型のフィールドの取得</a></li>
        <li><a href="#language-expression-set-field-value-deref">デリファレンスによる値型のフィールドの設定</a></li>
        <li><a href="#language-expression-get-array-element">配列の要素の値の取得</a></li>
        <li><a href="#language-expression-set-array-element">配列の要素の値の設定</a></li>
        <li><a href="#language-expression-typecast">型キャスト</a></li>
        <li><a href="#language-expression-new-object">オブジェクトの生成</a></li>
        <li><a href="#language-expression-new-array">配列の生成</a></li>
        <li><a href="#language-expression-release-object">オブジェクトの解放</a></li>
        <li><a href="#language-expression-array-init">配列の初期化</a></li>
        <li><a href="#language-operator-array-length">配列長演算子</a></li>
        <li><a href="#language-operator-string-length">文字列長演算子</a></li>
        <li><a href="#language-operator-arithmetic">算術演算子</a></li>
        <li><a href="#language-operator-bit">ビット演算子</a></li>
        <li><a href="#language-operator-shift">シフト演算子</a></li>
        <li><a href="#language-operator-concat">文字列連結演算子</a></li>
        <li><a href="#language-operator-ref">リファレンス演算子</a></li>
        <li><a href="#language-operator-deref">リファレンス演算子</a></li>
        <li><a href="#language-operator-assign">代入演算子</a></li>
        <li><a href="#language-operator-array-length">配列長演算子</a></li>
        <li><a href="#language-operator-string-length">文字列長演算子</a></li>
        <li><a href="#language-operator-scalar">スカラ演算子</a></li>
        <li><a href="#language-expression-current-package">現在のパッケージ名の取得</a></li>
        <li><a href="#language-expression-current-file">現在のファイル名の取得</a></li>
        <li><a href="#language-expression-current-line">現在の行番号の取得</a></li>
        <li>(式)</li>
      </ul>
      
      <h4 id="language-expression-get-lex-var">レキシカル変数の値の取得</h4>
      <p>
        レキシカル変数の値の取得をするには、レキシカル変数自体を記述します。
      </p>
<pre>
$var
</pre>
      <p>
        レキシカル変数の値の取得は、<a href="#language-expression">式</a>です。
      </p>

      <h4 id="language-expression-set-lex-var">レキシカル変数の値の設定</h4>
      <p>
        レキシカル変数の値の設定を行うには、<a href="#language-operator-assign">代入演算子</a>を使用します。
      </p>
<pre>
$var = 右式
</pre>
      <p>
        代入が<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        レキシカル変数の値の設定は、設定後の値を返します。
      </p>
      <p>
        レキシカル変数の値の設定は、<a href="#language-expression">式</a>です。
      </p>
      <p>
        右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
      </p>
      <p>
        代入前に、すでに$varにオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
      </p>
      
      <h4 id="language-expression-get-package-var">パッケージ変数の値の取得</h4>
      <p>
        パッケージ変数の値を取得するには以下の構文を使用します。
      </p>
<pre>
$クラス名::パッケージ変数名
</pre>
      <p>
        自分自身のパッケージに属するパッケージ変数の場合は「クラス名::」を省略できます。
      </p>
<pre>
$パッケージ変数名
</pre>
      <p>
       パッケージ変数の値の取得は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        定義されていないパッケージ変数の値を取得しようとした場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        パッケージの外側からプライベートなパッケージ変数にアクセスしようとした場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>パッケージ変数の値の取得のサンプル</b>
      </p>
<pre>
package Foo {
  our $VAR : int;
  
  sub bar : int () {
    my $var1 = $Foo::VAR;
    my $var2 = $VAR;
  }
}
</pre>

      <h4 id="language-expression-set-package-var">パッケージ変数の値の設定</h4>
      <p>
        パッケージ変数の値を設定するには以下の構文を使用します。
      </p>
<pre>
$クラス名::パッケージ変数名 = 右式
</pre>
        自分自身のパッケージに属するパッケージ変数の場合は「クラス名::」を省略できます。
      </p>
<pre>
$パッケージ変数名 = 右式
</pre>
      <p>
        パッケージ変数設定は、<a href="#language-expression">式</a>を返します。返される結果は、代入後のパッケージ変数の値です。
      </p>
      <p>
        定義されていないパッケージ変数の値を設定しようとした場合は、コンパイル時エラーが設定します。
      </p>
      <p>
        パッケージの外側からプライベートなパッケージ変数にアクセスしようとした場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>パッケージ変数の値の設定のサンプル</b>
      </p>
<pre>
package Foo {
  our $VAR : int;
  
  sub bar : int () {
    $Foo::VAR = 1;
    $VAR = 3;
  }
}
</pre>

      <h4 id="language-expression-get-exception-var">例外変数の値の取得</h4>
      <p>
        例外変数の値を取得するには以下の構文を使用します。
      </p>
<pre>
$@
</pre>
      <p>
       例外変数の値の取得は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
       例外変数の値の取得は、<a href="#language-type-string">文字列型</a>の値を返します。
      </p>
      <p>
        <b>例外変数の値の取得のサンプル</b>
      </p>
      <p>
        例外変数の値の取得のサンプルです。
      </p>
<pre>
eval {
  foo();
};

if (my $message = $@) {
  
}
</pre>

      <h4 id="language-expression-set-exception-var">例外変数の値の設定</h4>
      <p>
        例外変数の値を設定するには以下の構文を使用します。
      </p>
<pre>
$@ = 右式
</pre>
      <p>
        右式は<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
      </p>
      <p>
       例外変数の値の設定は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
       例外変数の値の設定は、設定後の例外変数の値を返します。これは、<a href="#language-type-string">文字列型</a>です。
      </p>
      <p>
        <b>例外変数の値の設定のサンプル</b>
      </p>
      <p>
        例外変数の値の設定のサンプルです。
      </p>
<pre>
$@ = "Error";
</pre>

      <h4 id="language-expression-get-field-class">クラス型のフィールドの値の取得</h4>
      <p>
        クラス型のフィールドの値の取得は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名}
</pre>
      <p>
        インボカント式は、<a href="#language-type-class">クラス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-value">値型</a>の値であった場合は、<a href="#language-expression-get-field-value">値型のフィールドの値の取得</a>になり、<a href="#language-type-ref-value">値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-value-deref">デリファレンスによる値型のフィールドの取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        クラス型のフィールドの値の取得は、オブジェクトに保存されているフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>クラス型のフィールドの値の取得のサンプル</b>
      </p>
      <p>
        クラス型のフィールドの値の取得のサンプルです。
      </p>
<pre>
my $point = Point->new;
my $x = $point->{x};
</pre>
      
      <h4 id="language-expression-set-field-class">クラス型のフィールドの値の設定</h4>
      <p>
        クラス型のフィールドの値の設定は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名} = 右式
</pre>
      <p>
        インボカント式は、<a href="#language-type-class">クラス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-value">値型</a>の値であった場合は、<a href="#language-expression-get-field-value">値型のフィールドの値の設定</a>になり、<a href="#language-type-ref-value">値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-value-deref">デリファレンスによる値型のフィールドの設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        クラス型のフィールドの値の設定は、設定後のオブジェクトに保存されているフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
      </p>
      <p>
        代入前に、すでにフィールドにオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
      </p>
      <p>
        <b>クラス型のフィールドの値の設定のサンプル</b>
      </p>
      <p>
        クラス型のフィールドの値の設定のサンプルです。
      </p>
<pre>
my $point = Point->new;
$point->{x} = 1;
</pre>
      
      <h4 id="language-expression-get-field-value">値型のフィールドの値の取得</h4>
      <p>
        値型のフィールドの値の取得は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名}
</pre>
      <p>
        インボカント式は、<a href="#language-type-class">値型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>になり、<a href="#language-type-ref-value">値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-value-deref">デリファレンスによる値型のフィールドの取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        値型のフィールドの値の取得は、<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>値型のフィールドの値の取得のサンプル</b>
      </p>
      <p>
        値型のフィールドの値の取得のサンプルです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
my $re = $z->{re};
</pre>

      <h4 id="language-expression-set-field-value">値型のフィールドの値の設定</h4>
      <p>
        値型のフィールドの値の設定は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名} = 右式
</pre>
      <p>
        インボカント式は、<a href="#language-type-class">値型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>になり、<a href="#language-type-ref-value">値のリファレンス型</a>の値であった場合は、<a href="#language-expression-set-field-value-deref">デリファレンスによる値型のフィールドの設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        値型のフィールドの値の設定は、設定後の<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>値型のフィールドの値の設定のサンプル</b>
      </p>
      <p>
        値型のフィールドの値の設定のサンプルです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
$z->{re} = 2.5;
</pre>

      <h4 id="language-expression-get-field-value-deref">デリファレンスによる値型のフィールドの値の取得</h4>
      <p>
        デリファレンスによる値型のフィールドの値の取得は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名}
</pre>
      <p>
        インボカント式は、<a href="#language-type-ref-value">値のリファレンス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>になり、<a href="#language-type-value">値型</a>の値であった場合は、<a href="#language-expression-get-field-value">値型のフィールドの値の取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デリファレンスによる値型のフィールドの値の取得は、<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>デリファレンスによる値型のフィールドの値の取得のサンプル</b>
      </p>
      <p>
        デリファレンスによる値型のフィールドの値の取得のサンプルです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
my $re = $z_ref->{re};
</pre>

      <h4 id="language-expression-set-field-value-deref">デリファレンスによる値型のフィールドの値の設定</h4>
      <p>
        デリファレンスによる値型のフィールドの値の設定は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名} = 右式
</pre>
      <p>
        インボカント式は、<a href="#language-type-ref-value">値のリファレンス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>になり、<a href="#language-type-value">値型</a>の値であった場合は、<a href="#language-expression-set-field-value">値型のフィールドの値の設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デリファレンスによる値型のフィールドの値の設定は、設定後の<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>デリファレンスによる値型のフィールドの値の設定のサンプル</b>
      </p>
      <p>
        デリファレンスによる値型のフィールドの値の設定のサンプルです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{re} = 2.5;
</pre>
      
      <h4 id="language-expression-get-array-element">配列の要素の値の取得</h4>
      <p>
        配列の要素の値を取得するには、次のように記述します。
      </p>
<p>
配列式->[インデックス式]
</p>
      <p>
        配列式は、<a href="#language-type-array">配列型</a>の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        インデックス式は、int型の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        配列の要素の値を取得は、指定したインデックスの要素の値を返します。これは、式です。
      </p>
      <p>
        実行時に、配列式の値が、未定義値である場合は、実行時例外が発生します。
      </p>
      <p>
        実行時に、インデックスの値が、0より小さい場合、あるいは、配列の最大のインデックスを超えている場合は、実行時例外が発生します。
      </p>
      <p>
        <b>配列の要素の値の取得のサンプル</b>
      </p>
      <p>
        配列の要素の値の取得のサンプルです。
      </p>
<pre>
my $nums = new int[3];
my $num = $nums->[1];

my $points = new Point[3];
my $point = $points->[1];

my $objects : oarray = $points;
my $object = (Point)$objects->[1];
</pre>
      
      <h4 id="language-expression-set-array-element">配列の要素の値の設定</h4>
      <p>
        配列の要素の値を設定するには、次のように記述します。
      </p>
<p>
配列式->[インデックス式] = 右式
</p>
      <p>
        配列式は、<a href="#language-type-array">配列型</a>の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        インデックス式は、int型の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        右式の型は、配列の要素の型と<a href="#language-type-compatible">型の互換性</a>がなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        配列の要素の値を設定は、設定後の値を返します。これは、式です。
      </p>
      <p>
        実行時に、配列式の値が、未定義値である場合は、実行時例外が発生します。
      </p>
      <p>
        実行時に、インデックスの値が、0より小さい場合、あるいは、配列の最大のインデックスを超えている場合は、実行時例外が発生します。
      </p>
      <p>
        右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
      </p>
      <p>
        代入前に、すでに配列の要素にオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
      </p>
      <p>
        <b>配列の要素の値の設定のサンプル</b>
      </p>
      <p>
        配列の要素の値の設定のサンプルです。
      </p>
<pre>
my $nums = new int[3];
$nums->[1] = 3;

my $points = new Point[3];
$points->[1] = Point->new(1, 2);

my $objects : oarray = $points;
$objects->[2] = Point->new(3, 5);;
</pre>

      <h4 id="language-expression-new-object">オブジェクトの生成</h4>
      <p>
        オブジェクトを生成するには、newキーワードと以下の構文をを使用します。
      </p>
<pre>
my $object = new パッケージ名;
</pre>
      <p>
        指定されたパッケージは、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドは、すべて<a href="language-type-initial-value">型の初期値</a>で初期化されます。
      </p>
      <p>
        オブジェクトの生成は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        生成直後のオブジェクトのリファレンスカウントは、0です。代入が実行されるタイミングで、リファレンスカウントが1増やされます。明示的な代入が行われない場合でも、一時変数が作成され、そこに代入されます。
      </p>
      <p>
        <b>オブジェクトの生成のサンプル</b>
      </p>
<pre>
my $object = new Foo;
</pre>
      <p>
        生成されたオブジェクトは内部的に次の情報を持っています。
      </p>
      <ul class="list">
        <li>リファレンスカウント</li>
        <li>ウィークリファレンスのバックリファレンス</li>
        <li>基本型のID</li>
        <li>型の次元(常に0)</li>
      </ul>
      
      <h4 id="language-expression-new-array">配列の生成</h4>
      <p>
        配列を作成するには、newキーワードと以下の構文をを使用します。
      </p>
<pre>
my $object = new 型[要素数式];
</pre>
      <p>
        型には、<a href="#language-type-numeric">数値型</a>、<a href="#language-type-object">オブジェクト型</a>、<a href="#language-type-value">値型</a>が指定できます。それ以外の型を指定した場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        要素数式は、int型以下の<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        要素数式に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        要素数式で指定された長さの配列が生成されます。
      </p>
      <p>
        配列の要素は、すべて<a href="language-type-initial-value">型の初期値</a>で初期化されます。
      </p>
      <p>
        配列において、要素は、メモリ上に連続していることが保証されます。
      </p>
      <p>
        配列の生成は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        配列は、<a href="#language-type-object">オブジェクト型</a>です。
      </p>
      <p>
        <b>配列の生成のサンプル</b>
      </p>
<pre>
my $nums = new int[3];
my $objects = new Foo[3];
my $objects = new object[3];
my $values = new Complex_2d[3]
</pre>
      <p>
        生成された配列は、内部的に次の情報を持っています。
      </p>
      <ul class="list">
        <li>リファレンスカウント</li>
        <li>基本型のID</li>
        <li>型の次元(1以上の値)</li>
        <li>配列の長さ</li>
      </ul>
      <p>
        多次元配列は、上記の構文を使用して、作成できます。要素は、<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
      </p>
<pre>
my $nums = new int[][3];
my $nums = new int[][][3];
</pre>
      <p>
        多次元配列の次元数の最大は、255です。
      </p>
      
      <h4 id="language-expression-array-init">配列の初期化</h4>
      <p>
        SPVMには、配列の生成を簡単にするための配列の初期化の構文があります。式はなくてもかまいません。
      </p>
<pre>
[]
[式1, 式2, 式3]
</pre>
      <p>
        配列の初期化は、式の要素数の長さを持った配列を返します。
      </p>
      <p>
        配列の型は、式1の型を配列型にしたものです。要素が指定されない場合は、<a href="#language-type-any-object">汎用オブジェクト型</a>を配列型にしたものになります。
      </p>
      <p>
        式2以降が、<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイルエラーになります。
      </p>

      <h4 id="language-expression-callsub">サブルーチンの呼び出し</h4>
      <p>
        <a href="#language-sub-definition">サブルーチンの定義</a>によって定義されたサブルーチンは呼び出すことができます。呼び出しには、2種類あって、<b>関数の呼び出し</b>と<b>メソッドの呼び出し</b>があります。
      </p>
      
      <h5 id="language-expression-callsub-func">関数の呼び出し</h5>
      <p>
        関数の呼び出しとは、<a href="#language-sub-method">メソッド</a>ではないサブルーチンを呼び出す方法のことをいいます。メソッドかどうかの判断は、<a href="#language-sub-definition">サブルーチンの定義</a>において、第一引数に<a href="#language-type-self">self型</a>の引数が指定されていた場合が、メソッドになります。
      </p>
      <p>
        関数の呼び出しは以下の方法で行うことができます。引数は、なくても構いません。最大で255個の引数を指定できます。
      </p>
<pre>
パッケージ名->サブルーチン名(引数1, 引数2, 引数3, ..., 引数n);
</pre>
      <p>
        Perlにおいてクラスメソッドの呼び出しと呼ばれているものが、SPVMでは、関数の呼び出しと呼ばれていることに注意してください。
      </p>
      <p>
        関数の呼び出しでは、パッケージ名を省略することもできます。
      </p>
<pre>
サブルーチン名(引数1, 引数2, 引数3, ..., 引数n);
</pre>
      <p>
        どのパッケージのサブルーチンが呼び出されるかは、以下の順番によって決まります。
      </p>
      <p>
        1. 現在のパッケージで定義されているサブルーチン、または現在のパッケージにインポートされたサブルーチン
      </p>
      <p>
        2. 標準関数 - COREパッケージで定義されているサブルーチン
      </p>
      
      <p>
        関数の呼び出しは、引数を受け取ります。引数の個数が、サブルーチンの定義で定義されている引数の個数と一致しない場合は、コンパイル時エラーが発生します。それぞれの引数の型が、サブルーチン定義で定義されている引数の型と<a href="#language-type-compatible">型の互換性</a>がない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        関数の呼び出しは、戻り値がvoid型以外の場合は、戻り値を返します。
      </p>
      <p>
        関数の呼び出しは、<a href="#language-expression">式</a>です。
      <p>
      <p>
        <b>サブルーチン呼び出しのサンプル</b>
      </p>
      <p>
        サブルーチン呼び出しのサンプルです。
      </p>
<pre>
my $ret = Foo->bar(1, 2, 3);
my $ret = bar(1, 2, 3);
</pre>

      <h5 id="language-expression-callsub-method">メソッドの呼び出し</h5>
      <p>
        メソッドの呼び出しとは、<a href="#language-sub-method">メソッド</a>であるサブルーチンを呼び出す方法のことをいいます。メソッドかどうかの判断は、<a href="#language-sub-definition">サブルーチンの定義</a>において、第一引数に<a href="#language-type-self">self型</a>の引数が指定されていた場合が、メソッドになります。
      </p>
      <p>
        メソッドの呼び出しは、<a href="#language-expression-new-object">オブジェクトの生成</a>によって生成されたオブジェクトを使って以下の構文で行うことができます。
      </p>
<pre>
オブジェクト->サブルーチン名(引数1, 引数2, 引数3, ..., 引数n);
</pre>
      <p>
        メソッドの呼び出しは、引数を受け取ります。引数の個数が、サブルーチンの定義で定義されている引数の個数と一致しない場合は、コンパイル時エラーが発生します。それぞれの引数の型が、サブルーチン定義で定義されている引数の型と<a href="#language-type-compatible">型の互換性</a>がない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        メソッドの呼び出しは、戻り値がvoid型以外の場合は、戻り値を返します。
      </p>
      <p>
        メソッドの呼び出しは、<a href="#language-expression">式</a>です。
      <p>
      <p>
        <b>メソッドの呼び出しのサンプル</b>
      </p>
      <p>
        メソッドの呼び出しのサンプルです。
      </p>
<pre>
my $point = new Point;
$point->set_x(3);
</pre>
      <p>
        <a href="#language-sub-anon">無名サブルーチン</a>の呼び出しは、メソッドの呼び出しになります。この場合は、名前なしで呼び出すことができます。
      </p>
<pre>
オブジェクト->(引数1, 引数2, 引数3, ..., 引数n);
</pre>

      <p>
        <b>無名サブルーチンの呼び出しのサンプル</b>
      </p>
      <p>
        無名サブルーチンの呼び出しのサンプルです。
      </p>
<pre>
my $anon_sub = sub : int ($self: self, $num1 : int, $num2 : int) {
  return $num1 + $num2;
};

my $ret = $anon_sub->(1, 2);
</pre>

      <h4 id="language-operator-deref-get">デリファレンスによる値の取得</h4>
      <p>
        デリファレンスによる値の取得とは、リファレンスから実際の値を取得するための操作のことです。C言語の関節演算子「*」を実現するために設計されました。
      </p>
<pre>
$変数
</pre>
      <p>
        変数の型は、リファレンス型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デリファレンスによる値の取得は、<a href="#language-expression">式</a>を返します。
      </p>
      <pre>
        <b>デリファレンスによる値の取得のサンプル</b>
      </pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
my $num_deref : int = $$num_ref;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
my $z_deref : SPVM::Complex_2d = $$z_ref;
</pre>

      <h4 id="language-operator-deref-set">デリファレンスによる値の設定</h4>
      <p>
        デリファレンスによる値の設定とは、リファレンスから実際の値を設定するための操作のことです。C言語の関節演算子「*」を実現するために設計されました。
      </p>
<pre>
$変数 = 式
</pre>
      <p>
        変数の型は、リファレンス型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        式の型は、デリファレンスされた場合の変数の型に一致していなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デリファレンスによる値の設定は、設定された値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <pre>
        <b>デリファレンスによる値の設定のサンプル</b>
      </pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
$$num_ref = 1;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;

my $z2 : SPVM::Complex_2d;

$$z_ref = $z2;
</pre>

      <h4 id="language-expression-current-package">現在のパッケージ名の取得</h4>
      <p>
        現在のパッケージ名の取得を行う「__PACKAGE__」キーワードを使用します。
      </p>
<pre>
__PACKAGE__
</pre>
      <p>
        現在のパッケージ名の取得は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>現在のパッケージ名の取得のサンプル</b>
      </p>
<pre>
package Foo::Bar {
  sub baz : void () {
    # Foo::Bar
    my $package_name == __PACKAGE__;
  }
}
</pre>
      <h4 id="language-expression-current-package">現在のファイル名の取得</h4>
      <p>
        現在のファイル名の取得を行う「__FILE__」キーワードを使用します。
      </p>
<pre>
__FILE__
</pre>
      <p>
        現在のファイル名の取得は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        現在のファイル名とは、モジュールの読み込みパスを基準とした、ファイルの相対パスのことをいいます。たとえば、ファイルの読み込みパスが「/mypath」でモジュール名が「Foo::Bar」であった場合は、絶対パスは「/mypath/Foo/Bar.spvm」で、相対パスは「Foo/Bar.spvm」です。相対パスである「Foo/Bar.spvm」が、現在のファイル名になります。
      </p>
      <p>
        <b>現在のファイル名の取得のサンプル</b>
      </p>
<pre>
# Foo/Bar.spvm
package Foo::Bar {
  sub baz : void () {
    # Foo/Bar.spvm
    my $file_name == __FILE__;
  }
}
package Foo::Bar2 {
  sub baz : void () {
    # Foo/Bar.spvm
    my $file_name == __FILE__;
  }
}
</pre>
      <h4 id="language-expression-current-package">現在の行番号の取得</h4>
      <p>
        現在の行番号の取得を行う「__LINE__」キーワードを使用します。
      </p>
<pre>
__LINE__
</pre>
      <p>
        現在の行番号の取得は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>現在の行番号の取得のサンプル</b>
      </p>
<pre>
package Foo::Bar {
  sub baz : void () {
    # 4
    my $line == __LINE__;
  }
}
</pre>

      <h3 id="language-expression-release-object">オブジェクトの解放</h3>
      <p>
        オブジェクトは、リファレンスカウントが0になるとメモリから解放されます。
      </p>
      <p>
        オブジェクトが、オブジェクト型の値を要素として持つ配列だった場合は、オブジェクトの解放の前に、未定義値ではないすべての配列の要素のリファレンスカウントが1減らされます
      </p>
      <p>
        オブジェクトが、クラス型で、オブジェクト型のフィールドを持つときは、オブジェクトの解放の前に、未定義値ではないすべてのオブジェクト型のフィールドが所有するオブジェクトのリファレンスカウントが1減らされます。フィールドに保存されているオブジェクトにウィークリファレンスが設定されていた場合は、リファレンスカウントが1減らされる前に、ウィークリファレンスが解除されます。
      </p>
      <p>
        オブジェクトがウィークリファレンスのバックリファレンスを持つときは、バックリファレンスとして登録されているフィールドすべてに、未定義値を代入し、バックリファレンスをすべて削除します。
      </p>
      <p>
        上記の処理は、再帰的に行われます。
      </p>

      <h3 id="language-condition">条件</h3>
      <p>
        条件は次の項目で定義されます。
      </p>
      <p>
        <b>条件の一覧</b>
      </p>
      <ul class="list">
        <li><a href="#language-operator-comparison">比較演算子</a></li>
        <li><a href="#language-operator-logical">論理演算子</a></li>
        <li>(条件)</li>
      </ul>
      <p>
        条件の結果は、真または偽です。
      </p>
      <p>
        最後の「(条件)」というのは、条件を「()」で囲ったという意味です。
      </p>

      <h3 id="language-condition-part">条件部</h3>
      <p>
        条件部とは、条件判定が行われる部分のことです。条件部には「<a href="#language-term">項</a>」が記述できます。
      </p>
      <p>
        <b>if文のかっこの中</b>
      </p>
<pre>
if (条件部) {

}
</pre>
      <p>
        <b>unless文のかっこの中</b>
      </p>
<pre>
unless (条件部) {

}
</pre>
      <p>
        <b>forのかっこの中の二つ目</b>
      </p>
<pre>
for (初期化;条件部;次の値;) {

}
</pre>
      <p>
        <b>whileのかっこの中</b>
      </p>
<pre>
while (条件部) {

}
</pre>
      <p>
        <b>論理AND演算子の左右</b>
      </p>
<pre>
条件部 && 条件部
</pre>
      <p>
        <b>論理OR演算子の左右</b>
      </p>
<pre>
条件部 || 条件部
</pre>
      <p>
        <b>論理否定演算子の右側</b>
      </p>
<pre>
!条件部
</pre>
      <p>
        条件部に式が書かれた場合は、結果の型はint型です。
      </p>
      <p>
        式は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-object">オブジェクト型</a>あるいは<a href="#language-type-undef">未定義型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        条件部に式が書かれた場合は、型に応じた結果を返します。
      </p>
      <p>
        式が<a href="#language-undef">未定義値</a>である場合は、0を返します。
      </p>
      <p>
        式が、<a href="#language-type-numeric">数値型</a>の場合は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        型がint型の場合は、その値を返します。
      </p>
      <p>
        型がlong型、float型、double型、オブジェクト型である場合は、C99における以下の演算と完全に一致する演算を行います。
      </p>
<pre>
!!x
</pre>
      
      <h3 id="language-literal">リテラル</h3>
      <ul class="list">
        <li><a href="#language-literal-integer">整数リテラル</a></li>
        <li><a href="#language-literal-floating-point">浮動小数点リテラル</a></li>
        <li><a href="#language-literal-character">文字リテラル</a></li>
        <li><a href="#language-literal-string">文字列リテラル</a></li>
      </ul>
      <h4 id="language-literal-integer">整数リテラル</h3>
      <p>
        <b>10進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は「0～9」の1つ以上の連続した文字で表現されます。
      </p>
      <p>
        先頭に「+」あるいは「-」の符号をつけることができます。
      </p>
      <p>
        整数リテラルの型は、デフォルトでは「int型」になります。
      </p>
      <p>
        整数リテラルがint型で表現できる数値の範囲を超えている場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        末尾に「L」あるいは「l」のサフィックスをつけることで「long型」の整数リテラルを表現できます。
      </p>
      <p>
        long型の整数リテラルの場合は、long型で表現できる数値の範囲を超えている場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        区切り文字として「_」を使用することができます。区切り文字は意味を持ちません。
      </p>
      <p>
        不正な整数リテラルの表現はコンパイル時エラーが発生します。
      </p>
      <p>
        整数リテラルがbyte型の変数に代入される場合、あるいはbyte型のサブルーチンの引数として渡される場合で、byte型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>によって、byte型に自動的に変換されます。範囲を超えている場合は、コンパイル時エラーとなります。
      </p>
      <p>
        整数リテラルがshort型の変数に代入される場合、あるいはshort型のサブルーチンの引数として渡される場合で、short型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>によって、short型に自動的に変換されます。範囲を超えている場合は、コンパイル時エラーとなります。
      </p>
      <p>
        整数リテラルのサンプルです。
      </p>
<pre>
123
+123
-123
123L
123l
123_456_789
-123_456_789L
</pre>
      <p>
        <b>16進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>16進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を16進数を使って表現するときは「0x」から始めます。
      </p>
      <p>
        その後ろに「0～9」「a～f」「A～F」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な16進数表現は、コンパイル時エラーが発生します。
      </p>
      <p>
        整数リテラルを16進数で表現したサンプルです。
      </p>
<pre>
0x3b4f
-0x3F1A
0xDeL
0xFFFFFFFF_FFFFFFFF
</pre>

      <p>
        <b>8進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>8進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を8進数を使って表現するときは「0」から始めます。
      </p>
      <p>
        その後ろに「0～7」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な8進数表現は、コンパイル時エラーが発生します。
      </p>
      <p>
        整数リテラルを8進数で表現したサンプルです。
      </p>
<pre>
0755
-0644
0666L
0655_755
</pre>
      <p>
        <b>2進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>2進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を2進数を使って表現するときは「0b」から始めます。
      </p>
      <p>
        その後ろに「0」か「1」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な2進数表現は、コンパイル時エラーが発生します。
      </p>
      <p>
        整数リテラルを2進数で表現したサンプルです。
      </p>
<pre>
0b0101
-0b1010
0b110000L
0b10101010_10101010
</pre>


      <h4 id="language-literal-floating-point">浮動小数点リテラル</h3>
      <p>
        浮動小数点リテラルは「符号部」「数値部」「指数部」「サフィックス」から構成されます。
      <p>
      <p>
        浮動小数点リテラルには「10進数浮動小数点リテラル」と「16進数浮動小数点リテラル」があります。
      </p>
      <p>
        「符号部」は「+」か「-」で表現されます。「符号部」の存在は、任意です。「符号部」が存在する場合は、先頭にある必要があります。
      </p>
      <p>
        「10進数浮動小数点リテラル」は、数値部が「一桁以上の10進数字」で始まる必要があります。
      </p>
      <p>
        「10進数字」とは「0～9」のことです。
      </p>
      <p>
        「10進数浮動小数点リテラル」は、数値部に「小数点」が含まれているか、含まれていない場合は「指数部」あるいは「サフィックス」が必要です。
      </p>
      <p>
        「小数点」とは「.」のことです。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、数値部が「0x」あるいは「0X」で始まり、その後ろに「一桁以上の16進数字」が続く必要があります。
      </p>
      <p>
        16進数字とは「0～9」「a～f」「A～F」のことです。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、「数値部」に「小数点」を含むことができます。
      </p>
      <p>
        「数値部」はアンダーライン「_」を含むことができます。これは単なる区切り文字で、無視されます。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、「指数部」が必要です。
      </p>
      <p>
        「指数部」は「指数表現」と「符号付10進整数」で構成されます。
      </p>
      <p>
        「指数表現」は「10進数浮動小数点リテラル」の場合は「e」あるいは「E」、「16進数浮動小数点リテラル」の場合は「p」あるいは「P」になります。
      </p>
      <p>
        「指数部」の意味は「10進数浮動小数点リテラル」の場合は、10進数による桁移動、「16進数浮動小数点リテラル」の場合は、2進数による桁移動になります。
      </p>
      <p>
        末尾に「f」あるいは「F」のサフィックスをつけると、浮動小数点リテラルの型は「float型」になります。
      </p>
      <p>
        末尾に「d」あるいは「D」のサフィックスをつけると、浮動小数点リテラルの型は「double型」になります。
      </p>
      <p>
        サフィックスが省略された場合は、浮動小数点リテラルの型は「double型」になります。
      </p>
      <p>
        浮動小数点リテラルが「float型」の場合はC標準の「strtof関数」を使って、文字列からfloat型への変換が行われます。変換が失敗した場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        浮動小数点リテラルが「double型」の場合はC標準の「strtod関数」を使って、文字列からdouble型への変換が行われます。変換が失敗した場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        無限大を表現する浮動小数点リテラルはありません。標準関数である「<a href="#stdfunc-INFINITY">INFINITY関数</a>」「<a href="#stdfunc-INFINITYF">INFINITYF関数</a>」を使用してください。
      </p>
      <p>
        非値を表現する浮動小数点リテラルはありません。標準関数である「<a href="#stdfunc-NAN">NAN関数</a>」「<a href="#stdfunc-NANF">NANF関数</a>」を使用してください。
      </p>
      <p>
        浮動小数点リテラルのサンプルです
      </p>
<pre>
1.32
-1.32
1.32f
1.32F
1.32e3
1.32e-3
1.32E+3
1.32E-3
0x3d3d.edp0
0x3d3d.edp3
0x3d3d.edP3
0x3d3d.edP-3f
</pre>

      <h4 id="language-literal-character">文字リテラル</h3>
      <p>
        文字リテラルは、シングルクォート「'」で囲まれます。
      </p>
      <p>
        文字リテラルの内容は「ひとつのAsciiの印字可能文字」あるいは「ひとつのエスケープ文字」です。
      </p>
      <p>
        文字リテラルの型は「byte型」になります。
      </p>
      <p>
        不正な文字リテラルの場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>エスケープ文字</b>
      </p>
      <table class="toc">
        <tr>
          <th>
            エスケープ文字
          </th>
          <th>
            説明
          </th>
        </tr>
        <tr>
          <td>
            <b>\0</b>
          </td>
          <td>
            Asciiコードの0「NUL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\a</b>
          </td>
          <td>
            Asciiコードの7「BEL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\b</b>
          </td>
          <td>
            Asciiコードの8「BS」
          </td>
        </tr>
        <tr>
          <td>
            <b>\t</b>
          </td>
          <td>
            Asciiコードの9「HT」
          </td>
        </tr>
        <tr>
          <td>
            <b>\n</b>
          </td>
          <td>
            Asciiコードの10「LF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\f</b>
          </td>
          <td>
            Asciiコードの12「FF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\r</b>
          </td>
          <td>
            Asciiコードの13「CR」
          </td>
        </tr>
        <tr>
          <td>
            <b>\"</b>
          </td>
          <td>
            Asciiコードの34「"」
          </td>
        </tr>
        <tr>
          <td>
            <b>\'</b>
          </td>
          <td>
            Asciiコードの39「'」
          </td>
        </tr>
        <tr>
          <td>
            <b>\\</b>
          </td>
          <td>
            Asciiコードの92「\」
          </td>
        </tr>
        <tr>
          <td>
            <b>\xの後ろに二桁の16進数</b>
          </td>
          <td>
            直接Asciiコードを指定します。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
      </table>
      
      <p>
        <b>文字リテラルのサンプル</b>
      </p>
      <p>
        文字リテラルのサンプルです。
      </p>
<pre>
# 文字リテラル
'a'
'x'

# エスケープ文字を使った文字リテラル
'\a'
'\b'
'\t'
'\n'
'\f'
'\r'
'\"'
'\''
'\\'
'\x0D'
'\x0A'
</pre>
      
      <h4 id="language-literal-string">文字列リテラル</h3>
      <p>
        文字列リテラルは、ダブルクォート「"」で囲まれます。
      </p>
      <p>
        文字列リテラルの内容は「0個以上のAsciiの印字可能文字あるいはエスケープ文字」です。
      </p>
      <p>
        文字列リテラルの型は「string型」になります。
      </p>
      <p>
        不正な文字列リテラルの場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>エスケープ文字</b>
      </p>
      <table class="toc">
        <tr>
          <th>
            エスケープ文字
          </th>
          <th>
            説明
          </th>
        </tr>
        <tr>
          <td>
            <b>\0</b>
          </td>
          <td>
            Asciiコードの0「NUL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\a</b>
          </td>
          <td>
            Asciiコードの7「BEL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\b</b>
          </td>
          <td>
            Asciiコードの8「BS」
          </td>
        </tr>
        <tr>
          <td>
            <b>\t</b>
          </td>
          <td>
            Asciiコードの9「HT」
          </td>
        </tr>
        <tr>
          <td>
            <b>\n</b>
          </td>
          <td>
            Asciiコードの10「LF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\f</b>
          </td>
          <td>
            Asciiコードの12「FF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\r</b>
          </td>
          <td>
            Asciiコードの13「CR」
          </td>
        </tr>
        <tr>
          <td>
            <b>\"</b>
          </td>
          <td>
            Asciiコードの34「"」
          </td>
        </tr>
        <tr>
          <td>
            <b>\'</b>
          </td>
          <td>
            Asciiコードの39「'」
          </td>
        </tr>
        <tr>
          <td>
            <b>\\</b>
          </td>
          <td>
            Asciiコードの92「\」
          </td>
        </tr>
        <tr>
          <td>
            <b>\xの後ろに二桁の16進数</b>
          </td>
          <td>
            直接Asciiコードを指定します。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
        <tr>
          <td>
            <b>\N{}の中の複数桁の16進数</b>
          </td>
          <td>
            Unicodeのコードポイントを16進数で指定します。UTF-8に変換されます。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
      </table>
      <p>
        Unicodeのコードポイントを指定するエスケープ文字以外は、<a href="#language-literal-character">文字リテラル</a>のエスケープ文字と共通です。
      </p>
      <p>
        <b>文字列リテラルのサンプル</b>
      </p>
      <p>
        文字列リテラルのサンプルです。
      </p>
<pre>
# 文字列リテラル
"abc"
"あいう"

# エスケープ文字を使った文字列リテラル
"abc\tdef\n"
"\x0D\x0A"
"\N{U+3042}\N{U+3044}\N{U+3046}"
</pre>
      
      <h3 id="language-string">文字列</h3>
      <p>
        SPVMの文字列のデータ表現は、byte型の配列です。特別な内部表現を持たない、単なるバイト列です。
      </p>
<pre>
my $string = new byte[3];
$string->[0] = 'a';
$string->[1] = 'b';
$string->[2] = 'c';
</pre>
      <p>
        byte型の配列は、<a href="#language-type-string">文字列型</a>に代入できます。文字列型は、コンパイル時には要素を変更できない型ですが、実行時はbyte型の配列になります。
      </p>
<pre>
my $string_const : string = $string;
</pre>
      <p>
        <a href="#language-literal-string">文字列リテラル</a>を代入することによって、文字列を作成できます。文字列リテラルを元にしたstring型の新しい文字列を返します。
      </p>
<pre>
my $string_const = "abc";
</pre>
      <p>
        byte[]はC言語の「char*」、文字列型はC言語の「const char*」に該当するように設計されています。
      </p>
      
      <h3 id="language-undef">未定義値</h3>
      <p>
        未定義は「undef」で表現されます。
      </p>
<pre>
undef
</pre>
      <p>
        未定義値は、任意のオブジェクト型の変数に代入することができます。
      </p>
      <p>
        未定義値はオブジェクト型の値と「==」「!=」演算子を使用して、比較することができます。未定義値は、生成されたオブジェクトと等しくない事が保証されます。
      </p>
      <p>
        未定義は条件部で使われた場合は、偽になります。
      </p>
      <p>
        未定義値は、エクステンションにおいてC言語の値として利用された場合は、0と等しくなることが保証されます。
      </p>
      <h3 id="language-operator">演算子</h3>
      <ul class="list">
        <li><a href="#language-operator-summary">演算子の概要</a></li>
        <li><a href="#language-operator-unary">単項演算子</a></li>
        <li><a href="#language-operator-binary">二項演算子</a></li>
        <li><a href="#language-operator-sequential">順次演算子</a></li>
        <li><a href="#language-operator-arithmetic">算術演算子</a></li>
        <li><a href="#language-operator-unary-plus">単項プラス演算子</a></li>
        <li><a href="#language-operator-unary-minus">単項マイナス演算子</a></li>
        <li><a href="#language-operator-add">加算演算子</a></li>
        <li><a href="#language-operator-subtract">減算演算子</a></li>
        <li><a href="#language-operator-multiply">乗算演算子</a></li>
        <li><a href="#language-operator-divide">除算演算子</a></li>
        <li><a href="#language-operator-remainder">剰余演算子</a></li>
        <li><a href="#language-operator-inc">インクリメント演算子</a></li>
        <li><a href="#language-operator-dec">デクリメント演算子</a></li>
        <li><a href="#language-operator-bit">ビット演算子</a></li>
        <li><a href="#language-operator-bit-and">ビットAND演算子</a></li>
        <li><a href="#language-operator-bit-or">ビットOR演算子</a></li>
        <li><a href="#language-operator-bit-not">ビット否定演算子</a></li>
        <li><a href="#language-operator-shift">シフト演算子</a></li>
        <li><a href="#language-operator-left-shift">左シフト演算子</a></li>
        <li><a href="#language-operator-arithmetic-right-shift">算術右シフト演算子</a></li>
        <li><a href="#language-operator-logical-right-shift">論理右シフト演算子</a></li>
        <li><a href="#language-operator-comparison">比較演算子</a></li>
        <li><a href="#language-operator-comparison-numeric">数値比較演算子</a></li>
        <li><a href="#language-operator-comparison-string">文字列比較演算子</a></li>
        <li><a href="#language-operator-isa">isa演算子</a></li>
        <li><a href="#language-operator-logical">論理演算子</a></li>
        <li><a href="#language-operator-logical-and">論理AND演算子</a></li>
        <li><a href="#language-operator-logical-or">論理OR演算子</a></li>
        <li><a href="#language-operator-logical-not">論理NOT演算子</a></li>
        <li><a href="#language-operator-concat">文字列連結演算子</a></li>
        <li><a href="#language-operator-assign">代入演算子</a></li>
        <li><a href="#language-operator-assign-special">特殊代入演算子</a></li>
        <li><a href="#language-operator-ref">リファレンス演算子</a></li>
        <li><a href="#language-operator-array-length">配列長演算子</a></li>
        <li><a href="#language-operator-string-length">文字列長演算子</a></li>
        <li><a href="#language-operator-scalar">スカラ演算子</a></li>
        <li><a href="#language-operator-isweak">isweak演算子</a></li>
      </ul>
      
      <h4 id="language-operator-summary">演算子の概要</h4>
      <p>
        演算子は、<a href="#language-operator-unary">単項演算子</a>、<a href="#language-operator-binary">二項演算子</a>、<a href="#language-operator-inc">インクリメント演算子</a>、<a href="#language-operator-dec">デクリメント演算子</a>、<a href="#language-operator-comparison">比較演算子</a>、<a href="#language-operator-logical">論理演算子</a>、<a href="#language-operator-assign">代入演算子</a>からなります。
      </p>
      
      <h4 id="language-operator-unary">単項演算子</h4>
      <p>
        単項演算子とは、<a href="#language-term">項</a>の前に置かれる演算子のことをいいます。
      </p>
<pre>
単項演算子 項
</pre>
      <p>
        単項演算子には、<a href="#language-operator-unary-plus">単項プラス演算子</a>、<a href="#language-operator-unary-minus">単項マイナス演算子</a>、<a href="#language-operator-bit-not">ビット否定演算子</a>、<a href="#language-operator-logical-not">論理否定演算子</a>、<a href="#language-operator-array-legnth">配列長演算子</a>、<a href="#language-operator-string-legnth">文字列長演算子</a>があります。
      </p>
      <p>
        インクリメント演算子とデクリメント演算子は、単項演算子には含まれません。
      </p>

      <h4 id="language-operator-binary">二項演算子</h4>
      <p>
        二項演算子とは、左項と右項の間に置かれる演算子のことをいいます。項については、<a href="#language-term">項</a>を参考にしてください。
      </p>
<pre>
左項 二項演算子 右項
</pre>

      <p>
        二項演算子には、<a href="#language-operator-add">加算演算子</a>、<a href="#language-operator-subtract">減算演算子</a>、<a href="#language-operator-multiply">乗算演算子</a>、<a href="#language-operator-divide">除算演算子</a>、<a href="#language-operator-remainder">剰余演算子</a>、<a href="#language-operator-bit-and">ビットAND演算子</a>、<a href="#language-operator-bit-or">ビットOR演算子</a>、<a href="#language-operator-logical-and">論理AND演算子</a>、<a href="#language-operator-logical-or">論理OR演算子</a>、<a href="#language-operator-shift">シフト演算子</a>、<a href="#language-operator-concat">文字列連結演算子</a>があります。
      </p>
 
      <h4 id="language-operator-sequential">順次演算子</h4>
      <p>
        順次演算子とは、複数の<a href="#language-expression">式</a>を並べて記述でき、最後の値を返す演算子のことです。
      </p>
<pre>
(式1, 式2, 式3)
</pre>
      <p>
        式は左から実行されます。最後の値が返されます。
      <p>
      <p>
        順次演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>順次演算子のサンプル</b>
      </p>
      <p>
        順次演算子のサンプルです。
      </p>
<pre>
# $fooには3が代入される。
my $foo = (1, 2, 3);

# $xは3、$retは5になる
my $x = 1;
my $y = 2;
my $ret = ($x += 2, $x + $y);
</pre>

      <li><a href="#language-operator-sequential">順次演算子</a></li>

      <h4 id="language-operator-arithmetic">算術演算子</h4>
      <p>
        算術演算子は、算術を行う演算子のことで、<a href="#language-operator-add">加算演算子</a>、<a href="#language-operator-subtract">減算演算子</a>、<a href="#language-operator-multiply">乗算演算子</a>、<a href="#language-operator-divide">除算演算子</a>、<a href="#language-operator-remainder">剰余演算子</a>、<a href="#language-operator-unary-plus">単項プラス演算子</a>、<a href="#language-operator-unary-minus">単項マイナス演算子</a>、<a href="#language-operator-inc">インクリメント演算子</a>、<a href="#language-operator-dec">デクリメント演算子</a>からなります。
      </p>

      <h4 id="language-operator-unary-plus">単項プラス演算子</h4>
      <p>
        単項プラス演算子は「+」で表現される<a href="#language-operator-unary">単項演算子</a>です。
      </p>
<pre>
+式
</pre>
      <p>
        式は<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、単項プラス演算子は、与えられた値をコピーして返します。
      </p>
      <p>
        単項プラス演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        単項プラス演算子の結果の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
      </p>
      <p>
        単項プラス演算子は例外を発生させません。
      </p>
      <p>
        <b>単項プラス演算子のサンプル</b>
      </p>
<pre>
my $num = +10;
</pre>
      <h4 id="language-operator-unary-minus">単項マイナス演算子</h4>
      <p>
        単項マイナス演算子は「-」で表現される<a href="#language-operator-unary">単項演算子</a>です。
      </p>
<pre>
-式
</pre>
      <p>
        式は<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、単項マイナス演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
-x
</pre>
      <p>
        単項マイナス演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        単項マイナス演算子の結果の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
      </p>
      <p>
        単項マイナス演算子は例外を発生させません。
      </p>
      <p>
        <b>単項マイナス演算子のサンプル</b>
      </p>
<pre>
my $num = -10;
</pre>
      <h4 id="language-operator-add">加算演算子</h4>
      <p>
        加算演算子は「+」で表現される、加算を行うための<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 + 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、加算演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
x + y;
</pre>
      <p>
        加算演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        加算演算子の結果の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        加算演算子は、例外を発生させません。
      </p>
      <h4 id="language-operator-subtract">減算演算子</h4>
      <p>
        減算演算子は「-」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 - 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、減算演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
x - y;
</pre>
      <p>
        減算演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        減算演算子の結果の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        減算演算子は、例外を発生させません。
      </p>
      <h4 id="language-operator-multiply">乗算演算子</h4>
      <p>
        乗算演算子は「*」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 * 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、乗算演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
x * y;
</pre>
      <p>
        乗算演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        乗算演算子の結果の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        乗算演算子は、例外を発生させません。
      </p>
      <h4 id="language-operator-divide">除算演算子</h4>
      <p>
        除算演算子は「/」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 / 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、除算演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
x / y;
</pre>
      <p>
        除算演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        除算演算子の結果の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        整数型に対する演算の場合には、除算演算子は、右辺が0であった場合に、例外が発生します。
      </p>
      <p>
        浮動小数点型に対する演算の場合には、除算演算子は、例外を発生させません。
      </p>
      
      <h4 id="language-operator-remainder">剰余演算子</h4>
      <p>
        剰余演算子は「%」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 % 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、剰余演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x % y;
</pre>
      <p>
        剰余演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        剰余演算子の結果の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        剰余演算子は、右辺が0であった場合に、例外が発生します。
      </p>

      <h4 id="language-operator-inc">インクリメント演算子</h4>
      <p>
        インクリメント演算子は、値を1加算する演算子です。インクリメント演算子が前置されるか、後置されるかで、意味が変わります。
      </p>
<pre>
# 前置のインクリメント
++レキシカル変数
++パッケージ変数
++フィールドへのアクセス
++配列へのアクセス
++デリファレンス

# 後置のインクリメント
レキシカル変数++
パッケージ変数++
フィールドへのアクセス++
配列へのアクセス++
デリファレンス++
</pre>
      <p>
        インクリメント演算子の対象は、<a href="#language-lex-var">レキシカル変数</a>、<a href="#language-package-var">パッケージ変数</a>、<a href="#language-field-access">フィールドへのアクセス</a>、<a href="#language-array-access">配列へのアクセス</a>、<a href="#language-deref">デリファレンス</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        インクリメント演算子の対象の型は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイルエラーが発生します。
      </p>
      <p>
        <b>前置のインクリメント演算子</b>
      </p>
      <p>
        前置のインクリメント演算子は、インクリメントを行った後に、インクリメントされた値を返します。
      </p>
      <p>
        前置のインクリメント演算子は、次の式と等価です。対象に1が加算された後に、元の型で型キャストが行われ、対象に代入されます。
      </p>
<pre>
(対象 = (型キャスト)(対象 + 1))
</pre>
      <p>
        たとえば、byte型の値の前置のインクリメントは、次の式と等価です。
      </p>

<pre>
($num = (byte)($num + 1))
</pre>
      <p>
        <b>後置のインクリメント演算子</b>
      </p>
      <p>
        後置のインクリメント演算子は、インクリメントを行った後に、インクリメントする前の値を返します。
      </p>
      <p>
        後置のインクリメント演算子は、順次演算子を使った、次の式と等価です。対象が一時変数に保存され、対象に1が足された後に、元の型で型キャストが行われ、対象に代入されます。その後、一時変数が返されます。
      </p>
<pre>
(my 一時変数 = 対象, 対象 = (型キャスト)(対象 + 1), 一時変数)
</pre>
      <p>
        たとえば、byte型の値の後置のインクリメントは、次の式と等価です。
      </p>

<pre>
(my $tmp = $num, $num = (byte)($num + 1), $tmp)
</pre>

      <h4 id="language-operator-dec">デクリメント演算子</h4>
      <p>
        デクリメント演算子は、値を1減算する演算子です。デクリメント演算子が前置されるか、後置されるかで、意味が変わります。
      </p>
<pre>
# 前置のデクリメント
--レキシカル変数
--パッケージ変数
--フィールドへのアクセス
--配列へのアクセス
--デリファレンス

# 後置のデクリメント
レキシカル変数--
パッケージ変数--
フィールドへのアクセス--
配列へのアクセス--
デリファレンス--
</pre>
      <p>
        デクリメント演算子の対象は、<a href="#language-lex-var">レキシカル変数</a>、<a href="#language-package-var">パッケージ変数</a>、<a href="#language-field-access">フィールドへのアクセス</a>、<a href="#language-array-access">配列へのアクセス</a>、<a href="#language-deref">デリファレンス</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デクリメント演算子の対象の型は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイルエラーが発生します。
      </p>
      <p>
        <b>前置のデクリメント演算子</b>
      </p>
      <p>
        前置のデクリメント演算子は、デクリメントを行った後に、デクリメントされた値を返します。
      </p>
      <p>
        前置のデクリメント演算子は、次の式と等価です。対象に1が減算された後に、元の型で型キャストが行われ、対象に代入されます。
      </p>
<pre>
(対象 = (型キャスト)(対象 - 1))
</pre>
      <p>
        たとえば、byte型の値の前置のデクリメントは、次の式と等価です。
      </p>

<pre>
($num = (byte)($num - 1))
</pre>
      <p>
        <b>後置のデクリメント演算子</b>
      </p>
      <p>
        後置のデクリメント演算子は、デクリメントを行った後に、デクリメントする前の値を返します。
      </p>
      <p>
        後置のデクリメント演算子は、順次演算子を使った、次の式と等価です。対象が一時変数に保存され、対象に1が足された後に、元の型で型キャストが行われ、対象に代入されます。その後、一時変数が返されます。
      </p>
<pre>
(my 一時変数 = 対象, 対象 = (型キャスト)(対象 - 1), 一時変数)
</pre>
      <p>
        たとえば、byte型の値の後置のデクリメントは、次の式と等価です。
      </p>

<pre>
(my $tmp = $num, $num = (byte)($num - 1), $tmp)
</pre>

      <h4 id="language-operator-bit">ビット演算子</h4>
      <p>
        ビット演算子は、ビット演算を行う演算子のことで、><a href="#language-operator-bit-and">ビットAND演算子</a>、<a href="#language-operator-bit-or">ビットOR演算子</a>、<a href="#language-operator-bit-not">ビット否定演算子</a>からなります。
      </p>
      
      <h4 id="language-operator-bit-and">ビットAND演算子</h4>
      <p>
        ビットANDは「&」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 & 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、ビットAND演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x & y;
</pre>
      <p>
        ビットAND演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        ビットAND演算子の結果の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        ビットAND演算子は、例外を発生させません。
      </p>

      <h4 id="language-operator-bit-or">ビットOR演算子</h4>
      <p>
        ビットORは「|」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 | 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、ビットOR演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x | y;
</pre>
      <p>
        ビットOR演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        ビットOR演算子の結果の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        ビットOR演算子は、例外を発生させません。
      </p>
      
      <h4 id="language-operator-bit-not">ビット否定演算子</h4>
      <p>
        ビット否定演算子は「~」で表現される<a href="#language-operator-unary">単項演算子</a>です。
      </p>
<pre>
~式
</pre>
      <p>
        式は<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、ビット否定演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
~x
</pre>
      <p>
        ビット否定演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        ビット否定演算子の結果の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
      </p>
      <p>
        ビット否定演算子は例外を発生させません。
      </p>
      <p>
        <b>ビット否定演算子のサンプル</b>
      </p>
<pre>
my $num = ~0xFF0A;
</pre>

      <h4 id="language-operator-shift">シフト演算子</h4>
      <p>
        シフト演算子は、ビットシフトを行う演算子で、<a href="#language-operator-left-shift">左シフト演算子</a>、<a href="#language-operator-arithmetic-right-shift">算術右シフト演算子</a>、<a href="#language-operator-logical-right-shift">論理右シフト演算子</a>からなります。
      </p>
      <h4 id="language-operator-left-shift">左シフト演算子</h4>
      <p>
        左シフトは「<<」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 << 右式
</pre>
      <p>
        左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左シフト演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x << y;
</pre>
      <p>
        左シフト演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        左シフト演算子は、例外を発生させません。
      </p>

      <h4 id="language-operator-arithmetic-right-shift">算術右シフト演算子</h4>
      <p>
        算術右シフトは「>>」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 >> 右式
</pre>
      <p>
        左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        算術右シフト演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。xに対して、<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x >> y;
</pre>
      <p>
        算術右シフト演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        算術右シフト演算子は、例外を発生させません。
      </p>

      <h4 id="language-operator-logical-right-shift">論理右シフト演算子</h4>
      <p>
        論理右シフトは「>>>」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 >>> 右式
</pre>
      <p>
        左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        論理右シフト演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。xに対して、<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
(符号付整数型キャスト)((符号なし整数型キャスト)x >> y);
</pre>
      <p>
        論理右シフト演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        論理右シフト演算子は、例外を発生させません。
      </p>

      <h4 id="language-operator-comparison">比較演算子</h4>
      <p>
        比較演算子とは、左式と右式の間に置かれる演算子で、<a href="#language-condition">条件</a>を返す演算子のことをいいます。
      </p>
<pre>
左式 比較演算子 右式
</pre>
      <p>
        比較演算子には、<a href="#language-operator-comparison-numeric">数値比較演算子</a>、<a href="#language-operator-comparison-string">文字列比較演算子</a>、isa演算子があります。
      </p>
      
      <h4 id="language-operator-comparison-numeric">数値比較演算子</h4>
      <p>
        数値比較演算子とは、数値あるいはオブジェクトのアドレスを比較するために、左式と右式の間に置かれる演算子で、<a href="#language-condition">条件</a>を返す演算子のことをいいます。
      </p>
<pre>
左式 数値比較演算子 右式
</pre>
      <p>
        数値比較演算子の一覧です。
      </p>
      <table>
        <tr>
          <th>演算子</th>
          <th>比較可能な型</th>
          <th>解説</th>
        </tr>
        <tr>
          <td>
            左式 == 右式
          </td>
          <td>
            左式と右式が数値型、左式と右式がオブジェクト型(未定義値を含む)
          </td>
          <td>
            左式と右式が等しい
          </td>
        </tr>
        <tr>
          <td>
            左式 != 右式
          </td>
          <td>
            左式と右式が数値型、左式と右式がオブジェクト型(未定義値を含む)
          </td>
          <td>
            左式と右式が等しくない
          </td>
        </tr>
        <tr>
          <td>
            左式 > 右式
          </td>
          <td>
            左式と右式が数値型
          </td>
          <td>
            左式は右式より大きい
          </td>
        </tr>
        <tr>
          <td>
            左式 >= 右式
          </td>
          <td>
            左式と右式が数値型
          </td>
          <td>
            左式は右式より大きいまたは等しい
          </td>
        </tr>
        <tr>
          <td>
            左式 < 右式
          </td>
          <td>
            左式と右式が数値型
          </td>
          <td>
            左式は右式より小さい
          </td>
        </tr>
        <tr>
          <td>
            左式 <= 右式
          </td>
          <td>
            左式と右式が数値型
          </td>
          <td>
            左式は右式より小さいまたは等しい
          </td>
        </tr>
      </table>
      <p>
        左辺と右辺の型は、比較可能な型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        数値型の比較の場合は、左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、数値比較演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型、オブジェクト型における演算が定義されます。
      </p>
<pre>
# 数値型の比較、オブジェクト型の比較
x == y;
x != y;

# 数値型の比較
x > y;
x >= y;
x < y;
x <= y;
</pre>
      <p>
        数値比較演算子の結果の型は、int型です。真である場合は0以外の値を、偽である場合は0を返します。
      </p>
      <p>
        数値比較演算子は、例外を発生させません。
      </p>

      <h4 id="language-operator-comparison-string">文字列比較演算子</h4>
      <p>
        文字列比較演算子とは、文字列を比較するために、左式と右式の間に置かれる演算子で、<a href="#language-condition">条件</a>を返す演算子のことをいいます。
      </p>
<pre>
左式 文字列比較演算子 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
      </p>
      <p>
        文字列比較演算子の一覧です。
      </p>
      <table>
        <tr>
          <th>演算子</th>
          <th>解説</th>
        </tr>
        <tr>
          <td>
            左式 eq 右式
          </td>
          <td>
            左式と右式が等しい
          </td>
        </tr>
        <tr>
          <td>
            左式 ne 右式
          </td>
          <td>
            左式と右式が等しくない
          </td>
        </tr>
        <tr>
          <td>
            左式 gt 右式
          </td>
          <td>
            左式は右式より辞書式順序で比較して大きい
          </td>
        </tr>
        <tr>
          <td>
            左式 ge 右式
          </td>
          <td>
            左式は右式より辞書式順序で比較して大きいまたは等しい
          </td>
        </tr>
        <tr>
          <td>
            左式 lt 右式
          </td>
          <td>
            左式は右式より辞書式順序で比較して小さい
          </td>
        </tr>
        <tr>
          <td>
            左式 le 右式
          </td>
          <td>
            左式は右式より辞書式順序で比較して小さいまたは等しい
          </td>
        </tr>
      </table>
      <p>
        文字列比較演算子の結果の型は、int型です。真である場合は0以外の値を、偽である場合は0を返します。
      </p>
      <h4 id="language-operator-isa">isa演算子</h4>
      <p>
        数値比較演算子とは、数値あるいはオブジェクトのアドレスを比較するために、左式と右式の間に置かれる演算子で、<a href="#language-condition">条件</a>を返す演算子のことをいいます。
      </p>
      <p>
        isa演算子とはは、型の適合性をチェックするための演算子で、<a href="#language-condition">条件</a>を返します。
      </p>
<pre>
左式 isa 右型
</pre>
      <p>
        isa演算子は、右型に応じて、3種類の動作をします。
      </p>
      <p>
        1. 右型が、<a href="#language-type-numeric">数値型</a>、<a href="#language-type-value">値型</a>、<a href="#language-type-any-object">汎用オブジェクト型</a>、<a href="#language-type-ref">リファレンス型</a>の場合は、コンパイル時に左式の型が右型と同一のものであるかをチェックします。同一であった場合は真を、そうでない場合は偽を返します。
      </p>
      <p>
        2. 右型が、<a href="#language-type-class">クラス型</a>であった場合は、実行時に左式の型が、クラス型と一致するかをチェックします。一致した場合は真を、そうでない場合は偽を返します。左式の型は、オブジェクト型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        3. 右型が、<a href="#language-type-interface">インターフェース型</a>であった場合は、実行時に左式の型がクラス型であり、そのクラスがインターフェースを満たすかどうかをチェックします。満たした場合は真を、そうでない場合は偽を返します。左式の型は、オブジェクト型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      
      <h4 id="language-operator-logical">論理演算子</h4>
      <p>
        論理演算子は、論理演算を行う演算子のことで、><a href="#language-operator-logical-and">論理AND演算子</a>、<a href="#language-operator-logical-or">論理OR演算子</a>、<a href="#language-operator-logical-not">論理否定演算子</a>からなります。
      </p>
      <p>
        論理演算子は、<a href="#language-condition">条件</a>を返します。
      </p>
      
      <h4 id="language-operator-logical-and">論理AND演算子</h4>
      <p>
        論理AND演算子とは、論理AND演算を行うために、「&&」で表現される、<a href="#language-term">項</a>をオペランドとする<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左項 && 右項
</pre>
      <p>
        論理AND演算子は次のように動作します。
      </p>
      <p>
        1. 左項の評価が真であれば、右項を実行し、右項の評価が、真であれば、真を返し、右項の評価が偽であれば、偽を返します。
      </p>
      <p>
        2. 左項の評価が偽であれば、偽を返します。右項は実行されません。
      </p>
      <p>
        論理AND演算子の結果の型は、int型です。
      </p>
      <p>
        論理AND演算子は<a href="#language-condition">条件</a>を返します。
      </p>
      <p>
        論理AND演算子は、例外を発生させません。
      </p>
      
      <h4 id="language-operator-logical-and">論理OR演算子</h4>
      <p>
        論理OR演算子とは、論理OR演算を行うために、「||」で表現される、<a href="#language-term">項</a>をオペランドとする<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左項 || 右項
</pre>
      <p>
        論理OR演算子は次のように動作します。
      </p>
      <p>
        1. 左項の評価が真であれば、真を返します。右項は実行されません。
      </p>
      <p>
        2. 左項の評価が偽であれば、右項を実行し、右項の評価が、真であれば、真を返し、右項の評価が偽であれば、偽を返します。
      </p>
      <p>
        論理OR演算子の結果の型は、int型です。
      </p>
      <p>
        論理OR演算子は<a href="#language-condition">条件</a>を返します。
      </p>
      <p>
        論理OR演算子は、例外を発生させません。
      </p>

      <h4 id="language-operator-logical-and">論理NOT演算子</h4>
      <p>
        論理NOT演算子とは、論理NOT演算を行うために、項の左に置かれる演算子で、「!」で表現される<a href="#language-condition">条件</a>を返す<a href="#language-operator-binary">単項演算子</a>です。項については、<a href="#language-term">項</a>を参考にしてください。
      </p>
<pre>
!項
</pre>
      <p>
        論理NOT演算子は、項が真であれば、偽を返します。項が偽であれば、真を返します。
      </p>
      <p>
        論理NOT演算子の結果の型は、int型です。
      </p>
      <p>
        論理NOT演算子は<a href="#language-condition">条件</a>うぃを返します。
      </p>
      <p>
        論理NOT演算子は、例外を発生させません。
      </p>
      
      <h4 id="language-operator-concat">文字列連結演算子</h4>
      <p>
        文字列連結演算子は「.」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 . 右式
</pre>
      <p>
        左式あるいは右式が、<a href="#language-type-numeric">数値型</a>であった場合は、<a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a>によって文字列に変換されます。
      </p>
      <p>
        左式と右式はどちらも<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。そうでない場合は、コンパイルエラーになります。
      </p>
      <p>
        文字列連結演算子は、左式と右式で表現される<a href="#language-string">文字列</a>を連結し、新しい文字列を返します。
      </p>
      <p>
        文字列連結演算子は<a href="#language-expression">式</a>を返し、型は<a href="#language-type-string">文字列型</a>です。
      </p>
      <p>
        左式と右式の両方が、<a href="#language-literal-string">文字列リテラル</a>であった場合は、コンパイル時に連結された文字列リテラルが生成されます。パフォーマンスのコストを意識せずに、文字列連結演算子で、文字列リテラルを連結できます。
      </p>
      <p>
        実行時に、左式あるいは右式が<a href="#language-undef">未定義値</a>だった場合は、例外が発生します。
      </p>
      <p>
        <b>文字列連結演算子のサンプル</b>
      </p>
<pre>
my $str = "abc" . "def";
my $str = "def" . 34;
my $str = 123 . 456;
</pre>
      <h4 id="language-operator-assign">代入演算子</h4>
      <p>
        代入演算子は「=」で表現される、代入を行うための<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 = 右式
</pre>
      <p>
        代入演算子は、右辺と左辺によって、複数の意味を持ちます。各項目を参考にしてください。
      </p>
      <p>
        代入演算子においては、右式が評価された後に、左式が評価されます。これは、原則として、式は左から右へ実行されるということの例外です。
      </p>
      
      <ul>
        <li><a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a></li>
      </ul>
      
      <h4 id="language-operator-assign-special">特殊代入演算子</h4>
      <p>
        特殊代入演算子とは、<a href="#language-operator-binary">二項演算子</a>と<a href="#language-operator-assign">代入演算子</a>の組み合わせで表現される特殊な代入を行う<a href="#language-operator-binary">二項演算子</a>のことです。
      </p>
<pre>
左式 特殊代入演算子 右式
</pre>
      <p>
        左式と右式が<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>特殊代入演算子の一覧</b>
      </p>
      <p>
        特殊代入演算子の一覧です。
      </p>
      <table>
        <tr>
          <td>加算代入演算子</td>
          <td>+=</td>
        </tr>
        <tr>
          <td>減算代入演算子</td>
          <td>-=</td>
        </tr>
        <tr>
          <td>乗算代入演算子</td>
          <td>*=</td>
        </tr>
        <tr>
          <td>除算代入演算子</td>
          <td>/=</td>
        </tr>
        <tr>
          <td>剰余代入演算子</td>
          <td>%=</td>
        </tr>
        <tr>
          <td>ビットAND代入演算子</td>
          <td>&=</td>
        </tr>
        <tr>
          <td>ビットOR代入演算子</td>
          <td>|=</td>
        </tr>
        <tr>
          <td>左シフト代入演算子</td>
          <td><<=</td>
        </tr>
        <tr>
          <td>算術右シフト代入演算子</td>
          <td>>>=</td>
        </tr>
        <tr>
          <td>論理右シフト代入演算子</td>
          <td>>>>=</td>
        </tr>
      </table>
      <p>
        特殊代入演算子は、次のように展開されます。
      </p>
<pre>
# 展開前
左式 特殊代入演算子 右式

# 展開後
左式 代入演算子 (左式の型によるキャスト)(左式 指定された演算子 右式)
</pre>
      <p>
        たとえば、加算代入演算子の場合は、次のように展開されます。
      </p>
<pre>
# 展開前 xはbyte型
$x += 1;

# 展開後
$x = (byte)($x + 1)
</pre>
      <p>
        <b>特殊代入演算子のサンプル</b>
      </p>
      <p>
        特殊代入演算子のサンプルです。
      </p>
<pre>
$x += 1;
$x -= 1;
$x *= 1;
$x /= 1;
$x &= 1;
$x |= 1;
$x ^= 1;
$x %= 1;
$x <<= 1;
$x >>= 1;
$x >>>= 1;
</pre>
      <h4 id="language-operator-ref">リファレンス演算子</h4>
      <p>
        リファレンス演算子は、<a href="#language-type-numeric">数値型</a>または<a href="#language-type-value">値型</a>の変数のアドレスを取得する演算子です。C言語のアドレス演算子「&」を実現するために設計されました。
      </p>
<pre>
\変数
</pre>
      <p>
        変数が数値型または値型でなかった場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        リファレンス演算子は式を返します。返される型は、<a href="#language-type-ref">リファレンス型</a>です。
      </p>
      <pre>
        <b>リファレンス演算子のサンプル</b>
      </pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
</pre>
      <p>
        リファレンスの詳しい解説については、<a href="#language-ref">リファレンス</a>を見てください。
      </p>

      <h4 id="language-operator-array-length">配列長演算子</h4>
      <p>
        配列長演算子は、<a href="#language-array">配列</a>の長さを取得するための「@」で表現される<a href="#language-operator-binary">単項演算子</a>です。
      </p>
<pre>
@右式
</pre>
      <p>
        右式は、配列型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        配列長演算子は、配列の長さをint型の値で返します。
      </p>
      <p>
        配列長演算子は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>配列長演算子のサンプル</b>
      </p>
      <p>
        配列長演算子のサンプルです。
      </p>
<pre>
my $nums = new byte[10];
my $length = @$nums;
</pre>
      <p>
        SPVMにはPerlにおけるコンテキストという考え方はなく、配列長演算子は、常に配列の長さを返すことに注意してください。
      </p>

      <h4 id="language-operator-string-length">文字列長演算子</h4>
      <p>
        文字列長演算子は、<a href="#language-string">文字列</a>の長さを取得するための「length」で表現される<a href="#language-operator-binary">単項演算子</a>です。
      </p>
<pre>
length 右式
</pre>
      <p>
        右式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        文字列長演算子は、文字列の長さをint型の値で返します。文字列長演算子が返す文字列の長さは、バイト列としてみたときの長さでです。
      </p>
      <p>
        文字列長演算子は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>文字列長演算子のサンプル</b>
      </p>
      <p>
        文字列長演算子のサンプルです。
      </p>
<pre>
my $nums = "abcde";
my $length = length $nums;
</pre>

      <h4 id="language-operator-scalar">スカラ演算子</h4>
      <p>
        スカラ演算子は、何もしないで、与えられた値そのものを返す演算子です。<a href="language-operator-array-length">配列長演算子</a>の意味を分かりやすくするためだけに用意されています。
      </p>
<pre>
scalar 右式
</pre>
      <p>
        右式は<a href="language-operator-array-length">配列長演算子</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        スカラ演算子は、式を返します。
      </p>
      <p>
        <b>スカラ演算子のサンプル</b>
      </p>
      <p>
        スカラ演算子のサンプルです。
      </p>
<pre>
my $nums = new int[3];
foo(scalar @$nums);
</pre>

      <h4 id="language-operator-isweak">isweak演算子</h3>
      <p>
        isweak演算子は、フィールドが、<a href="#language-weak-ref">ウィークリファレンス</a>かを確認する演算子です。
      </p>
<pre>
isweak オブジェクト式->{フィールド名};
</pre>
      <p>
        オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名は、存在するフィールド名でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、偽を返します。これは、<a href="#language-condition">条件</a>です。
      </p>
      <p>
        isweak演算子は、フィールドがウィークリファレンスの場合は、真を、そうでない場合は偽を返します。これは、<a href="#language-condition">条件</a>です。
      </p>

      <h3 id="language-operator-precedence">演算子の優先順位</h3>
      <p>
        演算子の優先順位は、以下の通りです。下にいくほど、優先順位が高くなります。
      </p>
      <table>
        <tr>
          <th>結合方向</th>
          <th>演算子</th>
        </tr>
        <tr>
          <td>
            右結合
          </td>
          <td>
            <ul>
            代入演算子「=」<br>
            加算代入演算子「+=」<br>
            減算代入演算子「-=」<br>
            乗算代入演算子「*=」<br>
            除算代入演算子「/=」<br>
            剰余代入演算子「%=」<br>
            ビットAND代入演算子「&=」<br>
            ビットOR代入演算子「|=」<br>
            ビット排他OR代入演算子「^=」<br>
            左シフト代入演算子「<<=」<br>
            算術右シフト代入演算子「>>=」<br>
            論理右シフト演算子「>>>=」<br>
            文字列結合代入演算子「.=」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            条件OR演算子「||」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            条件AND演算子 「&&」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            ビットOR演算子「|」<br>
            ビットXOR演算子 「^」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            ビットAND演算子「&」
          </td>
        </tr>
        <tr>
          <td>
            非結合
          </td>
          <td>
            数値等価演算子「==」<br>
            数値非等価演算子「!=」<br>
            文字列等価演算子「eq」<br>
            文字列非等価演算子「ne」<br>
          </td>
        </tr>
        <tr>
          <td>
            非結合
          </td>
          <td>
            数値大なり演算子「>」<br>
            数値小なり演算子「<」<br>
            数値大なり等価演算子「>=」<br>
            数値小なり等価演算子「<=」<br>
            文字列大なり演算子「gt」<br>
            文字列大なり等価演算子「ge」<br>
            文字列小なり演算子「lt」<br>
            文字列小なり等価演算子「le」<br>
            isa演算子「isa」
          </td>
        </tr>
        <tr>
          <td>
            左結合 
          </td>
          <td>
            左シフト演算子 「<<」<br>
            符号付き右シフト演算子「>>」<br>
            符号なし右シフト演算子「>>>」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            加算演算子「+」<br>
            減算演算子「-」<br>
            文字列連結演算子「.」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            乗算演算子「*」<br>
            除算演算子「/」<br>
            剰余演算子「%」
          </td>
        </tr>
        <tr>
          <td>
            右結合
          </td>
          <td>
            条件NOT演算子「!」<br>
            ビットNOT演算子「~」<br>
            リファレンス演算子「\」<br>
            プラス演算子「+」<br>
            マイナス演算子「-」<br>
            配列長取得演算子「@」<br>
            デリファレンス演算子「$」<br>
            型キャスト「(型名)」
            スカラ演算子「scalar」<br>
            文字列長取得演算子「length」<br>
            require演算子「require」<br>
          </td>
        </tr>
        <tr>
          <td>
            非結合
          </td>
          <td>
            前置インクリメント演算子「++」<br>
            後置インクリメント演算子「++」<br>
            前置デクリメント演算子「--」<br>
            後置デクリメント演算子「--」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            アロー演算子「->」<br>
          </td>
        </tr>
      </table>
      <p>
        演算子の優先順位は「()」を使うことによって、最優先にすることができます。
      </p>
<pre>
# a * b が先
a * b + c

# b + c が先
a * (b + c)
</pre>
      
      <h3 id="language-statement">文</h3>
      <p>
        文は、ひとつの処理のことで「<a href="#language-scope-block">スコープブロック</a>」の中に複数記述することができます。<a href="#language-expression">式</a>のように値として評価されることはありません。
      </p>
      <p>
        <b>文の一覧</b>
      </p>
      <p>
        文の一覧です。
      </p>
      <ul class="list">
        <li><a href="#language-statement-if">if文</a></li>
        <li><a href="#language-statement-switch">switch文</a></li>
        <li><a href="#language-statement-case">case文</a></li>
        <li><a href="#language-statement-while">while文</a></li>
        <li><a href="#language-statement-for">for文</a></li>
        <li><a href="#language-statement-default">default文</a></li>
        <li><a href="#language-statement-block-simple">単純ブロック</a></li>
        <li><a href="#language-statement-eval">eval文</a></li>
        <li><a href="#language-statement-ifrequire">if require文</a></li>
        <li><a href="#language-statement-next">next文</a></li>
        <li><a href="#language-statement-last">last文</a></li>
        <li><a href="#language-statement-return">return文</a></li>
        <li><a href="#language-statement-croak">croak文</a></li>
        <li><a href="#language-statement-weaken">weaken文</a></li>
        <li><a href="#language-statement-unweaken">unweaken文</a></li>
        <li><a href="#language-statement-expression">式文</a></li>
        <li><a href="#language-statement-empty">空文</a></li>
      </ul>
      
      <h4 id="language-statement-if">if文</h3>
      <p>
        if文は、条件分岐を行うための文です。
      </p>
<pre>
if (項) {
  
}
</pre>
      <p>
        項が真の場合に、ブロックが実行されます。SPVMにおける真偽については<a href="#language-condition-part">条件部</a>を見てください。
      </p>
      <p>
        条件を複数書きたい場合には「elsif文」を続けることができます。 条件判定は上から実行され、項が真になった場合に対応するブロックが実行されます。
      </p>
<pre>
if (項) {
  
}
elsif(項) {
  
}
</pre>
      <p>
        「else文」を使って、項が真ではなかった場合の処理を記述することができます。if文とelsif文の条件判定がすべて偽であった場合にelseのブロックの内部の文が実行されます。elsif文は、なくてもかまいません。
      </p>
<pre>
if (項) {
  
}
elsif(項) {
  
}
else {
  
}
</pre>
      <p>
        <b>if文のサンプル</b>
      </p>
      <p>
        if文のサンプルです。
      </p>
<pre>
my $flag = 1;

if ($flag == 1) {
  print("One\n");
}
elsif ($flag == 2) {
  print("Tow\n");
}
else {
  print("Other");
}
</pre>
      <p>
        if文は、内部的には、目には見えない単純なブロックで囲まれています。
      </p>
<pre>
{
  if (項) {
    
  }
}
</pre>
      <p>
        elsifは、内部的には、if文とelse文に展開されます。
      </p>
<pre>
# 展開前
if (項1) {

}
elsif (項2) {

}
else {

}

# 展開後
if (項1) {
}
else {
  if (項2) {
  
  }
  else {
  
  }
}
</pre>
      <p>
        if文の条件部で、変数宣言を行うときは、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれていることと、elsifは、内部的には、if文とelse文に展開されるということを、意識してください。
      </p>
<pre>
# 展開前
my $num = 1;
if (my $num = 2) {
  
}
elsif (my $num = 3) {
  
}
else {
  
}

# 展開後
my $num = 1;
{
  if (my $num = 2) {
    
  }
  else {
    {
      if (my $num = 3) {
        
      }
      else {
        
      }
    }
  }
}
</pre>

      <h4 id="language-statement-switch">switch文</h4>
      <p>
        switch文は、int型の整数を条件にして、条件分岐を行うための文です。条件がint型の整数で、たくさんの分岐がある場合は、if文よりも高速です。
      </p>
<pre>
switch (条件式) {
  case 定数1:
  
  case 定数2:
  
  case 定数n:
  
  default:
}
</pre>
      <p>
        条件式は、<a href="#language-expression">式</a>を指定できます。式の型は、int型の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        case文で指定される定数は、int型の定数でなければなりません。enum型の値や、int型の定数サブルーチンは、int型の定数として、構文解析時に展開されるので、利用することができます。
      </p>
      <p>
        case文に指定される定数は、重複してはいけません。重複している場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        条件式で指定された値が、case文で指定された値にマッチした場合は、そのcase文の位置にジャンプします。
      </p>
      <p>
        マッチしなかった場合でdefault文が指定されている場合は、default文の位置にジャンプします。default文が指定されていなかった場合は、switchブロックは実行されません。
      </p>
      <p>
        switchブロックの中で、last文を使用した場合は、switchブロックから抜けることができます。
      </p>

<pre>
switch (条件式) {
  case 定数1:
    last;
  case 定数2:
    last;
  case 定数n:
    last;
  default:
}
</pre>

      <p>
        <b>switch文のサンプル</b>
      </p>
      <p>
        switch文のサンプルです。
      </p>
<pre>
my $code = 2;
switch ($code) {
  case 1:
    print("1\n");
    last;
  case 2:
    print("2\n");
    last;
  case 3:
    print("3\n");
    last;
  default:
    print("Other\n");
}
</pre>
      <p>
        last文を書かない場合は、下にあるcase文やdefault文も実行されてしまうので注意してください。以下のように書いてしまうと「2」「3」「Other」と表示されます。
      </p>
<pre>
my $code = 2;
switch ($code) {
  case 1:
    print("1\n");
  case 2:
    print("2\n");
  case 3:
    print("3\n");
  default:
    print("Other\n");
}
</pre>

      <h4 id="language-statement-switch">case文</h4>
      <p>
        case文は、switchブロックの中で使うことができる、条件を指定するための文です。case文についての詳細は、<a href="#language-statement-switch">switch文</a>の解説を見てください。
      </p>

      <h4 id="language-statement-switch">default文</h4>
      <p>
        default文は、switchブロックの中で使うことができる、デフォルトの条件を指定するための文です。default文についての詳細は、<a href="#language-statement-switch">switch文</a>の解説を見てください。
      </p>

      <h4 id="language-statement-switch">switch文</h4>
      <p>
        for文は、繰り返しを行うための文です。
      </p>

      <h4 id="language-statement-while">while文</h4>
      <p>
        while文は、繰り返しを行うための文です。
      </p>
<pre>
while (条件項) {
  
}
</pre>
      <p>
        条件項、<a href="#language-term">項</a>を記述できます。条件項が真であった場合に、ブロックが実行されます。そうでない場合は、ブロックを抜けます。
      </p>
      <p>
        <b>while文のサンプル</b>
      </p>
      <p>
        while文のサンプルです。
      </p>
<pre>
my $i = 0;
while ($i < 5) {
  
  print("$i\n");
  
  $i++;
}
</pre>
      <p>
        whileブロックの内部では、<a href="#language-statement-last">last文</a>を使って、whileブロックを抜けることができます。
      </p>
<pre>
while (1) {
  last;
}
</pre>

      <p>
        whileブロックの内部では、<a href="#language-statement-next">next文</a>を使って、次に実行される条件項の直前に移動することができます。
      </p>
<pre>
my $i = 0;
while ($i < 5) {
  
  if ($i == 3) {
    $i++;
    next;
  }
  
  print("$i\n");
  $i++;
}
</pre>
      
      <p>
        while文は、内部的には、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれています。
      </p>
<pre>
{
  while (条件項) {
    
  }
}
</pre>
      <p>
        while文の条件部で、変数宣言を行うときは、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれていることを意識してください。
      </p>
<pre>
# 展開前
my $num = 5;
while (my $num = 3) {
  
  $i++;
}

# 展開後
my $num = 5;
{
  while (my $num = 3) {
    
    $i++;
  }
}
</pre>

      <h4 id="language-statement-for">for文</h4>
      <p>
        for文は、繰り返しを行うための文です。
      </p>
<pre>
for (初期化式; 条件項; インクリメント式) {
  
}
</pre>
      <p>
        初期化式には、<a href="#language-expression">式</a>を記述できます。一般的には、ループ変数の初期化などの式を記述します。初期化式は省略することが可能です。
      </p>
      <p>
        条件項、<a href="#language-term">項</a>を記述できます。条件項が真であった場合に、ブロックが実行されます。そうでない場合は、ブロックを抜けます。
      </p>
      <p>
        インクリメント式には、<a href="#language-expression">式</a>を記述できます。一般的には、ループ変数のインクリメントの式を記述します。インクリメント式は省略することが可能です。
      </p>
      <p>
        for文は以下のwhile文と同じ意味を持ちます。インクリメント式は、ブロックの最後に実行されます。初期化式は、<a href="#language-block-statement-simple">単純なブロック</a>に囲まれています。
      </p>
<pre>
{
  初期化式;
  while (条件項) {
    
    
    
    インクリメント式;
  }
}
</pre>
      <p>
        <b>for文のサンプル</b>
      </p>
      <p>
        for文のサンプルです。
      </p>
<pre>
for (my $i = 0; $i < 5; $i++) {
  
  print("$i\n");
}
</pre>
      <p>
        forブロックの内部では、<a href="#language-statement-last">last文</a>を使って、forブロックを抜けることができます。
      </p>

<pre>
for (初期化式; 条件項; インクリメント式) {
  
}
</pre>
      
      <p>
        forブロックの内部では、<a href="#language-statement-next">next文</a>を使って、次に実行されるインクリメント式の直前に移動することができます。
      </p>
<pre>
for (my $i = 0; $i < 5; $i++) {
  
  if ($i == 3) {
    next;
  }
}
</pre>

      <h4 id="language-statement-return">return文</h4>
      <p>
        return文を使うと、サブルーチンから脱出します。モータル変数に代入されているオブジェクトは、自動的に解放されます。
      </p>
<pre>
return;
</pre>
      <p>
        戻り値がある場合は、<a href="#language-expression">式</a>を指定することができます。
      </p>
<pre>
return 式;
</pre>
      <p>
        <a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型が「void型」である場合は、式が存在してはいけません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型が「void型」以外の場合は、式の型と一致していなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>

      <h4 id="language-statement-croak">croak文</h4>
      <p>
        croak文は、例外を発生させるための文です。
      </p>
<pre>
croak 式;
</pre>
      <p>
        式は、文字列互換型でなければなりません。
      </p>
      <p>
        croak文の詳しい解説については、<a href="#language-exception">例外処理</a>を見てください。
      </p>
      
      <h4 id="language-statement-weaken">weaken文</h4>
      <p>
        weaken文は、フィールドに対して、<a href="#language-weak-ref">ウィークリファレンス</a>を設定する文です。
      </p>
<pre>
weaken オブジェクト式->{フィールド名};
</pre>
      <p>
        オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名は、存在するフィールド名でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、weaken文は、何もしません。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>でない場合は、次のことが行われます。
      </p>
      <p>
        1. フィールドに保存されているオブジェクトのリファレンスカウントを1減らします。
      </p>
      <p>
        2. フィールドに、ウィークリファレンスフラグを設定します。
      </p>
      <p>
        3. フィールドに保存されているオブジェクトのバックリファレンスに、フィールドを追加します。
      </p>
      <p>
        ウィークリファレンスフラグは、フィールドに保存されているオブジェクトに設定されるのではなく、フィールド自体に設定されることに注意してください。
      </p>
      <p>
        フィールドに保存されているオブジェクトのリファレンスカウントが、0になってしまった場合は、ウィークリファレンスは作成されず、フィールドに保存されているオブジェクトは解放されます。
      </p>
      <p>
        バックリファレンスとは、フィールドに保存されているオブジェクトが持つデータで、ウィークリファレンスフラグが設定されたフィールドを知るために、追加されます。これは、複数存在することがあります。
      </p>
<pre>
# バックリファレンスが、複数あるサンプル
my $foo = new Foo;
my $bar = new Bar;
my $baz = new Baz;

$foo->{bar} = $bar;
$foo->{baz} = $baz;

$bar->{foo} = $foo;
$baz->{foo} = $foo;

weaken $bar->{foo};
weaken $baz->{foo};
</pre>
      <p>
        上記の例では「$bar->{foo}」と「$baz->{foo}」に、ウィークリファレンスフラグが立ちます。$fooで表現されるオブジェクトは、バックリファレンス「$bar->{foo}」と「$baz->{foo}」を持ちます。
      </p>
      <p>
        バックリファレンスの情報が必要なのは、<a href="#language-expression-release-object">オブジェクトの解放</a>が行われるときに、バックリファレンスが指すフィールドに未定義値を代入する必要があるからです。
      </p>

      <h4 id="language-statement-unweaken">unweaken文</h4>
      <p>
        unweaken文は、フィールドに対して、<a href="#language-weak-ref">ウィークリファレンス</a>を解除する文です。
      </p>
<pre>
unweaken オブジェクト式->{フィールド名};
</pre>
      <p>
        オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名は、存在するフィールド名でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、unweaken文は、何もしません。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>でない場合は、次のことが行われます。
      </p>
      <p>
        1. フィールドに保存されているオブジェクトのリファレンスカウントを1増やします。
      </p>
      <p>
        2. フィールドのウィークリファレンスフラグを解除します。
      </p>
      <p>
        3. フィールドに保存されているオブジェクトのバックリファレンスから、フィールドを削除します。
      </p>

      <h4 id="language-statement-next">next文</h4>
      <p>
        「next文」は、次のループの先頭に移動するための文です。<a href="#language-block-statement-while">whileブロック</a>、<a href="#language-block-statement-for">forブロック</a>の中で使うことができます。
      </p>
<pre>
next;
</pre>
      <p>
        実際の動作については<a href="#language-statement-while">while文</a>、<a href="#language-statement-for">for文</a>の解説を見てください。
      </p>

      <h4 id="language-statement-last">last文</h4>
      <p>
        「last文」は、ループあるいはswitchブロックを脱出するための文です。<a href="#language-block-statement-while">whileブロック</a>、<a href="#language-block-statement-for">forブロック</a>、<a href="#language-block-statement-switch">switchブロック</a>の中で使うことができます。
      </p>
      <p>
        実際の動作については<a href="#language-statement-while">while文</a>、<a href="#language-statement-for">for文</a>、<a href="#language-statement-switch">switch文</a>の解説を見てください。
      </p>
<pre>
last;
</pre>

      <h4 id="language-statement-expression">式文</h4>
      <p>
        式文は「<a href="#language-expression">式</a>」と「;」で構成される文のことです。
      </p>
<pre>
式;
</pre>

      <p>
        式文のサンプルです。
      </p>
<pre>
1;
$var;
1 + 2;
foo();
my $num = 1 + 2;
</pre>

      <h4 id="language-statement-empty">空文</h4>
      <p>
        空文は「;」だけで終わる文のことです。
      </p>
<pre>
;
</pre>

      <h3 id="language-type">型</h3>
      <ul class="list">
        <li><a href="#language-type-summary">型の概要</a></li>
        <li><a href="#language-type-initial-value">型の初期値</a></li>
        <li><a href="#language-type-void">void型</a></li>
        <li><a href="#language-type-numeric">数値型</a></li>
        <li><a href="#language-type-integral">整数型</a></li>
        <li><a href="#language-type-byte">byte型</a></li>
        <li><a href="#language-type-short">short型</a></li>
        <li><a href="#language-type-int">int型</a></li>
        <li><a href="#language-type-long">long型</a></li>
        <li><a href="#language-type-floating-point">浮動小数点型</a></li>
        <li><a href="#language-type-float">float型</a></li>
        <li><a href="#language-type-double">double型</a></li>
        <li><a href="#language-type-package">パッケージ型</a></li>
        <li><a href="#language-type-object">オブジェクト型</a></li>
        <li><a href="#language-type-numeric-object">数値オブジェクト型</a></li>
        <li><a href="#language-type-undef">未定義型</a></li>
        <li><a href="#language-type-class">クラス型</a></li>
        <li><a href="#language-type-interface">インターフェース型</a></li>
        <li><a href="#language-type-any-object">汎用オブジェクト型</a></li>
        <li><a href="#language-type-self">self型</a></li>
        <li><a href="#language-type-array">配列型</a></li>
        <li><a href="#language-type-array-numeric">数値配列型</a></li>
        <li><a href="#language-type-array-byte">byte[]型</a></li>
        <li><a href="#language-type-array-object">オブジェクト配列型</a></li>
        <li><a href="#language-type-array-value">値配列型</a></li>
        <li><a href="#language-type-any-object-array">汎用オブジェクト配列型</a></li>
        <li><a href="#language-type-string">文字列型</a></li>
        <li><a href="#language-type-string-compatible">文字列互換型</a></li>
        <li><a href="#language-type-value">値型</a></li>
        <li><a href="#language-type-ref">リファレンス型</a></li>
        <li><a href="#language-type-ref-numeric">数値のリファレンス型</a></li>
        <li><a href="#language-type-ref-value">値のリファレンス型</a></li>
      </ul>
      <h4 id="language-type-summary">型の概要</h3>
      <p>
        SPVMは、静的型言語です。すべてのデータは静的な型を持ちます。
      </p>
      <p>
        レキシカル変数の宣言、フィールドの定義、パッケージ変数の定義、サブルーチンの定義の引数と戻り値において、型が指定される必要があります。
      </p>
      <p>
        レキシカル変数の宣言においては、型推論を利用して、暗黙的に型を指定することもできます。
      </p>
      <h4 id="language-type-initial-value">型の初期値</h3>
      <p>
        レキシカル変数の初期値、<a href="#language-package-var-initial-value">パッケージ変数の初期値</a>、オブジェクトの生成におけるフィールドの初期値は、型の初期値によって決まります。
      </p>
      <p>
        型の初期化値の一覧です。データにおけるすべてのビット列は0に設定されます。
      </p>
      </p>
      <table>
        <tr>
          <th>
            <b>型名</b>
          </th>
          <th>
            初期値
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>オブジェクト型</b>
          </td>
          <td>
            undef
          </td>
        </tr>
        <tr>
          <td>
            <b>値型</b>
          </td>
          <td>
            すべてのフィールドが0
          </td>
        </tr>
      </table>
      
      <h4 id="language-type-numeric">数値型</h3>
      <p>
        数値型は「<a href="#language-type-integral">整数型</a>」と「<a href="#language-type-floating-point">浮動小数点型</a>」からなります。
      </p>
      
      <h4 id="language-type-integral">整数型</h3>
      <p>
        SPVMの整数型は以下の4つです。
      </p>
      <table>
        <tr>
          <th>
            <b>型名</b>
          </th>
          <th>
            説明
          </th>
          <th>
            サイズ
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            8bit符号付整数型
          </td>
          <td>
            1バイト
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            16bit符号付整数型
          </td>
          <td>
            2バイト
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            32bit符号付整数型
          </td>
          <td>
            4バイト
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            64bit符号付整数型
          </td>
          <td>
            8バイト
          </td>
        </tr>
      </table>
      <p>
        SPVMの整数型には、符号なし整数型は存在しません。
      </p>
      <p>
        整数の計算規則については、<a href="#language-operator-arithmetic">算術演算子</a>を参考にしてください。
      </p>
      <h4 id="language-type-byte">byte型</h3>
      <p>
        byte型は、符号付8bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint8_t型と同じ型です。
      </p>
      <h4 id="language-type-short">short型</h3>
      <p>
        byte型は、符号付16bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint16_t型と同じ型です。
      </p>
      <h4 id="language-type-int">int型</h3>
      <p>
        int型は、符号付32bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint32_t型と同じ型です。
      </p>
      <h4 id="language-type-int">long型</h3>
      <p>
        long型は、符号付64bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint64_t型と同じ型です。
      </p>
      
      <h4 id="language-type-floating-point">浮動小数点型</h3>
      <p>
        SPVMの浮動小数点型は以下の2つです。
      </p>
      <table>
        <tr>
          <th>
            <b>型名</b>
          </th>
          <th>
            説明
          </th>
          <th>
            サイズ
          </th>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            単精度浮動小数点型 - 32bitで浮動小数点を表現します
          </td>
          <td>
            4バイト
          </td>
        </tr>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            倍精度浮動小数点型 - 64bitで浮動小数点を表現します
          </td>
          <td>
            8バイト
          </td>
        </tr>
      </table>
      <p>
        浮動小数点の計算規則については、<a href="#language-operator-arithmetic">算術演算子</a>を参考にしてください。
      </p>
      
      <h4 id="language-type-float">float型</h3>
      <p>
        float型は、単精度浮動小数点(32bit)を表現する<a href="#language-type-floating-point">浮動小数点型</a>です。C99のfloat型と同じ型です。
      </p>
      
      <h4 id="language-type-float">double型</h3>
      <p>
        double型は、倍精度浮動小数点(64bit)を表現する<a href="#language-type-floating-point">浮動小数点型</a>です。C99のdouble型と同じ型です。
      </p>
      
      <h4 id="language-type-package">パッケージ型</h4>
      <p>
        パッケージ型とは「<a href="#language-package-definition">パッケージの定義</a>」によって定義される型のことをいいます。
      </p>
<pre>
package Foo {

}
</pre>
      <p>
        パッケージ型は「<a href="#language-type-class">クラス型</a>」「<a href="#language-type-interface">インターフェース型</a>」「<a href="#language-type-value">値型</a>」からなります。
      </p>
<pre>
# クラス型
package Foo {

}

# インターフェース型
package Foo : interface_t {

}

# 値型
package Foo : value_t {

}
</pre>
      <p>
        <a href="#language-type-pointer">ポインタ型</a>は、クラス型でもあるので、ポインタ型もパッケージ型になります。
      </p>
<pre>
# ポインタ型
package Foo : pointer_t {

}
</pre>

      <h4 id="language-type-object">オブジェクト型</h4>
      <p>
        オブジェクト型とは「<a href="#language-type-class">クラス型</a>」「<a href="#language-type-interface">インターフェース型</a>」「<a href="#language-type-array">配列型</a>」「<a href="#language-type-string">文字列型</a>」「<a href="#language-type-any-object">汎用オブジェクト型</a>」を合わせたものをいいます。「値型」「リファレンス型」は含みません。
      </p>
      <p>
        オブジェクト型の値は「汎用オブジェクト型」に代入できます。
      </p>
<pre>
my $object : object = new Foo;
my $object : object = new Foo[];
my $object : object = "abc";
</pre>
      <p>
        オブジェクト型のサイズはC99における「sizeof(void*)」の値と一致していなければなりません。
      </p>

      <h4 id="language-type-numeric-object">数値オブジェクト型</h4>
      <p>
        SPVMには、数値オブジェクト型として以下の型があります。
      </p>
      <table>
        <tr>
          <th>
            <b>数値型</b>
          </th>
          <th>
            対応する数値オブジェクト型
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            SPVM::Byte
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            SPVM::Short
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            SPVM::Int
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            SPVM::Long
          </td>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            SPVM::Float
          </td>
        </tr>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            SPVM::Double
          </td>
        </tr>
      </table>

      <h4 id="language-type-undef">未定義型</h4>
      <p>
        未定義型とは、<a href="#language-undef">未定義値</a>が持っている型のことです。明示的に利用することはできません。
      </p>
      <p>
        未定義型の値は<a href="#language-undef">未定義値</a>のみです。
      </p>
      <p>
        未定義型の値は、オブジェクト型に代入できます。他の型に代入した場合は、コンパイル時エラーが発生します。
      </p>
      
      <h4 id="language-type-class">クラス型</h4>
      <p>
        クラス型とは「<a href="#language-package-definition">パッケージの定義</a>」によって定義される型で「値型」「インターフェース型」ではない型のことをいいます。
      </p>
<pre>
packag Foo {
  
}
</pre>
      <p>
        クラス型はnew演算子によって、オブジェクトを生成することができます。
      </p>
<pre>
my $foo = new Foo;
</pre>
      <p>
        クラス型は<a href="#language-type-object">オブジェクト型</a>です。
      </p>
      <p>
        クラス型は<a href="#language-type-package">パッケージ型</a>です。
      </p>
      <p>
        「<a href="#language-type-pointer">ポインタ型</a>はクラス型です。
      </p>

      <h4 id="language-type-pointer">ポインタ型</h4>
      <p>
        ポインタ型とは「<a href="#language-package-definition">パッケージの定義</a>」において「pointer_t デスクリプタ」が指定されたものをいいます。
      </p>
<pre>
package Foo : pointer_t {
  
}
</pre>
      <p>
        ポインタ型は、クラス型の一種です。
      </p>
      <p>
        ポインタ型のデータには、C言語のポインタを保存することができます。
      </p>
      <p>
        ポインタ型には、フィールドを定義することはできません。定義されていた場合は、コンパイル時エラーが発生します。
      </p>
      <h4 id="language-type-interface">インターフェース型</h4>
      <p>
        インターフェース型とは「<a href="#language-package-definition">パッケージの定義</a>」において「interface_t デスクリプタ」が指定されたものをいいます。
      </p>
<pre>
package SPVM::Comparator : interface_t {
  sub compare : int ($self : self, $x1 : object, $x2 : object);
}
</pre>
      <p>
        インターフェスは、C言語における関数ポインタに該当する機能を提供するために設計されました。
      </p>
      <p>
        インターフェース型は、サブルーチンの定義を一つだけ持ちます。サブルーチンは、メソッドでなければなりません。
      </p>
      <p>
        インターフェース型は「フィールドの定義」「パッケージ変数の定義」を持つことはできません。
      </p>
      <p>
        インターフェース型の値を、new演算子によって実体化することはできません。
      </p>
      <p>
        インターフェース型は「パッケージ型」です。
      </p>
      <p>
        インターフェース型は「オブジェクト型」です。
      </p>
      <p>
        インターフェース型には、インターフェースを満たしたクラス型のオブジェクトを代入できます。この場合、クラスはインターフェースに適合するといいます。クラスがインターフェースを満たすのは次の二つの場合です。
      </p>
      <p>
        1. インターフェース型として定義されたサブルーチンと同一の名前とシグネチャを持つクラス型のオブジェクトは、インターフェースに適合します。
      </p>
<pre>
# インターフェース型の定義
package SPVM::Comparator : interface_t {
  sub compare : int ($self : self, $x1 : object, $x2 : object);
}

# クラスの定義
package SomeComparator {
  sub compare : int ($self : self, $x1 : object, $x2 : object) {
    
  }
  
  sub foo : int () {
  
  }
}

# インターフェース型への代入
my $comparator : comparator = new SomeComparator;
</pre>
      <p>
        2. インターフェース型として定義されたサブルーチンと同一のシグネチャを持つ無名サブルーチンは、インターフェースに適合します。
      </p>
<pre>
# インターフェース型の定義
package SPVM::Comparator : interface_t {
  sub compare : int ($self : self, $x1 : object, $x2 : object);
}

# インターフェース型への代入
my $comparator : comparator = sub : int ($self : self, $x1 : object, $x2 : object) {
  
}
</pre>

      <h4 id="language-type-any-object">汎用オブジェクト型</h4>
      <p>
        汎用オブジェクト型は「object」で表現します。C言語の「void*」型を表現するために設計されました。
      </p>
<pre>
my $object : object;
</pre>
      <p>
        汎用オブジェクト型には「オブジェクト型」の値を代入できます。
      </p>
<pre>
my $object : object = new Foo;
my $object : object = "abc";
my $object : object = new Foo[3];
</pre>

      <h4 id="language-type-self">self型</h4>
      <p>
        self型とは、自身の属するパッケージ型を表現し、引数がインボカントであることを示します。
      </p>
      <p>
        <a href="#language-sub-definition">サブルーチンの定義</a>において第一引数の型としてのみ利用できます。
      </p>
      
      <h4 id="language-type-void">void型</h4>
      <p>
        void型とは、<a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型としてだけ利用できる、存在しないことを示す特別な型です。
      </p>
      
      <h4 id="language-type-basic">基本型</h4>
      <p>
        次元を持たない型を基本型と呼びます。<a href="#language-type-numeric">数値型</a>、<a href="#language-type-package">パッケージ型</a>、<a href="#language-type-any-object">汎用オブジェクト型</a>、<a href="#language-type-string">文字列型</a>は、基本型です。
      </p>
      
      <h4 id="language-type-array">配列型</h4>
      <p>
        配列型は、連続した複数のデータ領域を表現します。<a href="#language-type-basic">基本型</a>は、配列にすることができます。
      </p>
<pre>
int[]
double[]
Point[]
object[]
string[]
</pre>
      <p>
        配列は次元を持ち最大255次元まで表現できます。
      </p>
<pre>
# 二次元
int[][]

# 三次元
int[][][]
</pre>
      <p>
        配列型は、<a href="#language-type-object">オブジェクト型</a>です。
      </p>
      <p>
        配列を作成するには、new演算子を使用します。以下の例では、要素数が3のint型の配列を作成しています。
      </p>
<p>
my $nums = new int[3];
</p>
      <p>
        多次元配列を作成するときも、new演算子を使用します。以下の例では、要素数が3のint[]型の配列を作成しています。
      </p>
<p>
my $nums = new int[][3];
</p>
      <h4 id="language-type-array-numeric">数値の配列型</h4>
      <p>
        数値の配列型とは、<a href="#language-type-numeric">数値型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
      </p>
      <p>
        <b>数値の配列型の一覧</b>
      </p>
      <ul class="list">
        <li>
          byte[]
        </li>
        <li>
          short[]
        </li>
        <li>
          int[]
        </li>
        <li>
          long[]
        </li>
        <li>
          float[]
        </li>
        <li>
          double[]
        </li>
      </ul>
      <p>
        数値の配列型によって表現されるデータは、要素が<a href="#language-type-numeric">数値型</a>のサイズで、配列の長さの個数で連続していなければなりません。
      </p>
      <p>
        数値の配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
      </p>
      <h4 id="language-type-array-byte">byte[]型</h4>
      <p>
        SPVMにおいては、byte[]型は<a href="#language-type-string-compatible">文字列互換型</a>であるという点において特別な型です。
      </p>
<pre>
byte[]
</pre>
      <p>
        <a href="#language-type-string">文字列型</a>は、コンパイル時には文字列型として扱われますが、実行時にはbyte[]型になります。
      </p>

      <h4 id="language-type-array-object">オブジェクトの配列型</h4>
      <p>
        オブジェクトの配列型とは、<a href="#language-type-object">オブジェクト型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
      </p>
      <p>
        <b>オブジェクトの配列型のサンプル</b>
      </p>
      <ul class="list">
        <li>
          Foo[]
        </li>
        <li>
          Foo[][]
        </li>
        <li>
          Comparable[]
        </li>
        <li>
          object[]
        </li>
      </ul>
      <p>
        オブジェクトの配列型によって表現されるデータは、要素が<a href="#language-type-object">オブジェクト型</a>のサイズで、配列の長さの個数で連続していなければなりません。
      </p>
      <p>
        オブジェクトの配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
      </p>

      <h4 id="language-type-array-value">値の配列型</h4>
      <p>
        値の配列型とは、<a href="#language-type-value">値型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
      </p>
      <p>
        <b>値の配列型のサンプル</b>
      </p>
      <ul class="list">
        <li>
          Complex_2d[]
        </li>
        <li>
          Complex_2f[]
        </li>
      </ul>
      <p>
        値の配列型によって表現されるデータは、要素が<a href="#language-type-numeric">値型</a>のサイズで、配列の長さの個数で連続していなければなりません。
      </p>
      <p>
        値の配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
      </p>

      <h4 id="language-type-any-object-array">汎用オブジェクト配列型</h4>
      <p>
        汎用オブジェクト配列型とは、oarrayで表現される、<a href="#language-type-object">オブジェクト型</a>の値を要素として持つ任意の<a href="#language-type-array">配列型</a>の値を代入できる型です。C言語のqsort関数の第一引数には、任意の配列型をvoid*型にキャストして渡すことができますが、これに該当する機能を実現するために、汎用オブジェクト配列型は設計されました。
      </p>
<pre>
my $array : oarray = new Point[3];
my $array : oarray = new object[3];
</pre>
      <p>
        オブジェクト型以外の型を持つ値が代入された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        「oarray型」は「object[]型」と異なる型であることに注意してください。oarray型は、オブジェクト型の値を要素として持つ任意の配列型の値を代入できる型であるのに対して、「object[]型」は、「object型の値を要素に持つ配列」を表現する型で、任意の配列型の値を代入することはできません。
      </p>
      <p>
        汎用オブジェクト配列型は、<a href="#language-type-array">配列型</a>です。<a href="#language-operator-array-length">配列長演算子</a>によって長さを取得すること、<a href="#language-expression-set-array-element">配列の要素の値の設定</a>、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>ができます。
      </p>
<pre>
my $array : oarray = new SPVM::Int[3];

# 汎用オブジェクト配列型の要素の長さを取得
my $legnth = @$array;

# 汎用オブジェクト配列型の要素の値の取得
my $num = (SPVM::Int)$array->[0];

# 汎用オブジェクト配列型の要素の値の設定
$array->[0] = SPVM::Int->new(5);
</pre>
      <p>
        汎用オブジェクト配列型の要素の値の設定においては、要素の型が、配列の型の次元よりも1だけ小さくなっているかの実行時チェックが入ります。チェックに失敗した場合は、例外が発生します。汎用オブジェクト配列型は、実行時型安全性を保証します。
      </p>

      <h4 id="language-type-string">文字列型</h4>
      <p>
        文字列型は、文字列を表現する型です。stringによって表現します。C言語の「const char*」を表現するために設計されました。
      </p>
<pre>
my $str : string;
</pre>
      <p>
        文字列リテラルによって、生成された文字列オブジェクトを代入できます。
      </p>
<pre>
my $str : string = "abc";
</pre>
      <p>
        SPVMの文字列は、要素を変更できないバイト型の配列です。配列アクセスを行って、文字を取得することができます。
      </p>
<pre>
# 文字の取得
my $ch = $str->[1];
</pre>
      <p>
        要素を変更しようとした場合は、コンパイル時エラーが発生します。
      </p>
<pre>
# 要素の変更はコンパイルエラー
$str->[1] = 'd';
</pre>
      <p>
        文字列型は、コンパイルが終わった後は、バイト型の配列とまったく同じものになります。たとえば、一つ目の表現は、二つ目の表現として扱われます。
      </p>
<pre>
# isa 文字列型
if ($str isa string) {
  
}

# isa バイト型の配列
if ($str isa byte[]) {
  
}
</pre>
      <p>
        SPVMの文字列は、変更不可ですが、これは、コンパイル時チェックであることに注意してください。
      </p>
      <p>
        文字列型は、byte[]型に、キャストすることができ、実行時に文字列を変更することができます。
      </p>
<pre>
my $bytes = (byte[])$str;
$bytes->[1] = 'd';
</pre>
      <p>
        文字列は、常に変更が可能であるものとして、扱ってください。
      </p>

      <h4 id="language-type-string-compatible">文字列互換型</h4>
      <p>
        文字列互換型とは、<a href="#language-type-string">文字列型</a>と<a href="#language-type-array-byte">byte[]型</a>のことを言います。
      </p>
      
      <h4 id="language-type-value">値型</h4>
      <p>
        値型とは、連続した数値を表現できる型です。
      </p>
      <p>
        パッケージの定義において「value_t」デスクリプタを指定することで、値型を定義できます。
      </p>
<pre>
package Point_3i : value_t {
  has x : int;
  has y : int;
  has z : int;
}
</pre>
      <p>
        値型の詳しい解説については、<a href="#language-value">値</a>を見てください。
      </p>

      <h4 id="language-type-ref">リファレンス型</h4>
      <p>
        リファレンス型とは、変数のアドレスが格納できる型のことです。<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-value">値型</a>の後ろに「&」を付けることで定義できます。
      </p>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $point : Point_3i;;
my $point_ref : Point_3i& = \$point;
</pre>
      <p>
        リファレンス型の値に代入できるのは、<a href="#language-operator-ref">リファレンス演算子</a>で取得したレキシカル変数のアドレスだけです。
      </p>
      <p>
        リファレンス型のレキシカル変数の宣言だけが行われた場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        リファレンス型は、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>の型として利用できます。必ずリファレンス演算子によって、レキシカル変数のアドレスが格納される必要があります。レキシカル変数の宣言だけの場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        リファレンス型は、<a href="#language-sub-definition">サブルーチンの定義</a>における引数の型として利用できます。
      </p>
      <p>
        リファレンス型は、<a href="#language-sub-definition">サブルーチンの定義</a>における戻り値の型として利用できません。
      </p>
      <p>
        リファレンス型は、<a href="#language-package-definition">パッケージの定義</a>におけるフィールドの型として利用できません。
      </p>
      <p>
        リファレンス型は、<a href="#language-package-definition">パッケージの定義</a>におけるパッケージ変数の型として利用できません。
      </p>
      <p>
        不正な場所で、リファレンス型が使用された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        リファレンスの詳しい解説については、<a href="#language-ref">リファレンス</a>を見てください。
      </p>

      <h3 id="language-type-inference">型推論</h3>
      <p>
        型推論によって、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>するときに、<a href="#language-type">型</a>の指定を省略することができます。型推論は、常に代入演算子の右辺の型によって、行われます。
      </p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;

# Foo
my $foo = new Foo;
</pre>
      <h3 id="language-type-compatible">型の互換性</h3>
      <p>
        型に互換性があるというのは、<a href="#language-expression-typecast">型キャスト</a>を行わないで、値が移動ができる型のことです。
      </p>
      <p>
        型に互換性があるのは次の場合です。
      </p>
      <p>
        <b>移動元と移動先の型が同一の場合</b>
      </p>
      <p>
        移動元と移動先の型が同一の場合は、型の互換性があります。
      </p>
<pre>
my $num1 : int;
my $num2 : int;
$num1 = $num2;
</pre>
      <p>
        <b>移動元の型がbyte[]型で、移動先の型が文字列型の場合</b>
      </p>
      <p>
        移動元の型がbyte[]型で、移動先の型が文字列型の場合は、型の互換性があります。
      </p>
<pre>
my $bytes = new byte[3];
my $str : string;
$str = $bytes;
</pre>
      <p>
        <b>移動元の型がオブジェクト型で、移動先の型が汎用オブジェクト型の場合</b>
      </p>
<pre>
my $foo : Foo = new Foo;
my $object : object;
$object = $foo;
</pre>
      <p>
        <b>移動元の型と移動先の型が、汎用オブジェクト型あるいは、汎用オブジェクト型の配列で、移動元の型の次元数が、移動先の型の次元数以上の場合</b>
      </p>
<pre>
my $objects_dim2_src : object[];
my $objects_dim1_dist : object;
$objects_dim1_dist = $objects_dim2_src;
</pre>
      <p>
        注意点として、汎用オブジェクトの配列と基本型の配列には互換性はありません。
      </p>
<pre>
# コンパイルエラー
my $objets : object[] = new int[3];
</pre>
      <p>
        型に互換性がない場合は、<a href="#language-type-convertion-implicite">暗黙的な型変換</a>が試みられます。暗黙の型変換に失敗した場合は、コンパイル時エラーが発生します。
      </p>
      
      <h3 id="language-type-convertion">型変換</h3>
      <ul class="list">
        <li><a href="#language-type-convertion-typecast">型キャスト</a></li>
        <li><a href="#language-type-convertion-typecast">数値型の型変換</a></li>
        <li><a href="#language-type-convertion-implicite">暗黙的な型変換</a></li>
        <li><a href="#language-type-convertion-numeric-type-order">数値型の順序</a></li>
        <li><a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a></li>
        <li><a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a></li>
        <li><a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a></li>
        <li><a href="#language-type-convertion-numeric-widening">数値拡大型変換</a></li>
        <li><a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a></li>
        <li><a href="#language-type-convertion-boxing">ボクシング変換</a></li>
        <li><a href="#language-type-convertion-unboxing">アンボクシング変換</a></li>
      </ul>
      
      <h4 id="language-type-convertion-typecast">型キャスト</h4>
      <p>
        型キャストとは、明示的に記述して行う型変換のことを言います。
      </p>
<pre>
# 型キャスト
(型)式
</pre>
      <p>
        int型の値をlong型に変換するサンプルは以下のようになります。
      </p>
<pre>
my $num = (long)3;
</pre>
      <p>
        型キャストは、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        移動元の型と指定した型が同一の場合は、単に値のコピーになります。
      </p>
<pre>
my $num : int = (int)4;
</pre>
      <p>
        <b>型キャストにおける型変換の一覧</b>
      </p>
      <p>
        型キャストにおける型変換の一覧です。この表にない型キャストが行われた場合は、コンパイル時エラーが発生します。
      </p>
      <table>
        <tr>
          <th>
            <b>指定した型</b>
          </th>
          <th>
            <b>移動元の型</b>
          </th>
          <th>
            変換の内容
          </th>
        </tr>
        <tr>
          <td>
            <b>byte[]</b>
          </td>
          <td>
            <b>string</b>
          </td>
          <td>
            アドレス値がコピーされます。
          </td>
        </tr>
        <tr>
          <td>
            <b>string</b>
          </td>
          <td>
            <b>byte[]</b>
          </td>
          <td>
            アドレス値がコピーされます。
          </td>
        </tr>
        <tr>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <a href="#language-type-convertion-numeric-widening">数値型の型変換</a>が行われます。
          </td>
        </tr>
        <tr>
          <td>
            <b>数値オブジェクト型</b>
          </td>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。数値型と数値オブジェクト型が表現する数値型は、同じでなければなりません。たとえば、数値型がintの場合は、数値オブジェクト型はSPVM::Int型でなければなりません。
          </td>
        </tr>
        <tr>
          <td>
            <b>汎用オブジェクト型</b>
          </td>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。
          </td>
        </tr>
        <tr>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <b>数値オブジェクト型</b>
          </td>
          <td>
            <a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。数値型と数値オブジェクト型が表現する数値型は、同じでなければなりません。たとえば、数値型がintの場合は、数値オブジェクト型はSPVM::Int型でなければなりません。
          </td>
        </tr>
        <tr>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <b>汎用オブジェクト型</b>
          </td>
          <td>
            <a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。
          </td>
        </tr>
        <tr>
          <td>
            <b>文字列型</b>
          </td>
          <td>
            <b>数値型</b>
          </td>
          <td>
            数値が、C標準のsprintf関数の「%g」フォーマットを使って、文字列化されます。
          </td>
        </tr>
      </table>

      <h4 id="language-type-convertion-numeric">数値型の型変換</h4>
      <p>
        数値型の型変換とは、<a href="#language-type-numeric">数値型</a>から<a href="#language-type-numeric">数値型</a>への変換のことです。
      </p>
      <p>
        数値型の型変換は、対応するC言語における数値型による型変換と全く同じ処理を行います。例えば、SPVMにおけるintからlongへの型変換は、C言語のint32_t型からint64_t型への型変換と同じ処理を行います。
      </p>
<pre>
# SPVMの変換
my $src : int = 5;
my $dist = (long)$src;

# C言語における対応
int32_t src = 5;
int64_t dist = (int64_t)src;
</pre>
      <p>
        型の対応については、<a href="#language-c99-type">C99との型の対応</a>を見てください。
      </p>
      <p>
        大きな型から小さな型に変換した場合や、浮動小数点から整数型に変換した場合は、正しい情報が保持されない場合があります。SPVMでは、C99に対応する型変換をそのまま行っているので、正しい情報が保持されない場合に、どの値に変換されるかは、C99の仕様と同じです。
      </p>
      
      <h4 id="language-type-convertion-implicite">暗黙的な型変換</h4>
      <p>
        暗黙的な型変換とは、SPVMによって行われる自動的な型変換のことです。次の箇所が、暗黙的な型変換が行われる可能性のある個所です。
      </p>
      <ul class="list">
        <li>異なる型に代入する場合</li>
        <li>異なる型のサブルーチンの引数に渡す場合</li>
        <li>戻り値とは異なる型を返却する場合</li>
      </ul>
      <p>
        次の場合に暗黙的な型変換が行われます。
      </p>
      <p>
        移動元と移動先の型がどちらも数値型で、移動元の型よりも移動先の型が大きい場合は、<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>が行われます。
      </p>
<pre>
# 暗黙の拡大型変換
my $num : long = 123;
my $num : double = 12.5f;
</pre>
      <p>
        移動元と移動先の型がどちらも数値型で、移動元の型よりも移動先の型が小さい場合で、移動元の値が、整数リテラルかつ移動先の型の値の範囲で表現できる場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>が行われます。
      </p>
<pre>
# 暗黙の縮小型変換
my $num : byte = 123;
my $num : short = 134;
</pre>
      <p>
        移動元の型が数値型で、移動先の型が汎用オブジェクト型の場合は、対応する数値オブジェクト型への<a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。以下の場合の例では、SPVM::Int型のオブジェクトに変換されたものが、汎用オブジェクトに代入されます。
      </p>
<pre>
# object型への暗黙のボクシング変換
my $num = 123;
my $object : object = $num;
</pre>
      <p>
        移動元の型が数値型で、移動先の型が対応する数値オブジェクト型の場合は、対応する数値オブジェクト型への<a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。
      </p>
<pre>
# object型への暗黙のボクシング変換
my $num = 123;
my $object : SPVM::Int = $num;
</pre>
      <p>
        移動元の型が汎用オブジェクト型で、移動先の型が数値型の場合は、対応する数値型における<a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。以下の場合の例では、SPVM::Int型のオブジェクトからint型への変換が試みられます。
      </p>
<pre>
# object型からの暗黙のアンボクシング変換 - 
my $object : object;
my $num : int = $object;
</pre>
      <p>
        移動元の型が数値オブジェクト型で、移動先の型が対応する数値型の場合は、対応する数値型における<a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。
      </p>
<pre>
# 数値オブジェクト型からの暗黙のアンボクシング変換
my $num_obj = SPVM::Int->new(3);
my $num : int = $num_obj;
</pre>
        移動元の型が数値型で、移動先の型が、文字列型の場合は、<a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a>が行われます。以下の場合の例では、数値の「123」が文字列「"123"」に変換されたものが代入されます。
      </p>
<pre>
# 文字列型への暗黙のボクシング変換
my $num = 123;
my $str : string = $num;
</pre>
      
      <h4 id="language-type-convertion-numeric-type-order">数値型の順序</h4>
      <p>
        <a href="#language-type-numeric">数値型</a>は、型の順序を持ちます。型の順序は小さい方から「byte」「short」「int」「long」「float」「double」です。
      </p>
      <h4 id="language-type-convertion-unary-numeric-widening">単項数値拡大型変換</h4>
      <p>
        単項数値拡大型変換とは、<a href="#language-expression">式</a>がbyte型あるいはshort型であった場合に、int型へ<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>を行うことをいいます。
      </p>
      <p>
        単項数値拡大型変換が行われるのは以下の場合です。
      </p>
      <ul class="list">
        <li>配列のインデックス</li>
        <li>配列を作成する場合の次元</li>
        <li>単項プラス演算子のオペランド</li>
        <li>単項マイナス演算子のオペランド</li>
        <li>シフト演算子「<<」「>>」「>>>」の左右のオペランド</li>
      </ul>
      <h4 id="language-type-convertion-binary-numeric-widening">二項数値拡大型変換</h4>
      <p>
        二項数値拡大型変換とは、左辺と右辺に数値型をとる二項演算子において、左式と右式に適用される<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>のことをいいます。
      </p>
      <p>
        次のルールが適用されます。
      </p>
      <p>
        1. 一方の式が、double型の場合は、他方の型はdouble型に変換されます。
      </p>
      <p>
        2. 一方の式が、float型の場合は、他方の型はfloat型に変換されます。
      </p>
      <p>
        3. 一方の式が、long型の場合は、他方の型はlong型に変換されます。
      </p>
      <p>
        4. それ以外の場合は、int型に変換されます。
      </p>
      <p>
        二項数値拡大型変換が行われるのは以下の場合です。
      </p>
      <ul class="list">
        <li><a href="#language-operator-add">加算演算子</a></li>
        <li><a href="#language-operator-subtract">減算演算子</a></li>
        <li><a href="#language-operator-multiply">乗算演算子</a></li>
        <li><a href="#language-operator-divide">除算演算子</a></li>
        <li><a href="#language-operator-remainder">剰余演算子</a></li>
        <li><a href="#language-operator-bit-and">ビットAND演算子</a></li>
        <li><a href="#language-operator-bit-or">ビットOR演算子</a></li>
        <li><a href="#language-operator-comparison-numeric">数値比較演算子</a></li>
      </ul>

      <h4 id="language-type-convertion-numeric-narrowing">数値縮小型変換</h4>
      <p>
        数値縮小型変換とは、<a href="#language-type-numeric">数値型</a>において大きい型から小さい型への変換が行われる場合に適用される変換の規則のことです。
      </p>
      <h4 id="language-type-convertion-numeric-widening">数値拡大型変換</h4>
      <p>
        数値拡大型変換とは、<a href="#language-type-numeric">数値型</a>において小さい型から大きい型への変換が行われる場合に適用される変換の規則のことです。
      </p>
      <h4 id="language-type-convertion-boxing">ボクシング変換</h4>
      <p>
        ボクシング変換とは、数値型の値を、数値オブジェクト型に変換する操作のことをいいます。
      </p>
      <h4 id="language-type-convertion-unboxing">アンボクシング変換</h4>
      <p>
        アンボクシング変換とは、数値オブジェクト型の値を、対応する数値型の値に変換する操作のことをいいます。
      </p>
      <h4 id="language-type-convertion-numeric-to-string">数値から文字列への型変換</h4>
      <p>
        数値から文字列への型変換とは、<a href="#language-type-numeric">数値型</a>が<a href="#language-type-string">文字列型</a>に変換される場合に適用される変換規則のことです。
      </p>
      <p>
        数値型の値をC99のsprintfの「%g」フォーマットを使って、SPVMの文字列へ変換します。
      </p>
      <h3 id="language-auto-loaded-module">自動的に読み込まれるモジュール</h3>
      <p>
        自動的に読み込まれるモジュールは以下です。<a href="language-use-module">use</a>キーワードによって読み込まなくても利用することができます。
      </p>
      <ul class="list">
        <li>SPVM::CORE</li>
        <li>SPVM::Byte</li>
        <li>SPVM::Short</li>
        <li>SPVM::Int</li>
        <li>SPVM::Long</li>
        <li>SPVM::Float</li>
        <li>SPVM::Double</li>
      </ul>
      
      <h2 id="stdfunc">標準関数</h2>
      <p>
        SPVMの標準関数の一覧です。
      </p>
      <ul class="toc">
        <li><a href="#stdfunc-INFINITY">INFINITY</a></li>
        <li><a href="#stdfunc-INFINITYF">INFINITYF</a></li>
        <li><a href="#stdfunc-NAN">NAN</a></li>
        <li><a href="#stdfunc-NANF">NANF</a></li>
      </ul>
      <h3 id="stdfunc-INFINITY">INFINITY</h3>
<pre>
sub INFINITY : double ()
</pre>
      <p>
        無限大を「double型」で返します。C標準の「INFINITYマクロ」の単純なラッパーです。
      </p>
      
      <h3 id="stdfunc-INFINITYF">INFINITYF</h3>
<pre>
sub INFINITYF : float ()
</pre>      
      <p>
        無限大を「float型」で返します。C標準の「INFINITYマクロ」の単純なラッパーです。
      </p>
      <h3 id="stdfunc-NAN">NAN</h3>
<pre>
sub NAN : double ()
</pre>      
      <p>
        非値を「double型」で返します。C標準の「NANマクロ」の単純なラッパーです。
      </p>
      <h3 id="stdfunc-NANF">NANF</h3>
<pre>
sub NANF : float ()
</pre>
      <p>
        非値を「float型」で返します。C標準の「NANマクロ」の単純なラッパーです。
      </p>

      <h2 id="faq">FAQ</h2>
      <h3>サブルーチン呼び出しの絶対名呼び出しができないのはなぜですか</h3>
      <p>
        SPVMでは以下のようにサブルーチンを呼び出すことができません。
      </p>
<pre>
Foo::bar();
</pre>
      <p>
        常に、アロー演算子を使う必要があります。
      </p>
<pre>
Foo->bar();
</pre>
      <p>
        SPVMの世界に閉じるのであれば、この二つを同じものとして扱うことができるのですが、Perlの世界においては、二つの表現は意味が異なります。
      </p>
      <p>
        SPVMのひとつの目標は、SPVMにおける呼び出しとPerlにおける呼び出しを完全に一致させることです。
      </p>
      <p>
        SPVMの世界でアロー演算子で呼び出せるものが、Perlの世界でもアロー演算子で呼び出せるという単純な規則を設けることで、呼び出しを完全に一致させています。
      </p>
      
      <h3>加算演算子・減算演算子・乗算演算子の整数演算でオーバーフローした場合の動作はどうなりますか</h3>
      <p>
        C99は、加算演算子・減算演算子・乗算演算子における整数演算のオーバーフロー時の動作について定義していないので、処理系依存になります。
      </p>
      <p>
        ほぼすべての環境においては、2の補数表現を使って、整数を表現し、加算と減算を行いますので、2の補数表現で演算を行った場合の結果になることが期待されます。
      </p>
      <h3>C99以外で書かれたライブラリは利用できますか</h3>
      <p>
        はい。ライブラリがC89、C11、C++の各仕様で書かれていても利用できます。C99準拠というのは、SPVM自体のソースコード自体において適用されるだけです。
      </p>
      <h3>定数畳み込み最適化は行われますか。</h3>
      <p>
        通常は、定数畳み込みの最適化は、行われませんが、プリコンパイルされたサブルーチンでは、定数畳み込みがCコンパイラによって試みらるでしょう。
      </p>
      <h3>演算子の優先順位でPerlと異なる点を教えてください</h3>
      <p>
        演算子の優先順位はPerlをベースにして作成されており、ほぼPerlの優先順位だと考えて大丈夫です。
      </p>
      <p>
        ひとつの違いは、SPVMには型キャストがあることです。型キャストは「単項演算子」の優先順位よりもひとつ低く、「乗算演算子」の優先順位よりも一つ高くなっています。
      </p>
      <p>
        以下の例ではキャストが先に行われます。
      </p>
<pre>
(long)3 + 1;
</pre>
      <h3>「比較演算子」と「論理演算子」が戻り値を返せないのはなぜですか?</h3>
      <p>
        これを、戻り値にすることは可能なはずですが、現在は実装されていません。
      </p>
      <p>
        実装されていない理由は、一時変数の増加とオペレーションコードの増加が見込まれ、最適な形で実装することが、現在の作者の実力では困難であることです。
      </p>
      <p>
        現在の内部実装では、条件判定した結果は、内部的な条件フラグに保存されます。
      </p>
      <p>
        戻り値が欲しい場合は、次のように記述してください。
      </p>
<pre>
my $flag : int;
if ($num > 3) {
  $flag = 1;
}
else {
  $flag = 0;
}
</pre>
      <h3>
        SPVMの1.0はいつリリースされますか。
      </h3>
      <h3>
        SPVMの1.0はいつリリースされますか。
      </h3>
      <p>
        SPVMは柔軟で、十分な後方互換性を保つことを目標に現在、設計しています。
      </p>
      <p>
        いくつかの分野で、プログラムが正しく記述できること、パフォーマンスの要件を満たすことが必要です。1.0のリリースは、この要件が満たされた後になります。
      </p>
      <p>
        デバイスドライバや、Open CV、Open GL、SIMD、 Open MP、GPUなどのC/C++ライブラリとの連携の確認。
      </p>
      <p>
        HTTPSのリクエストを処理できるHTTPクライアント/サーバーライブラリ。
      </p>
      <p>
        Windows APIを利用したネイティブWindowsアプリケーションの作成。
      </p>
      <p>
       少なくとも<b>デバイスドライバやC/C++ライブラリと連携でき、WebにHTTPSで接続できる、ネイティブアプリケーション</b>が作成できることの確認が必要です。
      </p>
      
      <h3>
        SPVMを開発するにあたって参考にした言語を教えてください。
      </h3>
      <p>
        言語仕様と文法についてはPerlを主に参考にしています。
      </p>
      <p>
        Perl 6の文法・キーワードを部分的に採用しています。「has」「native」「ro」「rw」「wo」など。
      </p>
      <p>
        SPVMのバーチャルマシンの初期実装は、JavaVMを参考にして、可変長バイト命令を解釈するスタック型VMとして作成されました。現在のSPVMは、64bitの固定長命令を解釈するレジスター型VMとなっています。
      </p>
      <p>
        数値型と数値計算においては、Javaの計算規則を参考にしました。
      </p>
      <p>
        ボクシング、アンボクシング、可変長引数については、Javaを参考にしました。
      </p>
      <p>
        文字列がUTF-8であることと、インターフェースについては、go言語を参考にしました。
      </p>
      
      <h3>なぜレジスタ型VMを採用していますか</h3>
      <p>
        レジスタ型VMを採用している最も大きな理由は、SPVMのオペレーションコードを、C言語のソースコードに変換するときに、1対1で対応させることができるためです。gccの最適化が適用できます。
      </p>
      <h3>列挙にint型以外の型を利用することはできますか</h3>
      <p>
        残念なことですが、列挙に利用できるるのはint型だけです。
      <p>
      <p>
        他の型の定数を利用したい場合は、定数を返すサブルーチンを定義してください。
      </p>
<pre>
sub FOO : double () {
  return 3.14;
}
</pre>
      <p>
        一つの定数を返すサブルーチンは、定数としてインライン展開されることが仕様上で保証されているので、パフォーマンスを気にせず利用できます。
      </p>
      <h3>
        SPVMのサブルーチン呼び出しでかっこを省略できないのはなぜですか。
      </h3>
      <p>
        SPVMにおいては、メソッドの呼び出し、クラスメソッドの呼び出しについては、かっこの省略が可能です。サブルーチン名だけを指定した場合においては、かっこの省略ができません。
      </p>
      <p>
        これは、サブルーチン名だけでは、識別子名がサブルーチンであることを、ソースコードの中で、決定できないためです。パッケージ名やフィールド名との区別ができません。
      </p>
      <p>
        他のソースファイルを解析することによって、かっこを省略する構文は、理論的には可能ですが、SPVMでは、単一ファイルの中で、静的な構文解析を完了できるということを重要視しました。
      </p>
      <h3>サポートされるGCCのバージョンを教えてください</h3>
      <p>
        gcc 4.3で確認しており、保証される最低のバージョンはgcc 4.3です。C99がサポートされている必要があります。
      </p>
      <h3>符号なし整数型はありませんか</h3>
      <p>
        残念ながら、SPVMには、符号なし整数型はありません。
      </p>
      <h3>対応しているOSを教えてください。</h3>

      <p>
      Unix、Linux、macOS、Windowsに対応しています。
      </p>

      <h3>Perlと異なる点を教えてください。</h3>

      <p>
        コンテキストは存在しません。関数の呼び出しには括弧が必要です。三項演算子はありません。シングルクォートは、文字定数です。
      </p>
      <p>
        標準関数や標準モジュールは、Perlとは完全に異なっています。
      </p>
      <p>
        サブルーチンは、必ずメソッドか、クラスメソッドになります。サブルーチンの絶対名での呼び出しはできません。
      </p>
      <p>
        モジュールの拡張子は「spvm」です。
      </p>
      <p>
        型はすべて静的型です。サブルーチン呼び出しは、コンパイル時に解決されます。配列は静的です。動的配列とハッシュは、モジュールとして提供されます。
      </p>

      <h3>スレッドは利用できますか</h3>
      <p>
        スレッドは、コアではサポートされていませんが、エクステンションを使ったユーザーモジュールを作成することで、間接的に利用できます。
      </p>
      <p>
        SPVMはシングルスレッドで動くように設計されています。シングルスレッドは、利用者にとって簡単で安全な設計です。
      </p>
      <p>
        スレッドの機能はSPVMのコアにはありませんが、CやC++のスレッドライブラリを利用して、エクステンションから利用することはできます。
      </p>
      <p>
        エクステンションでは、スレッド用のSPVMの実行環境を生成して、スレッド上で、利用できます。
      </p>
      <p>
        SPVMのモジュールとして作成すれば、SPVMからサブルーチンを通して、間接的にスレッドを利用できます。
      </p>

      <h3>エクステンションとは何ですか</h3>
      <p>
        エクステンションとは、SPVMからC/C++の関数を呼び出すための仕組みのことです。
      </p>

      <h3>プリコンパイルとは何ですか</h3>
      <p>
        プリコンパイルとは、SPVMのサブルーチンを、コンパイル時に機械語に変換する仕組みのことです。機械語に変換されたサブルーチンは、高速に実行できます。</p>
      <p>
        precompileが指定されたサブルーチンを含むモジュールファイルは、コンパイル時に、Cのソースコードに変換されます。
      </p>
<pre>
precompile sub sum : int ($num1 : int, $num2 : int) {
  return $num1 + $num2;
}
</pre>
      <p>
        Cのソースコードは、ビルドディレクトリの中に作成されます。
      </p>
      <p>
        生成されたCのソースコードは、Perlをコンパイルしたコンパイラ(通常はgccかclang)によって、機械語(.oの拡張子を持つオブジェクトファイル)にコンパイルされます。
      </p>
      <p>
        機械語に変換された後、各OSで呼び出すことのできる共有ライブラリ(.soや.dll)にリンクされます。
      </p>

      <h3>ビルドディレクトリとは何ですか</h3>
      <p>
        プリコンパイルする場合に、必要となるディレクトリのことです。
      </p>
      <p>
        ビルドディレクトリを利用することをSPVMに教えるにはSPVM::BuildDirモジュールを使用する必要があります。
      </p>
<pre>
use SPVM::BuildDir;
</pre>
      <p>
        スクリプトがあるディレクトリの「spvm_build」というディレクトリがデフォルトのビルドディレクトリ名になります。
      </p>
      <p>
        ビルドディレクトリ名を自分で指定したい場合は、次のようにします。
      </p>
<pre>
use FindBin;
use SPVM::BuildDir "$FindBin::Bin/mydir;
</pre>

      <h3>インターフェースとは何ですか</h3>
      <p>
        SPVMでは、インターフェスとは、実装を持たないメソッドが一つだけ定義されているパッケージのことをいいます。
      </p>
      <p>
        インターフェースのひとつの例は、標準モジュールである「SPVM::Comparable」です。
      </p>
<pre>
package SPVM::Comparable : interface_t {
  sub compare : int ($self : self, $object1 : object, $object2 : object);
}
</pre>
      <p>
        機能としては、C言語の関数ポインタに似ています。
      </p>

      <h3>ジェネリクスはありますか</h3>
      <p>
        残念なことですが、SPVMにはジェネリクスはありません。SPVMは、コンパイル時の型決定性よりも、型の簡単さを選択しました。
      </p>
      <p>
        コンテナの要素は、汎用オブジェクト型で定義してください。汎用オブジェクトから実際のオブジェクトを取得するためには、型キャストが必要です。
      </p>
<pre>
sub add : void ($self : self, $object : ojbect) { ... }
sub get : object ($self : self, $index : int) { ... }
</pre>

<pre>
my $list = SPVM::List->new;
$list->add("hello!");
my $str = (string)$list->get(0);
</pre>

      <h3>継承はありますか</h3>
      <p>
        残念ですが、継承はありません。SPVMでは「汎用オブジェクト型」と「インターフェース」を使って、ポリモーフィズムを実現します。
      </p>
      
      <h3>サブルーチンのオーバーロードはありますか。</h3>
      <p>
        サブルーチンのオーバーロードはありません。サブルーチンは、サブルーチン名で一意的に識別されます。
      </p>
      <p>
        採用されていない最も大きな理由は、Perl自体が型を持たないために、PerlからSPVMのサブルーチンへ渡す値の型が決定できないためです。
      </p>
      <p>
        このためSPVMでは、サブルーチン名によって、戻り値と引数の型がわかるように設計されています。
      </p>
      
      <h3>浮動小数点の演算は処理系依存ですか</h3>
      <p>
        はい、浮動小数点の表現方法、および演算は、処理系に依存します。
      </p>
      
      <h3>パッケージ名、フィールド名、サブルーチン名などの識別子に連続したアンダーラインが使えないのはなぜですか</h3>
      <p>
        二つの連続したアンダーラインは、エクステンションにおいて、パッケージ名とサブルーチン名の区切りとして利用されるためです。
      </p>
      <p>
        エクステンションはC言語で書かれます。
      </p>
<pre>
# SPVMのサブルーチン
package Foo::Bar {
  sub baz : void () { }
}
</pre>

<pre>
// エクステンションにおける関数名
SPVM_NATIVE_Foo__Bar__baz(SPVM_ENV* env, SPVM_VALUE* stack) {

}
</pre>
      <p>
        SPVMの「Foo::Barパッケージのbazサブルーチン」はエクステンションの「SPVM_NATIVE_Foo__Bar__baz」に対応します。これは1対1に対応し、相互に名前の変換が可能です。
      </p>
      
      <h3>SPVMからPerlのサブルーチンを呼び出すことはできますか</h3>
      <p>
        残念ながら、SPVMからPerlのサブルーチンを呼び出すことはできません。
      </p>
      <h3>C言語のconstやJavaのfinalのような機能はありますか。</h3>
      <p>
        一度代入した値を変更できなくする機能はありませんが、他の機能の組み合わせで実現することができます。
      </p>
      <p>
        <b>コンパイル時定数で数値型の場合</b>
      </p>
      <p>
        定数サブルーチンを使用します。
      </p>
<pre>
package Foo {
  sub VAL : double () {
    return 5.1234;
  }
}
</pre>
      
      <p>
        <b>コンパイル時定数でオブジェクト型の場合</b>
      </p>
      <p>
        パッケージ変数を定義します。パッケージ変数に読み込み用のアクセッサを定義します。BEGINブロックを使って、パッケージ変数を初期化します。
      </p>
<pre>
package Foo {
  our $POINT : ro int;
  
  BEGIN {
    $POINT = Point->new;
  }
}
</pre>
      <h3>シングルトンを生成することはできますか。</h3>
      <p>
        はいできます。
      </p>
      <p>
        パッケージ変数を定義します。BEGINブロックを使って、パッケージ変数を初期化します。singletonメソッドで、オブジェクトを返します。
      </p>
<pre>
package Foo {
  our $SINGLETON : Foo;
  BEGIN {
    $SINGLETON = new Foo;
  }
  
  sub singleton : Foo () {
    return $SINGLETON;
  }
}
</pre>
      <h3>SPVMの開発に参加することはできますか。</h3>

      <p>
        コア機能、標準関数、標準モジュールについては、作者が決定を行っています。その範囲の中であれば、開発への参加が可能です。
      </p>
      
      <p>
        バグ報告、ベンチマーク、言語評価、ブログなどでの紹介は歓迎です。
      </p>
      <h2 id="developer">開発情報</h2>
      <h3>SPVMの開発に参加</h3>
      <p>
        「README」の中に開発手順が記載されています。
      </p>
      <h3>著者</h3>
      <p>
        木本裕紀(kimoto.yuki@gmail.com)
      </p>
      <p>
        <img src="https://www.gravatar.com/avatar/0475497bcea869ee3d091edc3d06ced7?s=130&d=identicon">
      </p>
      <h3>コアデベロッパー</h3>
      <p>
        moti(motohiko.ave@gmail.com)
      </p>
      <h3>リポジトリ</h3>
      <p>
        <a href="https://github.com/yuki-kimoto/SPVM">SPVM(GitHub)</a>
      </p>
      <h3>CPAN</h3>
      <p>
        <a href="https://metacpan.org/pod/distribution/SPVM/lib/SPVM.pm">SPVM(CPAN)</a>
      </p>
      </p>
      <h3>バグ報告</h3>
      <p>
        バグ報告はGitHubのIssueで行うことができます。
      </p>
      <p>
        <a href="https://github.com/yuki-kimoto/SPVM/issues">GitHub Issue</a>
      </p>
    </div>
    <div class="footer">
      <div><a href="javascript:void(0)" class="to-top">▲</a></div>
      <a href="https://github.com/yuki-kimoto/SPVM">SPVMプロジェクト</a>
    </div>
  </body>
</html>
