<html>
  <head>
    <title>SPVM公式ドキュメント 1.0 ベータ</title>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="/images/spvm-logo.png">
    <link rel="stylesheet" type="text/css" href="/css/common.css">
    <script type="text/javascript" src="/js/jquery-1.9.0.min.js"></script>
    <script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
    <link  type="text/css" rel="stylesheet" href="/js/google-code-prettify/prettify.css"/>
    <script>
      $(function(){
        // google code prettifyの有効化
        $("pre").addClass("prettyprint");
        function init(event){
          prettyPrint();
        }
        if(window.addEventListener)window.addEventListener("load",init,false);
        else if(window.attachEvent)window.attachEvent("onload",init);
        
        
      });
    </script>

  </head>
  <body>
    <div class="header">
      <div class="container">
        <h1>
          <img src="/images/spvm-logo.png">
          SPVM公式ドキュメント 1.0 ベータ
        </h1>
      </div>
    </div>
    
    <div class="container">
      <p>
        昨日の記事は<a href="http://d.hatena.ne.jp/charsbar/20181207/1544189920">charsbar</a>さんでした。
      </p>
      <p>
        本日はyukikimotoが書きます。リレー形式でつなげていくのは、楽しいですね!
      </p>
      <p>
        この記事はSPVMの日本語公式ドキュメントです。書き始めですが、数時間で、書けるところまで書きます。
      </p>
      <p>
        <a href="https://qiita.com/advent-calendar/2018/perl">Perl Advent Calender 2018</a>をきっかけにに作成されました。
      </p>
      
      <h2>目次</h2>
      <ul class="toc">
        <li><a href="#purpose">目的</a></li>
        <li><a href="#user">ユーザー</a></li>
        <li><a href="#features">機能</a></li>
        <li><a href="#install">SPVMのインストール</a></li>
        <li><a href="#tutorial">チュートリアル</a></li>
        <li><a href="#language">言語仕様</a></li>
        <li><a href="#stdfunc">標準関数</a></li>
        <li><a href="#faq">FAQ</a></li>
        <li><a href="#devoloper">開発者</a></li>
      </ul>

      <h2 id="purpose">目的</h2>

      <h3>SPVMが開発された主な目的を教えてください。</h3>

      <p>
        SPVMは、<b>Perlの数値計算の遅さを改善</b>するために開発されました。<b>数値計算と配列の演算を高速化</b>することができます。
      </p>

      <h3>どれくらいの速度の改善を目指していますか</h3>

      <p>
        仕様が完成した後にベンチマークテストを始める予定ですが、数値計算と配列の演算に対して、Perlの30倍、C言語の1/2の速度を、最初の目標としています。
      </p>

      <h3>他の目的はありますか</h3>

      <p>
        二つ目の目的は、<b>C/C++のバインディングを簡単にする</b>ことです。XSやInline::Cは、C/C++のバインディングという点で、非常に難しいと感じています。
      </p>
      <p>
        簡単なAPIを使って、メモリ安全に、C/C++のバインディングができる機能を提供しています。
      </p>

      <h3>さらに、他の目的はありますか</h3>

      <p>
        三つ目の目的は、<b>単体で実行可能な実行ファイルを生成する</b>ことです。
      </p>
      <p>
        SPVMは、実行ファイルを生成する機能を持っているので、ランタイムなしに、プログラムの実行が可能で、配布することもできます。
      </p>
      <p>
        共有ライブラリ(ダイナミックリンクライブラリ)の読み込みにも対応しています。
      </p>

      <h3>生成された実行ファイルのライセンスはどうなりますか</h3>
      <p>
        SPVMのソースコードには、MITライセンスが適用されるので、MITライセンスの元で、商用利用が可能です。
      </p>

      <h3>実行ファイルを生成して、何ができますか</h3>
      <p>
        たとえば、ボタンなどのGUI部品を備えた、配布可能なWindowsアプリケーションが作成できる予定です。
      </p>

      <h2 id="user">ユーザー</h2>
      <p>
        どのような人をSPVMのユーザーとして想定していますか。
      </p>

      <h3>遺伝子解析などのビオテクノロジーの研究者</h3>
      <p>
        Perlは、遺伝子解析などのビオテクノロジーの分野で利用されていますが、配列操作の遅さに不満を感じている研究者の方がいます。
      </p>

      <p>
        配列操作を簡単に高速化でき、必要であればC/C++をバインディングし、openMPやSIMDなどの並列計算ができればと考えている研究者の方を想定しています。
      </p>

      <h3>Perlの数値計算を速くしたいが、XSやC言語は難しいと感じる方</h3>
      <p>
        SPVMを使うと、Perlの文法で、数値計算と配列演算を速くすることができます。
      </p>

      <h3>IoTの開発者</h3>

      <p>
        IoTの開発者は、ハードウェアからWebまでの幅広い知識が必要になります。大量の分野の知識が必要となるため、これを簡単に実現するライブラリがあれば便利です。
      </p>

      <p>
        C/C++、アセンブラを使って、センサーのデバイスドライバを作成。HTTPクライアントライブラリを使って、Webにアクセス。開発環境で、実行ファイルを作成して、それぞれの機器にそのままコピー。このような一連の機能をSPVMは提供する予定です。
      </p>

      <h3>グラフィックスエンジニア</h3>

      <p>
        画像処理には、大量の配列演算が必要です。Perlは、配列のデータ構造を言語仕様として持たないため、不満を感じている方がいます。
      </p>

      <p>
        SPVMは、連続した領域を持つ配列のデータ構造を提供しているので、DirectXやOpenGM、OpenCVなどと組み合わせて、画像処理をしたいユーザーに向いています。
      </p>

      <h3>AI・機械学習エンジニア</h3>

      <p>
        AI・機械学習には、配列演算が必要です。Perlは、配列のデータ構造を言語仕様として持たないため、不満を感じている方がいます。
      </p>

      <p>
        SPVMは、連続した領域を持つ配列のデータ構造を提供しているので、機械学習ライブラリとの相性が高いです。
      </p>

      <h3>マイクロサービスの提供者</h3>

      <p>
        SPVMは、JSONモジュール、非同期IOをサポートしたHTTPクライアント/サーバーをコアで提供する予定です。実行ファイルを生成可能なので、小さなLinuxサーバーを構築し、実行ファイルをコピーして、マイクロサービスを運用可能です。
      </p>

      <p>
        SPVMは、リファレンスカウント方式のGCを採用しているので、FullGCが起こらず、非同期IOの性能に大きく関わるレイテンシを小さくできます。
      </p>

      <h2 id="install">SPVMのインストール</h2>

      <p>
        SPVMはCPANモジュールです。cpanまたはcpanmを使ってインストールできます。
      </p>
<pre>
cpan SPVM
cpanm SPVM
</pre>

      <h2 id="features">機能</h2>
      <ul class="toc">
        <li><a href="#features-c99-math">C99で追加された数学関数</a></li>
      </ul>
      <ul class="toc">
        <li><a href="#features-specification">仕様化された言語仕様</a></li>
      </ul>
      
      <h3 class="features-c99-math">C99で追加された数学関数</h3>
      <p>
        C99で追加された新しいC言語の数学関数がすべて利用できます。
      </p>
      
      <h3 class="features-specification">仕様化された言語仕様</h3>
      <p>
        SPVMの言語仕様は、メジャーバージョンごとに、仕様化されています。仕様を元に、独自にコンパイラを開発することが可能です。
      </p>

      <h2 id="tutorial">SPVMのチュートリアル</h2>

      <p>
        SPVMのチュートリアルです。
      </p>
      
      <ul class="toc">
        <li>
          <a href="#tutorial-sum-array">配列の和を求める</a>
        </li>
      </ul>
      
      <h3 id="tutorial-sum-array">
        配列の和を求める
      </h3>
      
      <p>
        最初の簡単な例として配列の和を求めてみましょう。
      </p>
      <h4>SPVMモジュールの作成</h4>
      <p>
        「MyMath.spvm」というファイルファイルをlibディレクトリの中に作成してください。<b>SPVMのソースファイルの拡張子は「.spvm」</b>です。以下の内容を記述しましょう。
      </p>
<pre>
# lib/MyMath.spvm
package MyMath {
  sub sum : int ($nums : int[]) {
    
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }
    
    return $total;
  }
}
</pre>
      
      <p>
        SPVMでは<b>パッケージ構文</b>を使用して、パッケージを作成します。Perlのパッケージブロック構文と同じ文法です。
      </p>
<pre>
# パッケージ構文
package MyMath {

}
</pre>
      <p>
        パッケージのブロックの中では<b>サブルーチン定義</b>を行うことができます。
      </p>
<pre>
package MyMath {
  sub sum : int ($nums : int[]) {
    
  }
}
</pre>
      
      <p>
        SPVMは静的型言語ですので、<b>サブルーチンの宣言の中で、戻り値の型、引数名と引数の型を記述</b>します。
      </p>
      <p>
        戻り値は「int型」。引数は「int型の配列」です。<b>int型は、32bit符号付整数</b>を表現します。
      </p>
      <p>
        配列の和を計算している部分をみてみましょう。
      </p>
<pre>
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }

    return $total;
</pre>
      <p>
        和の計算方法の見た目は、Perlでfor文を使って書いたものとまったく同じです。
      </p>
      <p>
        このようにSPVMではM<b>Perlと同じ文法で記述</b>できるのがひとつの特徴です。Perlユーザーが、新しい文法を覚える負担ができるだけ小さくなるように設計されています。
      </p>
      <p>
        変数の宣言では<b>型推論</b>を使って、型を省略することができます。
      </p>
<pre>
    my $total = 0;
</pre>
      <p>
        SPVMの型推論は、右辺の型が確定しているときに、左辺の型宣言を省略することができます。
      </p>
      <p>
        数値リテラルの「0」は「int型」ですので、「$total」の型も「int型」になります。以下の記述と同じ意味になります。
      </p>
<pre>
    my $total : int = 0;
</pre>
      <p>
        <b>配列の長さ</b>は「@」を使うことで取得できます。
      </p>
<pre>
@$nums
</pre>
      <p>
        SPVMには、コンテキストはなく「@」は常に配列の長さを返します。
      </p>
      <p>
        次にSPVMで書かれたサブルーチンをPerlの側から呼び出してみましょう。
      <p>
      <h4>SPVMモジュールの呼び出し</h4>
      <p>
        「sum.pl」というファイルを作成して、以下の内容を記述してください。
      </p>
      <p>
        SPVMで書かれた「MyMath」パッケージの「sum」サブルーチンを呼び出して、配列の和を計算します。
      </p>
<pre>
use FindBin;
use lib "$FindBin::Bin/lib";

use SPVM 'MyMath';

my $sp_nums = SPVM::new_iarray([3, 6, 8, 9]);

my $total = MyMath->sum($sp_nums);

print $total . "\n";
</pre>
      <p>
        まず最初に<b>libディレクトリをモジュールの検索パスに追加</b>します。
      </p>
<pre>
# libディレクトリをモジュールの検索パスに追加
use FindBin;
use lib "$FindBin::Bin/lib";
</pre>
      <p>
        次に<b>SPVMモジュールを読み込み</b>ます。
      </p>
<pre>
# SPVMモジュールを読み込み
use SPVM 'MyMath';
</pre>
      <p>
        「use SPVM 'SPVMモジュール名'」という記述で、SPVMモジュールを読み込むことができます。
      </p>
      <p>
        次に<b>SPVMの配列を作成</b>します。
      </p>
<pre>
# int型配列の作成
my $sp_nums = SPVM::new_iarray([3, 6, 8, 9]);
</pre>
      <p>
        <b>SPVM::new_iarray関数</b>を使うと、配列のリファレンスを渡して、SPVMのint型の配列を作成することができます。
      </p>
      <p>
        <b>MyMathパッケージのsumサブルーチンを呼び出し</b>てみましょう。
      </p>
<pre>
# MyMathパッケージのsumサブルーチンを呼び出し
my $total = MyMath->sum($sp_nums);
</pre>
      <p>
        <b>SPVMのサブルーチン呼び出しは、Perlのクラスメソッド呼び出しになることに注意してください。</b>「絶対名 MyMath::sub」で呼び出すことはできません。
      </p>
      
      <p>
        sum関数の戻り値は「int型」ですが、SPVMの整数型は、自動的にPerlのスカラ型に変換されます。
      </p>
      
      <h2 id="language">言語仕様</h2>
      <p>
        SPVMの言語仕様の詳細です。
      </p>
      <ul class="toc">
        <li><a href="#language-comment">コメント</a>
        <li><a href="#language-pod">POD</a>
        <li><a href="#language-package-definition">パッケージ定義</a>
        <li><a href="#language-field-definition">フィールド定義</a>
        <li><a href="#language-type">型</a></li>
        <li><a href="#language-type-convertion">型変換</a></li>
        <li><a href="#language-literal">リテラル</a></li>
        <li><a href="#language-condition-part">条件部</a></li>
      </ul>
      <h3 id="language-comment">コメント</h3>
      <p>
        コメントは「#」で始まり改行で終わります。
      </p>
<pre>
# コメント
</pre>
      <h3 id="language-pod">POD</h3>
      <p>
        POD(プレーンオールドドキュメント)を記述することができます。PODは行頭が「=」で始まる任意の文字列の行から始まり、行頭から行末まで「=cut」で終わる行までです。
      </p>
      <p>
        PODの内側に書かれた文字列はソースコードとして解釈されず、コメントとして扱われます。
      </p>
<pre>
=pod

複数行
コメント

=cut
</pre>

<pre>
=head1

複数行
コメント

=cut
</pre>

      <h3 id="language-package-definition">パッケージ</h3>
      <p>
        パッケージを定義するには以下の構文を使用します。
      </p>
<pre>
package パッケージ名 {

}
</pre>
      <p>
        パッケージ名は「大文字」で始まる必要があります。
      </p>
      <p>
        「パッケージ名」の後に「:」をつなげてその後ろに「デスクリプタ」を指定することができます。
      </p>
<pre>
package パッケージ名 : デスクリプタ {

}
</pre>
      <p>
        パッケージの定義のサンプルです。
      </p>
<pre>
# パッケージ名のみ
package Point {

}
</pre>

<pre>
# パッケージ名とデスクリプタ
package Point : public {

}
</pre>
      
      <p>
        <b>パッケージデスクリプタ</b>
      </p>
      <p>
        パッケージで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このパッケージに対するnewキーワードが他のパッケージから利用できます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このパッケージに対するnewキーワードが他のパッケージから利用できません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>interface</b>
          </td>
          <td>
            このパッケージは「インターフェイス」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>value_t</b>
          </td>
          <td>
            このパッケージは「値型」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>pointer_t</b>
          </td>
          <td>
            このパッケージは「ポインタ型」になります。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイルエラーになります。
      </p>
      <p>
        「interface」「value_t」「pointer_t」のひとつより多くが同時に指定されている場合は、コンパイルエラーになります。
      </p>
      
      <p>
        <b>パッケージ内部で定義できるもの</b>
      </p>
      <p>
        パッケージ内部では<b>「use」</b><b>「パッケージ変数」</b><b>「フィールド」</b><b>「列挙」</b><b>「サブルーチン」</b>が定義できます。
      </p>
<pre>
package Foo {
  # use
  use Point;
  
  # パッケージ変数
  our $VAR int;
  
  # フィールド
  has var : int;
  
  # 列挙
  enum {
    CONST_VAL
  }
  
  # サブルーチン
  sub foo : int ($num : int) {
  
  }
}
</pre>
      <h3 id="language-field-definition">フィールド</h3>
      <p>
        「has」キーワードを使用してフィールドを定義することができます。
      </p>
<pre>
has フィールド名 : 型名
</pre>
      <p>
        フィールド定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        フィールド定義には「<a href="#language-type">型名</a>」が必要です。
      </p>
      <p>
        フィールド名は「a～z」「A～Z」「0～9」「_」で構成する必要があります。先頭は、数字から始めることはできません。連続した「_」を使用することはできません。
      </p>
      <p>
        フィールド定義には、デスクリプタを合わせて指定することができます。
      </p>
<pre>
has フィールド名 : デスクリプタ 型名
</pre>
      <p>
        <b>フィールドデスクリプタ</b>
      </p>
      <p>
        フィールドで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このフィールドは、外部のパッケージからアクセスできます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このフィールドは、外部のパッケージからアクセスできません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>ro</b>
          </td>
          <td>
            このフィールドは、読み込み用のアクセッサを持ちます。アクセッサ名は、フィールド名と同じです。
          </td>
        </tr>
        <tr>
          <td>
            <b>wo</b>
          </td>
          <td>
            このフィールドは、書き込み用のアクセッサを持ちます。アクセッサ名は、「set_フィールド名」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>rw</b>
          </td>
          <td>
            このフィールドは、読み込み用のアクセッサと書き込み用のアクセッサを持ちます。アクセッサ名は、それぞれ「フィールド名」「set_フィールド名」になります。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイルエラーになります。
      </p>
      <p>
        「ro」「wo」「rw」のひとつより多くが同時に指定されている場合は、コンパイルエラーになります。
      </p>
      <p>
        書き込み用のアクセッサの戻り値は「void型」です。
      </p>
      <p>
        SPVMのソースコードの中からアクセッサが呼び出された場合は、アクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
      </p>
      <p>
        <b>フィールド定義のサンプル</b>
      </p>
      <p>
        フィールド定義のサンプルです。
      </p>
<pre>
package Foo {
  has num1 : byte;
  has num2 : short;
  has num3 : int;
  has num4 : long;
  has num5 : float;
  has num6 : double;

  has num_public : public int;
  has num_ro : ro int;
  has num_wo : wo int;
  has num_rw : rw int;
}
</pre>
      
      <h3 id="language-type">型</h3>
      <ul class="toc">
        <li><a href="#language-type-integer">整数型</a></li>
        <li><a href="#language-type-floating-point">浮動小数点型</a></li>
        <li><a href="#language-type-object">オブジェクト型</a></li>
      </ul>
      <h4 id="language-type-integer">整数型</h3>
      <p>
        SPVMの整数型は以下の4つです。
      </p>
      <table>
        <tr>
          <th>
            <b>型名</b>
          </th>
          <th>
            説明
          </th>
          <th>
            範囲
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            8bit符号付整数
          </td>
          <td>
            -128～127
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            16bit符号付整数
          </td>
          <td>
            -32768～32767
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            32bit符号付整数
          </td>
          <td>
            -2147483648～2147483647
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            64bit符号付整数
          </td>
          <td>
            -9223372036854775808～9223372036854775807
          </td>
        </tr>
      </table>
      
      <h3 id="language-type-convertion">型変換</h3>
      <ul class="toc">
        <li><a href="#language-type-convertion-narrwing">縮小型変換</a></li>
        <li><a href="#language-type-convertion-widning">拡大型変換</a></li>
      </ul>
      <h4 id="language-type-convertion-narrowing">縮小型変換</h4>
      <p>
        縮小型変換とは、数値型において広い型から狭い型への変換が行われる場合に適用される変換の規則のことです。
      </p>
      <p>
        型の順序は狭い方から「byte」「short」「int」「long」「float」「double」です。
      </p>
      <h4 id="language-type-convertion-widening">拡大型変換</h4>
      <p>
        拡大型変換とは、数値型において狭い型から広い型への変換が行われる場合に適用される変換の規則のことです。
      </p>
      <p>
        型の順序は狭い方から「byte」「short」「int」「long」「float」「double」です。
      </p>
      
      <h3 id="language-literal">リテラル</h3>
      <ul class="toc">
        <li><a href="#language-literal-integer">整数リテラル</a></li>
        <li><a href="#language-literal-floating-point">浮動小数点リテラル</a></li>
        <li><a href="#language-literal-character">文字リテラル</a></li>
        <li><a href="#language-literal-string">文字列リテラル</a></li>
        <li><a href="#language-literal-undef">未定義値</a></li>
      </ul>

      <h4 id="language-literal-integer">整数リテラル</h3>
      <p>
        <b>10進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は「0～9」の1つ以上の連続した文字で表現されます。
      </p>
      <p>
        先頭に「+」あるいは「-」の符号をつけることができます。
      </p>
      <p>
        整数リテラルの型は、デフォルトでは「int型」になります。
      </p>
      <p>
        整数リテラルがint型で表現できる数値の範囲を超えている場合は、コンパイルエラーになります。
      </p>
      <p>
        末尾に「L」あるいは「l」のサフィックスをつけることで「long型」の整数リテラルを表現できます。
      </p>
      <p>
        long型の整数リテラルの場合は、long型で表現できる数値の範囲を超えている場合は、コンパイルエラーになります。
      </p>
      <p>
        区切り文字として「_」を使用することができます。区切り文字は意味を持ちません。
      </p>
      <p>
        不正な整数リテラルの表現はコンパイルエラーになります。
      </p>
      <p>
        整数リテラルがbyte型の変数に代入される場合、あるいはbyte型のサブルーチンの引数として渡される場合で、byte型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-narrowing">縮小型変換</a>によって、byte型に自動的に変換されます。範囲を超えている場合は、コンパイルエラーとなります。
      </p>
      <p>
        整数リテラルがshort型の変数に代入される場合、あるいはshort型のサブルーチンの引数として渡される場合で、short型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-narrowing">縮小型変換</a>によって、short型に自動的に変換されます。範囲を超えている場合は、コンパイルエラーとなります。
      </p>
      <p>
        整数リテラルのサンプルです。
      </p>
<pre>
123
+123
-123
123L
123l
123_456_789
-123_456_789L
</pre>
      <p>
        <b>16進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>16進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を16進数を使って表現するときは「0x」から始めます。
      </p>
      <p>
        その後ろに「0～9」「a～f」「A～F」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な16進数表現は、コンパイルエラーになります。
      </p>
      <p>
        整数リテラルを16進数で表現したサンプルです。
      </p>
<pre>
0x3b4f
-0x3F1A
0xDeL
0xFFFFFFFF_FFFFFFFF
</pre>

      <p>
        <b>8進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>8進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を8進数を使って表現するときは「0」から始めます。
      </p>
      <p>
        その後ろに「0～7」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な8進数表現は、コンパイルエラーになります。
      </p>
      <p>
        整数リテラルを8進数で表現したサンプルです。
      </p>
<pre>
0755
-0644
0666L
0655_755
</pre>
      <p>
        <b>2進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>2進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を2進数を使って表現するときは「0b」から始めます。
      </p>
      <p>
        その後ろに「0」か「1」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な2進数表現は、コンパイルエラーになります。
      </p>
      <p>
        整数リテラルを2進数で表現したサンプルです。
      </p>
<pre>
0b0101
-0b1010
0b110000L
0b10101010_10101010
</pre>


      <h4 id="language-literal-floating-point">浮動小数点リテラル</h3>
      <p>
        浮動小数点リテラルは「符号部」「数値部」「指数部」「サフィックス」から構成されます。
      <p>
      <p>
        浮動小数点リテラルには「10進数浮動小数点リテラル」と「16進数浮動小数点リテラル」があります。
      </p>
      <p>
        「符号部」は「+」か「-」で表現されます。「符号部」の存在は、任意です。「符号部」が存在する場合は、先頭にある必要があります。
      </p>
      <p>
        「10進数浮動小数点リテラル」は、数値部が「一桁以上の10進数字」で始まる必要があります。
      </p>
      <p>
        「10進数字」とは「0～9」のことです。
      </p>
      <p>
        「10進数浮動小数点リテラル」は、数値部に「小数点」が含まれているか、含まれていない場合は「指数部」あるいは「サフィックス」が必要です。
      </p>
      <p>
        「小数点」とは「.」のことです。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、数値部が「0x」あるいは「0X」で始まり、その後ろに「一桁以上の16進数字」が続く必要があります。
      </p>
      <p>
        16進数字とは「0～9」「a～f」「A～F」のことです。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、「数値部」に「小数点」を含むことができます。
      </p>
      <p>
        「数値部」はアンダーライン「_」を含むことができます。これは単なる区切り文字で、無視されます。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、「指数部」が必要です。
      </p>
      <p>
        「指数部」は「指数表現」と「符号付10進整数」で構成されます。
      </p>
      <p>
        「指数表現」は「10進数浮動小数点リテラル」の場合は「e」あるいは「E」、「16進数浮動小数点リテラル」の場合は「p」あるいは「P」になります。
      </p>
      <p>
        「指数部」の意味は「10進数浮動小数点リテラル」の場合は、10進数による桁移動、「16進数浮動小数点リテラル」の場合は、2進数による桁移動になります。
      </p>
      <p>
        末尾に「f」あるいは「F」のサフィックスをつけると、浮動小数点リテラルの型は「float型」になります。
      </p>
      <p>
        末尾に「d」あるいは「D」のサフィックスをつけると、浮動小数点リテラルの型は「double型」になります。
      </p>
      <p>
        サフィックスが省略された場合は、浮動小数点リテラルの型は「double型」になります。
      </p>
      <p>
        浮動小数点リテラルが「float型」の場合はC標準の「strtof関数」を使って、文字列からfloat型への変換が行われます。変換が失敗した場合は、コンパイルエラーになります。
      </p>
      <p>
        浮動小数点リテラルが「double型」の場合はC標準の「strtod関数」を使って、文字列からdouble型への変換が行われます。変換が失敗した場合は、コンパイルエラーになります。
      </p>
      <p>
        無限大を表現する浮動小数点リテラルはありません。標準関数である「<a href="#stdfunc-INFINITY">INFINITY関数</a>」「<a href="#stdfunc-INFINITYF">INFINITYF関数</a>」を使用してください。
      </p>
      <p>
        非値を表現する浮動小数点リテラルはありません。標準関数である「<a href="#stdfunc-NAN">NAN関数</a>」「<a href="#stdfunc-NANF">NANF関数</a>」を使用してください。
      </p>
      <p>
        浮動小数点リテラルのサンプルです
      </p>
<pre>
1.32
-1.32
1.32f
1.32F
1.32e3
1.32e-3
1.32E+3
1.32E-3
0x3d3d.edp0
0x3d3d.edp3
0x3d3d.edP3
0x3d3d.edP-3f
</pre>

      <h4 id="language-literal-character">文字リテラル</h3>

      <h4 id="language-literal-string">文字列リテラル</h3>
      
      <h4 id="language-literal-undef">未定義値</h3>
      <p>
        未定義は「undef」で表現されます。
      </p>
<pre>
undef
</pre>
      <p>
        未定義値は、任意のオブジェクト型の変数に代入することができます。
      </p>
      <p>
        未定義値はオブジェクト型の値と「==」「!=」演算子を使用して、比較することができます。未定義値は、生成されたオブジェクトと等しくない事が保証されます。
      </p>
      <p>
        未定義は条件部で使われた場合は、偽になります。
      </p>
      <p>
        未定義値は、エクステンションにおいてC言語の値として利用された場合は、0と等しくなることが保証されます。
      </p>
      <p>
        Perlと異なる点は、SPVMにおいては「undef」は関数ではなくリテラルであるということです。
      </p>
      
      <h3 id="language-condition-part">条件部</h3>
      <p>
        条件部とは、条件判定が行われる部分のことです。SPVMでは、以下の部分が条件部となります。
      </p>
      <p>
        if文のかっこの中。
      </p>
<pre>
if (条件部) {

}
</pre>
      <p>
        unless文のかっこの中。
      </p>
<pre>
unless (条件部) {

}
</pre>
      <p>
        forのかっこの中の二つ目。
      </p>
<pre>
for (初期化;条件部;次の値;) {

}
</pre>
      <p>
        whileのかっこの中。
      </p>
<pre>
while (条件部) {

}
</pre>

      <h2 id="stdfunc">標準関数</h2>
      <p>
        SPVMの標準関数の一覧です。
      </p>
      <ul class="toc">
        <li><a href="#stdfunc-INFINITY">INFINITY</a></li>
        <li><a href="#stdfunc-INFINITYF">INFINITYF</a></li>
        <li><a href="#stdfunc-NAN">NAN</a></li>
        <li><a href="#stdfunc-NANF">NANF</a></li>
      </ul>
      <h3 id="stdfunc-INFINITY">INFINITY</h3>
<pre>
sub INFINITY : double ()
</pre>
      <p>
        無限大を「double型」で返します。C標準の「INFINITYマクロ」の単純なラッパーです。
      </p>
      
      <h3 id="stdfunc-INFINITYF">INFINITYF</h3>
<pre>
sub INFINITYF : float ()
</pre>      
      <p>
        無限大を「float型」で返します。C標準の「INFINITYマクロ」の単純なラッパーです。
      </p>
      <h3 id="stdfunc-NAN">NAN</h3>
<pre>
sub NAN : double ()
</pre>      
      <p>
        非値を「double型」で返します。C標準の「NANマクロ」の単純なラッパーです。
      </p>
      <h3 id="stdfunc-NANF">NANF</h3>
<pre>
sub NANF : float ()
</pre>
      <p>
        非値を「float型」で返します。C標準の「NANマクロ」の単純なラッパーです。
      </p>

      <h2 id="faq">FAQ</h2>
      <h3>サポートされるGCCのバージョンを教えてください</h3>
      <p>
        gcc 4.3で確認しており、保証される最低のバージョンはgcc 4.3です。C99がサポートされている必要があります。
      </p>
      <h3>符号なし整数型はありませんか</h3>
      <p>
        残念ながら、SPVMには、符号なし整数型はありません。
      </p>
      <h3>対応しているOSを教えてください。</h3>

      <p>
      Unix、Linux、macOS、Windowsに対応しています。
      </p>

      <h3>Perlと異なる点を教えてください。</h3>

      <p>
        コンテキストは存在しません。関数呼び出しには括弧が必要です。三項演算子はありません。シングルクォートは、文字定数です。
      </p>
      <p>
        標準関数や標準モジュールは、Perlとは完全に異なっています。
      </p>
      <p>
        サブルーチンは、必ずメソッドか、クラスメソッドになります。サブルーチンの絶対名での呼び出しはできません。
      </p>
      <p>
        モジュールの拡張子は「spvm」です。
      </p>
      <p>
        型はすべて静的型です。サブルーチン呼び出しは、コンパイル時に解決されます。配列は静的です。動的配列とハッシュは、モジュールとして提供されます。
      </p>

      <h3>スレッドは利用できますか</h3>
      <p>
        スレッドは、コアではサポートされていませんが、エクステンションを使ったユーザーモジュールを作成することで、間接的に利用できます。
      </p>
      <p>
        SPVMはシングルスレッドで動くように設計されています。シングルスレッドは、利用者にとって簡単で安全な設計です。
      </p>
      <p>
        スレッドの機能はSPVMのコアにはありませんが、CやC++のスレッドライブラリを利用して、エクステンションから利用することはできます。
      </p>
      <p>
        エクステンションでは、スレッド用のSPVMの実行環境を生成して、スレッド上で、利用できます。
      </p>
      <p>
        SPVMのモジュールとして作成すれば、SPVMからサブルーチンを通して、間接的にスレッドを利用できます。
      </p>

      <h3>エクステンションとは何ですか</h3>
      <p>
        エクステンションとは、SPVMからC/C++の関数を呼び出すための仕組みのことです。
      </p>

      <h3>プリコンパイルとは何ですか</h3>
      <p>
        プリコンパイルとは、SPVMのサブルーチンを、コンパイル時に機械語に変換する仕組みのことです。機械語に変換されたサブルーチンは、高速に実行できます。</p>
      <p>
        precompileが指定されたサブルーチンを含むモジュールファイルは、コンパイル時に、Cのソースコードに変換されます。
      </p>
<pre>
precompile sub sum : int ($num1 : int, $num2 : int) {
  return $num1 + $num2;
}
</pre>
      <p>
        Cのソースコードは、ビルドディレクトリの中に作成されます。
      </p>
      <p>
        生成されたCのソースコードは、Perlをコンパイルしたコンパイラ(通常はgccかclang)によって、機械語(.oの拡張子を持つオブジェクトファイル)にコンパイルされます。
      </p>
      <p>
        機械語に変換された後、各OSで呼び出すことのできる共有ライブラリ(.soや.dll)にリンクされます。
      </p>

      <h3>ビルドディレクトリとは何ですか</h3>
      <p>
        プリコンパイルする場合に、必要となるディレクトリのことです。
      </p>
      <p>
        ビルドディレクトリを利用することをSPVMに教えるにはSPVM::BuildDirモジュールを使用する必要があります。
      </p>
<pre>
use SPVM::BuildDir;
</pre>
      <p>
        スクリプトがあるディレクトリの「spvm_build」というディレクトリがデフォルトのビルドディレクトリ名になります。
      </p>
      <p>
        ビルドディレクトリ名を自分で指定したい場合は、次のようにします。
      </p>
<pre>
use FindBin;
use SPVM::BuildDir "$FindBin::Bin/mydir;
</pre>

      <h3>インターフェースとは何ですか</h3>
      <p>
        SPVMでは、インターフェスとは、実装を持たないメソッドが一つだけ定義されているパッケージのことをいいます。
      </p>
      <p>
        インターフェースのひとつの例は、標準モジュールである「SPVM::Comparable」です。
      </p>
<pre>
package SPVM::Comparable : interface {
  sub compare : int ($self : self, $object1 : object, $object2 : object);
}
</pre>
      <p>
        機能としては、C言語の関数ポインタに似ています。
      </p>

      <h3>ジェネリクスはありますか</h3>
      <p>
        残念なことですが、SPVMにはジェネリクスはありません。SPVMは、コンパイル時の型決定性よりも、型の簡単さを選択しました。
      </p>
      <p>
        コンテナの要素は、汎用オブジェクト型で定義してください。汎用オブジェクトから実際のオブジェクトを取得するためには、型キャストが必要です。
      </p>
<pre>
sub add : void ($self : self, $object : ojbect) { ... }
sub get : object ($self : self, $index : int) { ... }
</pre>

<pre>
my $list = SPVM::List->new;
$list->add("hello!");
my $str = (string)$list->get(0);
</pre>

      <h3>サブルーチンのオーバーロードはありますか。</h3>
      <p>
        サブルーチンのオーバーロードはありません。サブルーチンは、サブルーチン名で一意的に識別されます。
      </p>
      <p>
        採用されていない最も大きな理由は、Perl自体が型を持たないために、PerlからSPVMのサブルーチンへ渡す値の型が決定できないためです。
      </p>
      <p>
        このためSPVMでは、サブルーチン名によって、戻り値と引数の型がわかるように設計されています。
      </p>
      
      <h3>浮動小数点の演算は処理系依存ですか</h3>
      <p>
        はい、浮動小数点の表現方法、および演算は、処理系に依存します。
      </p>
      
      <h3>パッケージ名、フィールド名、サブルーチン名などの識別子に連続したアンダーラインが使えないのはなぜですか</h3>
      <p>
        二つの連続したアンダーラインは、エクステンションにおいて、パッケージ名とサブルーチン名の区切りとして利用されるためです。
      </p>
      <p>
        エクステンションはC言語で書かれます。
      </p>
<pre>
# SPVMのサブルーチン
package Foo::Bar {
  sub baz : void () { }
}
</pre>

<pre>
// エクステンションにおける関数名
SPVM_NATIVE_Foo__Bar__baz(SPVM_ENV* env, SPVM_VALUE* stack) {

}
</pre>
      <p>
        SPVMの「Foo::Barパッケージのbazサブルーチン」はエクステンションの「SPVM_NATIVE_Foo__Bar__baz」に対応します。これは1対1に対応し、相互に名前の変換が可能です。
      </p>
      
      <h3>SPVMからPerlのサブルーチンを呼び出すことはできますか</h3>
      <p>
        残念ながら、SPVMからPerlのサブルーチンを呼び出すことはできません。
      </p>

      <h3>SPVMの開発に参加することはできますか。</h3>

      <p>
        コア機能、標準関数、標準モジュールについては、作者が決定を行っています。その範囲の中であれば、開発への参加が可能です。
      </p>
      
      <p>
        バグ報告、ベンチマーク、言語評価、ブログなどでの紹介は歓迎です。
      </p>
      <h2 id="developer">開発情報</h2>
      <h3>SPVMの開発に参加</h3>
      <p>
        「README」の中に開発手順が記載されています。
      </p>
      <h3>著者</h3>
      <p>
        木本裕紀(kimoto.yuki@gmail.com)
      </p>
      <p>
        <img src="https://www.gravatar.com/avatar/0475497bcea869ee3d091edc3d06ced7?s=130&d=identicon">
      </p>
      <h3>コアデベロッパー</h3>
      <p>
        moti(motohiko.ave@gmail.com)
      </p>
      <h3>リポジトリ</h3>
      <p>
        <a href="https://github.com/yuki-kimoto/SPVM">SPVM(GitHub)</a>
      </p>
      <h3>CPAN</h3>
      <p>
        <a href="https://metacpan.org/pod/distribution/SPVM/lib/SPVM.pm">SPVM(CPAN)</a>
      </p>
      </p>
      <h3>バグ報告</h3>
      <p>
        バグ報告はGitHubのIssueで行うことができます。
      </p>
      <p>
        <a href="https://github.com/yuki-kimoto/SPVM/issues">GitHub Issue</a>
      </p>
      <h3>ドキュメント最終更新日</h3>
      <p>
        2018年12月12日
      </p>
      <h2>明日は</h2>
      
      <p>
        明日は<a href="https://qiita.com/yumlonne">aeroastro</a>さんです。
      </p>
      <p>
        <a href="https://qiita.com/advent-calendar/2018/perl">Perl Advent Calendar 2018</a>
      </p>
    </div>
    <div class="footer">
      <a href="https://github.com/yuki-kimoto/SPVM">SPVMプロジェクト</a>
    </div>
  </body>
</html>
