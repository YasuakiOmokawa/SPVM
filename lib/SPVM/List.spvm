package SPVM::List : private {
  has values   : private object[];
  has capacity : private int;
  has offset   : private int;
  has length   : private int;

  sub _reallocate : void ($self : self) {
    my $new_capacity = $self->{length} * 2;
    unless ($new_capacity) {
      $new_capacity = 1;
    }
    my $new_values = new object [$new_capacity];
    for (my $i = 0; $i < $self->{length}; ++$i) {
      my $target = ($i + $self->{offset} + $self->{capacity}) % $self->{capacity};
      $new_values->[$i] = $self->{values}[$target];
    }
    $self->{offset} = 0;
    $self->{capacity} = $new_capacity;
    $self->{values} = $new_values;
  }

  sub _clear : void ($self : self) {
    $self->{values} = new object [0];
    $self->{capacity} = 0;
    $self->{offset} = 0;
    $self->{length} = 0;
  }

  sub _values : object[] ($self : self) {
    return $self->{values};
  }

  sub _capacity : int ($self : self) {
    return $self->{capacity};
  }

  sub _offset : int ($self : self) {
    return $self->{offset};
  }

  sub new : SPVM::List () {
    my $self = new SPVM::List;
    my $default_capacity = 16;
    $self->{capacity} = $default_capacity;
    $self->{values} = new object [$default_capacity];
    return $self;
  }

  sub new_with_capacity : SPVM::List ($capacity : int) {
    my $self = new SPVM::List;
    $self->{capacity} = $capacity;
    $self->{values} = new object [$capacity];
    return $self;
  }

  sub new_with_array : SPVM::List ($objects : object[]) {
    my $self = new SPVM::List;
    $self->{capacity} = @$objects;
    $self->{values} = new object [@$objects];
    for (my $i = 0; $i < @$objects; ++$i) {
      $self->{values}[$i] = $objects->[$i];
    }
    $self->{length} = @$objects;
    return $self;
  }

  sub length : int ($self : self) {
    return $self->{length};
  }

  sub push : void ($self : self, $value : object) {
    if ($self->{length} + 1 > $self->{capacity}) {
      $self->_reallocate;
    }
    $self->{values}[($self->{offset} + $self->{length}) % $self->{capacity}] = $value;
    ++$self->{length};
  }

  sub pop : object ($self : self) {
    if ($self->{length} - 1 < 0) {
      return undef;
    }
    my $target = ($self->{offset} + $self->{length} - 1) % $self->{capacity};
    my $ret = $self->{values}[$target];
    $self->{values}[$target] = undef;
    --$self->{length};
    return $ret;
  }

  sub unshift : void ($self : self, $value : object) {
    if ($self->{length} + 1 > $self->{capacity}) {
      $self->_reallocate;
    }
    if (--$self->{offset} < 0) {
      $self->{offset} += $self->{capacity};
    }
    $self->{values}[$self->{offset}] = $value;
    ++$self->{length};
  }

  sub shift : object ($self : self) {
    if ($self->{length} - 1 < 0) {
      return undef;
    }
    my $ret = $self->{values}[$self->{offset}];
    $self->{values}[$self->{offset}] = undef;
    --$self->{length};
    if (++$self->{offset} >= $self->{capacity}) {
      $self->{offset} = 0;
    }
    return $ret;
  }

  sub set : void ($self : self, $index : int, $value : object) {
    $self->{values}[($self->{offset} + $index) % $self->{capacity}] = $value;
  }

  sub get : object ($self : self, $index : int) {
    return $self->{values}[($self->{offset} + $index) % $self->{capacity}];
  }

  sub splice : object[] ($self : self, $cut_offset : int, $cut_length : int, $replace : object[]) {
    if ($cut_offset > $self->{length}) {
      warn("splice_with_list() offset past end of array");
      $cut_offset = $self->{length};
      $cut_length = 0;
    }

    # fit cut_length to the end.
    if ($cut_offset + $cut_length > $self->{length}) {
      $cut_length = $self->{length} - $cut_offset;
    }

    my $extracted = new object [$cut_length];
    for (my $i = 0; $i < $cut_length; ++$i) {
      $extracted->[$i] = $self->{values}[($self->{offset} + $cut_offset + $i) % $self->{capacity}];
    }

    unless ($replace) {
      $replace = new object [0];
    }

    my $new_values = new object [$self->{length} - $cut_length + @$replace];
    for (my $i = 0; $i < $cut_offset; ++$i) {
      $new_values->[$i] = $self->{values}[($self->{offset} + $i) % $self->{capacity}];
    }
    for (my $i = 0; $i < @$replace; ++$i) {
      $new_values->[$cut_offset + $i] = $replace->[$i];
    }
    for (my $i = 0; $i < $self->{length} - $cut_offset - $cut_length; ++$i) {
      $new_values->[$cut_offset + @$replace + $i] =
          $self->{values}[($self->{offset} + $cut_offset + $cut_length + $i) % $self->{capacity}];
    }

    $self->{capacity} = @$new_values;
    $self->{offset} = 0;
    $self->{length} = @$new_values;
    $self->{values} = $new_values;

    return $extracted;
  }
}
