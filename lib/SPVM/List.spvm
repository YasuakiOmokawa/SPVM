package SPVM::List : private {
  has values   : private object[];
  has capacity : private int;
  has offset   : private int;
  has length   : private int;

  sub _reallocate : void ($self : self) {
    my $new_capacity = $self->{length} * 2;
    unless ($new_capacity) {
      $new_capacity = 1;
    }
    my $new_values = new object [$new_capacity];
    for (my $i = 0; $i < $self->{length}; ++$i) {
      my $target = ($i + $self->{offset} + $self->{capacity}) % $self->{capacity};
      $new_values->[$i] = $self->{values}[$target];
    }
    $self->{offset} = 0;
    $self->{capacity} = $new_capacity;
    $self->{values} = $new_values;
  }

  sub _clear : void ($self : self) {
    $self->{values} = new object [0];
    $self->{capacity} = 0;
    $self->{offset} = 0;
    $self->{length} = 0;
  }

  sub _values : object[] ($self : self) {
    return $self->{values};
  }

  sub _capacity : int ($self : self) {
    return $self->{capacity};
  }

  sub _offset : int ($self : self) {
    return $self->{offset};
  }

  sub new : SPVM::List () {
    my $self = new SPVM::List;
    my $default_capacity = 16;
    $self->{capacity} = $default_capacity;
    $self->{values} = new object [$default_capacity];
    return $self;
  }

  sub new_with_capacity : SPVM::List ($capacity : int) {
    my $self = new SPVM::List;
    $self->{capacity} = $capacity;
    $self->{values} = new object [$capacity];
    return $self;
  }

  sub new_with_array : SPVM::List ($objects : object[]) {
    my $self = new SPVM::List;
    $self->{capacity} = @$objects;
    $self->{values} = new object [@$objects];
    for (my $i = 0; $i < @$objects; ++$i) {
      $self->{values}[$i] = $objects->[$i];
    }
    $self->{length} = @$objects;
    return $self;
  }

  sub length : int ($self : self) {
    return $self->{length};
  }

  sub push : void ($self : self, $value : object) {
    if ($self->{length} + 1 > $self->{capacity}) {
      $self->_reallocate;
    }
    $self->{values}[($self->{offset} + $self->{length}) % $self->{capacity}] = $value;
    ++$self->{length};
  }

  sub pop : object ($self : self) {
    if ($self->{length} - 1 < 0) {
      return undef;
    }
    my $target = ($self->{offset} + $self->{length} - 1) % $self->{capacity};
    my $ret = $self->{values}[$target];
    $self->{values}[$target] = undef;
    --$self->{length};
    return $ret;
  }

  sub unshift : void ($self : self, $value : object) {
    $self->_reallocate($self->{length} + 1, 1, 0);
    $self->{values}[--$self->{offset}] = $value;
    $self->{length}++;
  }

  sub shift : object ($self : self) {
    if ($self->{length} - 1 < 0) {
      return undef;
    }
    --$self->{length};
    my $ret = $self->{values}[$self->{offset}];
    $self->{values}[$self->{offset}] = undef;
    $self->{offset}++;
    return $ret;
  }

  sub set : void ($self : self, $index : int, $value : object) {
    if (!$self->_range_check($index)) {
      # do not allow autovivification
      croak "Modification of non-creatable array value attempted, subscript " . $index;
    }
    $index = $self->_fix_negative_index($index);
    $self->{values}[$self->{offset} + $index] = $value;
  }

  sub get : object ($self : self, $index : int) {
    if (!$self->_range_check($index)) {
      return undef;
    }
    $index = $self->_fix_negative_index($index);
    return $self->{values}[$self->{offset} + $index];
  }

  sub splice : object[] ($self : self, $cut_offset : int, $cut_length : int, $replace : object[]) {
    if ($cut_offset > $self->{length}) {
      warn("splice_with_list() offset past end of array");
      $cut_offset = $self->{length};
      $cut_length = 0;
    }
    if ($cut_offset != $self->{length} && !$self->_range_check($cut_offset)) {
      croak "Modification of non-creatable array value attempted, subscript " . $cut_offset;
    }

    $cut_offset = $self->_fix_negative_index($cut_offset);

    # fix negative length  
    if ($cut_length < 0) {
      $cut_length += $self->{length} - $cut_offset;
      if ($cut_length < 0) {
        $cut_length = 0;
      }
    }

    # fit cut_length to the end.
    if ($cut_offset + $cut_length > $self->{length}) {
      $cut_length = $self->{length} - $cut_offset;
    }

    my $old_values = new object [$self->{length}];
    for (my $i = 0; $i < $self->{length}; $i++) {
      $old_values->[$i] = $self->get($i);
    }

    $self->_clear;
    if ($replace == undef) {
      $replace = new object [0];
    }
    my $new_length = @$old_values - $cut_length + @$replace;
    $self->_reallocate($new_length, 0, $new_length);
    for (my $i = 0; $i < $cut_offset; $i++) {
      $self->push($old_values->[$i]);
    }
    for (my $i = 0; $i < @$replace; $i++) {
      $self->push($replace->[$i]);
    }
    for (my $i = 0; $i < @$old_values - $cut_offset - $cut_length; $i++) {
      $self->push($old_values->[$cut_offset + $cut_length + $i]);
    }

    my $extracted = new object [$cut_length];
    for (my $i = 0; $i < $cut_length; $i++) {
      $extracted->[$i] = $old_values->[$cut_offset + $i];
    }

    return $extracted;
  }
}
