package SPVM::List : private {
  has values   : private object[];
  has capacity : private int;
  has offset   : private int; # range of offset: [-capacity, -1)
  has length   : private int;

  sub _reallocate_with_capacity : void ($self : self, $new_capacity : int) {
    my $new_values = new object [$new_capacity];
    for (my $i = 0; $i < $self->{length}; ++$i) {
      my $target = $self->{offset} + $i;
      if ($target < 0) { $target += $self->{capacity}; };
      $new_values->[$i] = $self->{values}[$target];
    }
    $self->{offset} = -$new_capacity;
    $self->{capacity} = $new_capacity;
    $self->{values} = $new_values;
  }

  sub _reallocate : void ($self : self) {
    my $new_capacity : int;
    if ($self->{capacity} > INT32_MAX() / 2) {
      $new_capacity = INT32_MAX();
    }
    else {
      $new_capacity = $self->{capacity} * 2;
    }
    unless ($new_capacity) {
      $new_capacity = 1;
    }
    $self->_reallocate_with_capacity($new_capacity);
  }

  sub _values : object[] ($self : self) {
    return $self->{values};
  }

  sub _capacity : int ($self : self) {
    return $self->{capacity};
  }

  sub _offset : int ($self : self) {
    return $self->{offset};
  }

  sub new : SPVM::List () {
    my $self = new SPVM::List;
    my $default_capacity = 16;
    $self->{capacity} = $default_capacity;
    $self->{values} = new object [$default_capacity];
    $self->{offset} = -$default_capacity;
    return $self;
  }

  sub new_with_capacity : SPVM::List ($capacity : int) {
    my $self = new SPVM::List;
    unless ($capacity > 0) {
      croak "capacity must be positive";
    }
    $self->{capacity} = $capacity;
    $self->{values} = new object [$capacity];
    $self->{offset} = -$capacity;
    return $self;
  }

  sub new_with_array : SPVM::List ($objects : object[]) {
    my $self = new SPVM::List;
    $self->{capacity} = @$objects;
    $self->{values} = new object [@$objects];
    for (my $i = 0; $i < @$objects; ++$i) {
      $self->{values}[$i] = $objects->[$i];
    }
    $self->{length} = @$objects;
    $self->{offset} = -@$objects;
    return $self;
  }

  sub length : int ($self : self) {
    return $self->{length};
  }

  sub push : void ($self : self, $value : object) {
    if ($self->{length} + 1 > $self->{capacity}) {
      $self->_reallocate;
    }
    my $index = $self->{offset} + $self->{length};
    if ($index < 0) { $index += $self->{capacity}; }
    $self->{values}[$index] = $value;
    ++$self->{length};
  }

  sub pop : object ($self : self) {
    if ($self->{length} - 1 < 0) {
      return undef;
    }
    my $target = $self->{offset} + $self->{length} - 1 + $self->{capacity};
    my $ret = $self->{values}[$target];
    $self->{values}[$target] = undef;
    --$self->{length};
    return $ret;
  }

  sub unshift : void ($self : self, $value : object) {
    if ($self->{length} + 1 > $self->{capacity}) {
      $self->_reallocate;
    }
    if (--$self->{offset} < -$self->{capacity}) {
      $self->{offset} = -1;
    }
    $self->{values}[$self->{offset} + $self->{capacity}] = $value;
    ++$self->{length};
  }

  sub shift : object ($self : self) {
    if ($self->{length} - 1 < 0) {
      return undef;
    }
    my $ret = $self->{values}[$self->{offset} + $self->{capacity}];
    $self->{values}[$self->{offset} + $self->{capacity}] = undef;
    --$self->{length};
    if (++$self->{offset} > -1) {
      $self->{offset} = -$self->{capacity};
    }
    return $ret;
  }

  sub set : void ($self : self, $index : int, $value : object) {
    my $target = $self->{offset} + $index;
    if ($target < 0) { $target += $self->{capacity}; }
    else { $target %= $self->{capacity}; }
    $self->{values}[$target] = $value;
  }

  sub get : object ($self : self, $index : int) {
    my $target = $self->{offset} + $index;
    if ($target < 0) { $target += $self->{capacity}; }
    else { $target %= $self->{capacity}; }
    return $self->{values}[$target];
  }

  sub _rearrange_short_end_sequence : void ($self : self, $cut_offset : int, $cut_length : int, $replace_length : int) {
    if ($cut_length == $replace_length || $cut_offset == 0 || $cut_offset + $cut_length == $self->{length}) {
      return;
    }

    my $target_begin: int;
    my $target_end: int;
    my $right_sequence_moved: int;
    if ($cut_offset < $self->{length} - $cut_offset - $cut_length) {
      $target_begin = $self->{offset} + $cut_length - $replace_length;
      if ($target_begin < 0) {
        $target_begin += $self->{capacity};
      }
      $target_end = $self->{offset} + $cut_offset + $cut_length - $replace_length;
      if ($target_end < 0) {
        $target_end += $self->{capacity};
      }
      # O($cut_offset)
      $right_sequence_moved = 0;
    }
    else {
      $target_begin = $self->{offset} + $cut_offset + $replace_length;
      if ($target_begin < 0) {
        $target_begin += $self->{capacity};
      }
      $target_end = $self->{offset} + $self->{length} - $cut_length + $replace_length;
      if ($target_end < 0) {
        $target_end += $self->{capacity};
      }
      # O($self->{length} - $cut_offset - $cut_length)
      $right_sequence_moved = 1;
    }

    my $rearrange_diff = $cut_length - $replace_length;
    my $max_move: int;
    if ($target_begin < $target_end) { $max_move = $target_end - $target_begin; }
    else { $max_move = $self->{capacity} - $target_begin + $target_end; }
    my $move_count = 0;
    for (my $repr = 0; $repr < $max_move; ++$repr) {
      my $curr = $self->{offset} + $repr;
      if ($right_sequence_moved) { $curr += $cut_offset + $cut_length; }
      if ($curr < 0) { $curr += $self->{capacity}; }
      elsif ($curr >= $self->{capacity}) { $curr -= $self->{capacity}; }
      my $initial_pos = $curr;
      my $restored = $self->{values}[$curr];
      for (my $i = 0; 1; ++$i) {
        if ($i > 0 && $curr == $initial_pos) {
          last;
        }
        my $next = $curr;
        if ($right_sequence_moved) { $next -= $rearrange_diff; }
        else { $next += $rearrange_diff; }
        if ($next < 0) { $next += $self->{capacity}; }
        elsif ($next >= $self->{capacity}) { $next -= $self->{capacity}; }
        # $target_begin < $target_end: [$target_begin, $target_end)
        # $target_end < $target_begin: [$target_begin, capacity), [0, $target_end)
        if (($target_begin < $target_end && $next < $target_begin || $target_end <= $next) ||
            ($target_end < $target_begin && $next < $target_begin && $target_end <= $next)
        ) {
          last;
        }
        my $temp = $self->{values}[$next];
        $self->{values}[$next] = $restored;
        if (++$move_count == $max_move) {
          last;
        }
        $restored = $temp;
        $curr = $next;
      }
      if ($move_count == $max_move) {
        last;
      }
    }
  }

  # range of $cut_offset: [0, $cut_length]
  # O($self->{capacity})
  sub splice : object[] ($self : self, $cut_offset : int, $cut_length : int, $replace : object[]) {
    if ($cut_offset > $self->{length}) {
      warn("splice_with_list() offset past end of array");
      $cut_offset = $self->{length};
      $cut_length = 0;
    }

    # fit cut_length to the end.
    if ($cut_length > $self->{length}) {
      $cut_length = $self->{length};
    }
    if ($cut_offset > $self->{length} - $cut_length) { # always $self->{length} - $cut_length >= 0
      $cut_length = $self->{length} - $cut_offset;
    }

    my $replace_length = 0;
    if ($replace) {
      $replace_length = @$replace;
    }

    if ($self->{length} - $cut_length + $replace_length > $self->{capacity}) {
      # O($new_values_length)
      $self->_reallocate_with_capacity($self->{length} - $cut_length + $replace_length);
    }

    # extract elements
    # O($cut_length)
    my $extracted = new object [$cut_length];
    for (my $i = 0; $i < $cut_length; ++$i) {
      my $target = $self->{offset} + $i;
      if ($target > 0) { $target -= $self->{capacity}; } # to avoid overflow on the next statement
      $target += $cut_offset;
      if ($target < 0) { $target += $self->{capacity}; }
      $extracted->[$i] = $self->{values}[$target];
    }

    $self->_rearrange_short_end_sequence($cut_offset, $cut_length, $replace_length);

    # update fields
    my $prev_offset = $self->{offset};
    if ($cut_offset < $self->{length} - $cut_offset - $cut_length) {
      $self->{offset} += $cut_length - $replace_length;
      if ($self->{offset} < -$self->{capacity}) { $self->{offset} += $self->{capacity}; }
      elsif ($self->{offset} >= 0) { $self->{offset} -= $self->{capacity}; }
    }
    $self->{length} += $replace_length - $cut_length;

    # deallocate unused sequence
    if ($cut_length > $replace_length) {
      my $offset = $prev_offset;
      if ($prev_offset == $self->{offset}) {
        $offset += $self->{length};
      }
      for (my $i = 0; $i < $cut_length - $replace_length; ++$i) {
        my $target = $offset + $i;
        if ($target < 0) { $target += $self->{capacity}; }
        $self->{values}[$target] = undef;
      }
    }

    # replace with new array
    for (my $i = 0; $i < $replace_length; ++$i) {
      my $target = $self->{offset} + $cut_offset + $i;
      if ($target < 0) {
        $target += $self->{capacity};
      }
      $self->{values}[$target] = $replace->[$i];
    }

    return $extracted;
  }
}
