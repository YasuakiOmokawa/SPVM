package SPVM::Regex {
  use SPVM::Unicode (uchar);
  use SPVM::List;
  
  has patterns : SPVM::List;
  
  sub new : SPVM::Regex ($re_str : string) {
    my $self = new SPVM::Regex;
    
    $self->{patterns} = SPVM::List->new;
    
    $self->compile($re_str);
    
    return $self;
  }

  private sub compile : void ($self : self, $re_str : string) {
    
    unless ($re_str) {
      die "Regex string must be defined";
    }
    
    my $re_str_length = length $re_str;
    
    if ($re_str_length == 0) {
      die "Regex string must have length";
    }
    
    my $pos = 0;
    while ((my $uchar = uchar($re_str, \$pos)) >= 0) {
      switch ($uchar) {
        case '\\': {
          die "Not yet implemented ^";
          break;
        }
        case '^': {
          die "Not yet implemented ^";
          break;
        }
        case '.': {
          die "Not yet implemented .";
          break;
        }
        case '$': {
          die "Not yet implemented \$";
          break;
        }
        case '|': {
          die "Not yet implemented |";
          break;
        }
        case '(': {
          die "Not yet implemented (";
          break;
        }
        case ')': {
          die "Not yet implemented )";
          break;
        }
        case '[': {
          die "Not yet implemented [";
          break;
        }
        case ']': {
          die "Not yet implemented ]";
          break;
        }
        case '*': {
          die "Not yet implemented *";
          break;
        }
        case '+': {
          die "Not yet implemented +";
          break;
        }
        case '?': {
          die "Not yet implemented ?";
          break;
        }
        case '{': {
          die "Not yet implemented {";
          break;
        }
        case '}': {
          die "Not yet implemented }";
          break;
        }
        default: {
          my $pattern = new SPVM::Regex::Pattern;
          
          $pattern->{negate} = 0;
          
          my $uchar_mim_maxs = [$uchar, $uchar];
          $pattern->{uchar_mim_maxs} = $uchar_mim_maxs;
          
          $self->{patterns}->push($pattern);
        }
      }
    }
  }
  
  sub match : string[] ($self : self, $str : string) {
    
    my $patterns = $self->{patterns};
    
    my $patterns_length = $patterns->length;
    
    for (my $i = 0; $i < $patterns_length; $i++) {
      my $pattern = (SPVM::Regex::Pattern)$patterns->get($i);
      
      my $type = $pattern->{type};
      
      if ($type == SPVM::Regex::Pattern->PATTERN) {
        my $negate = $pattern->{negate};
        my $max_repeat = $pattern->{max_repeat};
        my $min_repeat = $pattern->{min_repeat};
        my $uchar_min_maxs = $pattern->{uchar_mim_maxs};
      }
      else {
        die "Not implemented";
      }
    }
    
    return undef;
  }
  
  sub replace : string ($self : self, $target : string, $replace : string) {
    
    return undef;
  }
}

package SPVM::Regex::Pattern {
  allow SPVM::Regex;
  
  enum {
    RE_START,
    RE_END,
    PATTERN,
    CAPTURE_START,
    CAPTURE_END,
  }
  
  has negate : byte;
  has type : byte;
  has max_repeat : int;
  has min_repeat : int;
  has uchar_mim_maxs : int[];
}
