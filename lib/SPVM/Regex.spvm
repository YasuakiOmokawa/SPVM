package SPVM::Regex {
  use SPVM::Unicode (uchar);
  use SPVM::List;

  has patterns : SPVM::List;
  has match_start : int;
  has match_end : int;
  
  enum {
    START,
    CONTINUE,
    QUANTIFIER_MIN,
    QUANTIFIER_MAX,
  }
  
  sub new : SPVM::Regex ($re_str : string) {
    my $self = new SPVM::Regex;
    
    $self->{patterns} = SPVM::List->new;
    
    $self->compile($re_str);
    
    return $self;
  }

  private sub compile : void ($self : self, $re_str : string) {
    
    unless ($re_str) {
      die "Regex string must be defined";
    }
    
    my $re_str_length = length $re_str;
    
    if ($re_str_length == 0) {
      die "Regex string must have length";
    }
    
    my $before_is_charset = 0;
    my $pos = 0;
    my $patterns = $self->{patterns};
    
    my $quantifier_min_str = "";
    my $quantifier_max_str = "";
    
    my $status = START();

    while ((my $uchar = uchar($re_str, \$pos)) >= 0) {
      if ($self->{match_end}) {
        die "\$ must be last of regex";
      }
      
      switch ($uchar) {
        case '\\': {
          die "Not yet implemented ^";
          break;
        }
        case '^': {
          unless ($status == START()) {
            die "Regex compile error";
          }
          
          $self->{match_start} = 1;
          
          break;
        }
        case '.': {
          die ". is not implemented";
          break;
        }
        case '$': {
          $self->{match_end} = 1;
          break;
        }
        case '|': {
          die "| is not implemented";
          break;
        }
        case '(': {
          die "Not yet implemented (";
          break;
        }
        case ')': {
          die "Not yet implemented )";
          break;
        }
        case '[': {
          die "Not yet implemented [";
          break;
        }
        case ']': {
          die "Not yet implemented ]";
          break;
        }
        case '*': {
          unless ($before_is_charset) {
            die "Regex compile error";
          }
          my $before_pattern = (SPVM::Regex::Pattern)$patterns->get($patterns->length - 1);
          $before_pattern->{min_repeat} = 0;
          $before_pattern->{max_repeat} = INT32_MAX();
          $before_is_charset = 0;
          break;
        }
        case '+': {
          unless ($before_is_charset) {
            die "Regex compile error";
          }
          my $before_pattern = (SPVM::Regex::Pattern)$patterns->get($patterns->length - 1);
          $before_pattern->{min_repeat} = 1;
          $before_pattern->{max_repeat} = INT32_MAX();
          $before_is_charset = 0;
          break;
        }
        case '?': {
          unless ($before_is_charset) {
            die "Regex compile error";
          }
          my $before_pattern = (SPVM::Regex::Pattern)$patterns->get($patterns->length - 1);
          $before_pattern->{min_repeat} = 0;
          $before_pattern->{max_repeat} = 1;
          $before_is_charset = 0;
          break;
        }
        case '{': {
          unless ($before_is_charset) {
            die "Regex compile error";
          }
          $status = QUANTIFIER_MIN();
          $before_is_charset = 0;
          break;
        }
        case '}': {
          unless ($status == QUANTIFIER_MAX()) {
            die "Regex compile error";
          }
          my $quantifier_max = strtoi($quantifier_max_str, 10);
          my $last_pattern = (SPVM::Regex::Pattern)$patterns->get($patterns->length - 1);
          $last_pattern->{max_repeat} = $quantifier_max;
          
          $status = CONTINUE();
          $before_is_charset = 0;
          $quantifier_max_str = "";
          break;
        }
        default: {
          if ($status == QUANTIFIER_MIN()) {
            if (isdigit($uchar)) {
              $quantifier_min_str .= $uchar - '0';
            }
            elsif ($uchar == ',') {
              my $quantifier_min = strtoi($quantifier_min_str, 10);
              my $last_pattern = (SPVM::Regex::Pattern)$patterns->get($patterns->length - 1);
              $last_pattern->{min_repeat} = $quantifier_min;
              
              $status = QUANTIFIER_MAX();
              $quantifier_min_str .= "";
            }
            else {
              die "Quantifier min must be non-fractional number";
            }
          }
          elsif ($status == QUANTIFIER_MAX()) {
            if (isdigit($uchar)) {
              $quantifier_max_str .= $uchar - '0';
            }
            else {
              die "Quantifier max must be non-fractional number";
            }
          }
          else {
            my $pattern = new SPVM::Regex::Pattern;
            $pattern->{type} = SPVM::Regex::Pattern->PATTERN;
            
            $pattern->{negate} = 0;
            
            my $uchar_mim_maxs = [$uchar, $uchar];
            $pattern->{uchar_mim_maxs} = $uchar_mim_maxs;
            $pattern->{max_repeat} = 1;
            $pattern->{min_repeat} = 1;
            
            $patterns->push($pattern);
            
            $before_is_charset = 1;
          }
        }
      }
    }
  }
  
  sub match : string[] ($self : self, $target : string) {
    
    unless ($target) {
      die "Target string must be defined";
    }
    
    # Convert to Unicode codepoint
    my $target_uchars_list = SPVM::IntList->new;
    {
      my $target_index = 0;
      while ((my $target_uchar = uchar($target, \$target_index)) >= 0) {
        $target_uchars_list->push($target_uchar);
      }
    }
    
    my $target_uchars = $target_uchars_list->to_array;

    my $patterns = $self->{patterns};
    my $patterns_length = $patterns->length;
    
    my $target_base_index = 0;
    my $match_all = 0;
    my $target_index = 0;
    while ($target_base_index < @$target_uchars) {
      $target_index = $target_base_index;
      my $pattern_index = 0;
      
      while ($target_index < @$target_uchars) {
        my $target_uchar = $target_uchars->[$target_index];
        my $pattern = (SPVM::Regex::Pattern)$patterns->get($pattern_index);
        
        my $type = $pattern->{type};
        
        my $match_uchar_repeat = 0;
        my $repeat_count = 0;
        if ($type == SPVM::Regex::Pattern->PATTERN) {
          # Match uchar repeat
          my $max_repeat = $pattern->{max_repeat};
          my $min_repeat = $pattern->{min_repeat};
          for (my $repeat_index = 0; $repeat_index < $max_repeat; $repeat_index++) {
            # Match uchar
            my $match_uchar = 0;
            my $uchar_min_maxs = $pattern->{uchar_mim_maxs};
            
            for (my $min_max_index = 0; $min_max_index < @$uchar_min_maxs; $min_max_index += 2) {
              
              my $uchar_min = $uchar_min_maxs->[$min_max_index];
              my $uchar_max = $uchar_min_maxs->[$min_max_index + 1];
              
              my $match_uchar_range = 0;
              if ($target_uchar >= $uchar_min && $target_uchar <= $uchar_max) {
                $match_uchar_range = 1;
              }
              
              my $negate = $pattern->{negate};
              if ($negate) {
                $match_uchar = !$match_uchar_range;
              }
              else {
                $match_uchar = $match_uchar_range;
              }
              if ($match_uchar) {
                last;
              }
            }
            
            # Increment repeat count
            if ($match_uchar) {
              $repeat_count++;
              $target_index++;
              if ($target_index == @$target_uchars) {
                last;
              }
              $target_uchar = $target_uchars->[$target_index];
            }
            else {
              last;
            }
          }
          if ($repeat_count >= $min_repeat) {
            $match_uchar_repeat = 1;
          }
        }
        else {
          die "Not implemented";
        }
        
        if ($match_uchar_repeat) {
          $pattern_index++;
          if ($pattern_index == $patterns_length) {
            last;
          }
        }
        else {
          last;
        }
      }
      
      if ($pattern_index == $patterns_length) {
        $match_all = 1;
        last;
      }
      else {
        if ($self->{match_start}) {
          last;
        }
        else {
          $target_base_index++;
        }
      }
    }
    
    if ($match_all) {
      if ($self->{match_end}) {
        if ($target_index == @$target_uchars) {
          return new string[0];
        }
        else {
          return undef;
        }
      }
      else {
        return new string[0];
      }
    }
    else {
      return undef;
    }
  }
  
  sub replace : string ($self : self, $target : string, $replace : string) {
    
    return undef;
  }
  
  private duplicate : int ($self, $pattern1, $pattern2) {
    my $uchar_min_maxs1 = $pattern1->uchar_min_maxs;
    my $uchar_min_maxs2 = $pattern2->uchar_min_maxs;
    
    my $duplicate = 1;
    for (my $min_max_index1 = 0; $min_max_index1 < @$uchar_min_maxs1; $min_max_index1 += 2) {
      my $uchar_min1 = $uchar_min_maxs1->[$min_max_index];
      my $uchar_max1 = $uchar_min_maxs1->[$min_max_index + 1];
      my $negate1 = (int)$pattern1->negate;
      
      for (my $min_max_index2 = 0; $min_max_index2 < @$uchar_min_maxs2; $min_max_index2 += 2) {
        my $uchar_min2 = $uchar_min_maxs2->[$min_max_index];
        my $uchar_max2 = $uchar_min_maxs2->[$min_max_index + 2];
        my $negate2 = (int)$pattern2->negate;
        
        if ($negate1 && $negate2) {
          if ($uchar_min2 > $uchar_max1 && $ucahr_max2 > $uchar_max1) {
            $duplicate = 0;
          }
          elsif ($uchar_min2 < $uchar_min1 && $ucahr_max2 > $uchar_min1
        }
        elsif ($negate1 && !$negate2) {
          
        }
        elsif (!$negate1 && $negate2) {
          
        }
        elsif (!$negate1 && !$negate2) {
          
        }
      }
    }
    
    
  }
}

package SPVM::Regex::Pattern {
  allow SPVM::Regex;
  
  enum {
    RE_START,
    RE_END,
    PATTERN,
    CAPTURE_START,
    CAPTURE_END,
  }
  
  has negate : byte;
  has type : byte;
  has max_repeat : int;
  has min_repeat : int;
  has uchar_mim_maxs : int[];
}
