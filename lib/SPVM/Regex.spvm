package SPVM::Regex {
  use SPVM::Unicode (uchar);
  use SPVM::List;
  
  has pattern_root : SPVM::Regex::Pattern;
  
  sub new : SPVM::Regex ($re_str : string) {
    my $self = new SPVM::Regex;
    
    unless ($re_str) {
      die "Regex string must be specified\n";
    }
    
    my $pattern_root = $self->compile($re_str);
    
    $self->{pattern_root} = $pattern_root;
    
    return $self;
  }

  private sub compile : SPVM::Regex::Pattern ($self : self, $re_str : string) {
    
    my $pos = 0;
    my $pattern_root = new SPVM::Regex::Pattern;
    $pattern_root->{type} = SPVM::Regex::Pattern->ROOT;
    $pattern_root->{patterns} = SPVM::List->new;
    
    while ((my $uchar = uchar($re_str, \$pos)) >= 0) {
      
      switch ($uchar) {
        case '\\': {
          die "Not yet implemented ^";
        }
        case '^': {
          die "Not yet implemented ^";
        }
        case '.': {
          die "Not yet implemented .";
        }
        case '$': {
          die "Not yet implemented \$";
        }
        case '|': {
          die "Not yet implemented |";
        }
        case '(': {
          die "Not yet implemented (";
        }
        case ')': {
          die "Not yet implemented )";
        }
        case '[': {
          die "Not yet implemented [";
        }
        case ']': {
          die "Not yet implemented ]";
        }
        case '*': {
          die "Not yet implemented *";
        }
        case '+': {
          die "Not yet implemented +";
        }
        case '?': {
          die "Not yet implemented ?";
        }
        case '{': {
          die "Not yet implemented {";
        }
        case '}': {
          die "Not yet implemented }";
        }
        default: {
          
          # Create charcter set
          my $negate_flag = 0;
          my $uchar_min = $uchar;
          my $uchar_max = $uchar;
          
          my $char_set = [$negate_flag, $uchar_min, $uchar_max];
          $pattern_root->{patterns}->push($char_set);
        }
      }
    }
    
    return $pattern_root ;
  }
  
  sub match : string[] ($self : self, $str : string) {
    
    return undef;
  }

  sub replace : string ($self : self, $target : string, $replace : string) {
    
    return undef;
  }
}

package SPVM::Regex::Pattern {
  allow SPVM::Regex;

  enum {
    ROOT,
    PATTERN,
    START,
    END,
  }
  
  has type : int;
  has patterns : SPVM::List;
  has max_repeat : int;
  has min_repeat : int;
  has capture_index : int;
}
