package SPVM::Util {
  use SPVM::Stringer;
  use SPVM::Cloner;
  use SPVM::EqualityChecker;
  use SPVM::StringBuffer;
  use SPVM::StringList;

  precompile sub copy_oarray : object[] ($objects : object[], $cloner : SPVM::Cloner) {
    my $length = @$objects;
    
    my $new_objects = new object[$length];
    
    for (my $i = 0; $i < $length; $i++) {
      $new_objects->[$i] = $cloner->($objects->[$i]);
    }
    
    return $new_objects;
  }

  precompile sub equals_oarray : int ($objs1 : oarray, $objs2 : oarray, $equality_checker : SPVM::EqualityChecker) {
    my $is_equals = 1;
    if (@$objs1 == @$objs2) {
      for (my $i = 0; $i < @$objs1; $i++) {
        if (!$equality_checker->($objs1->[$i], $objs2->[$i])) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }
    
    return $is_equals;
  }
  
  precompile sub joino : string ($sep : string, $objects : oarray, $stringer : SPVM::Stringer) {
    my $join = "";
    
    for (my $i = 0; $i < @$objects; $i++) {
      my $str = $stringer->($objects->[$i]);
      $join .= $str;
      if ($i != @$objects - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }

  precompile sub split : string[] ($sep : string, $string : string) {
    my $string_length = length $string;
    my $sep_length = length $sep;
    
    if ($sep_length == 0) {
      die "Separator must not be empty string";
    }
    
    my $separated_strings_list = SPVM::StringList->new;
    
    my $match_start = 0;
    my $string_base = 0;
    for (my $string_index = 0; $string_index < $string_length; $string_index++) {
      if ($string->[$string_index] == $sep->[0]) {
        $match_start = 1;
      }
      
      if ($match_start) {
        my $match = 1;
        for (my $sep_index = 0; $sep_index < $sep_length; $sep_index++) {
          if ($string_index + $sep_index > $string_length - 1) {
            $match = 0;
            last;
          }
          else {
            unless ($string->[$string_index + $sep_index] == $sep->[$sep_index]) {
              $match = 0;
              last;
            }
          }
        }
        if ($match) {
          my $separated_string = substr($string, $string_base, $string_index - $string_base);
          $separated_strings_list->push($separated_string);
          $string_base = $string_index + $sep_length;
          $string_index += $sep_length - 1;
        }
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }
    
    my $separated_strings = $separated_strings_list->to_array;
    
    return $separated_strings;
  }

  precompile sub sprintf : string ($format : string, $args : object[]...) {
    my $format_length = length $format;
    my $index = 0;

    my $output = SPVM::StringBuffer->new;
    my $args_index = 0;
    my $text_length = 0;

    while ($index < $format_length) {
      while ($index + $text_length < $format_length &&
          $format->[$index + $text_length] != '%') {
        ++$text_length;
      }
      if ($index + $text_length + 1 < $format_length &&
          $format->[$index + $text_length + 1] == '%') {
        ++$text_length;
        next;
      }

      $output->push(sliceb((byte[])$format, $index, $text_length));
      $index += $text_length;
      $text_length = 0;

      unless ($index + 1 < $format_length) {
        die "Invalid conversion in sprintf: end of string";
      }

      unless ($args_index < @$args) {
        die "Missing argument in sprintf";
      }

      my $type = $format->[++$index];

      switch ((int)$type) {
        case 'c': {
          my $arg = (SPVM::Byte)$args->[$args_index++];
          $output->push([$arg->val]);
          break;
        }
        case 's': {
          my $arg = (string)$args->[$args_index++];
          $output->push($arg);
          break;
        }
        case 'd': {
          my $arg = (SPVM::Int)$args->[$args_index++];
          $output->push($arg->val);
          break;
        }
        case 'l': {
          if ($index + 1 < $format_length &&
              $format->[$index + 1] == 'd') {
            ++$index;
            my $arg = (SPVM::Long)$args->[$args_index++];
            $output->push($arg->val);
          }
          else {
            die "Invalid conversion in sprintf: \"%" . [$type] ."\"";
          }
          break;
        }
        case 'f': {
          my $arg = (SPVM::Double)$args->[$args_index++];
          $output->push($arg->val);
          break;
        }
        case 'U': {
          die "Not implemented yet";
          break;
        }
        default: {
          die "Invalid conversion in sprintf: \"%" . [$type] ."\"";
          break;
        }
      }

      ++$index;
    }

    if ($args_index < @$args) {
      die "Redundant argument in sprintf";
    }

    return $output->to_str;
  }
}
