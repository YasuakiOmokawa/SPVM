package SPVM::Util {
  use SPVM::Stringer;
  use SPVM::Cloner;
  use SPVM::EqualityChecker;
  use SPVM::StringBuffer;
  use SPVM::StringList;
  use SPVM::Math (fabs, floor, log10, pow);

  BEGIN {
    _setup_sprintf();
  }

  precompile sub copy_oarray : object[] ($objects : object[], $cloner : SPVM::Cloner) {
    my $length = @$objects;
    
    my $new_objects = new object[$length];
    
    for (my $i = 0; $i < $length; $i++) {
      $new_objects->[$i] = $cloner->($objects->[$i]);
    }
    
    return $new_objects;
  }

  precompile sub equals_oarray : int ($objs1 : oarray, $objs2 : oarray, $equality_checker : SPVM::EqualityChecker) {
    my $is_equals = 1;
    if (@$objs1 == @$objs2) {
      for (my $i = 0; $i < @$objs1; $i++) {
        if (!$equality_checker->($objs1->[$i], $objs2->[$i])) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }
    
    return $is_equals;
  }
  
  precompile sub joino : string ($sep : string, $objects : oarray, $stringer : SPVM::Stringer) {
    my $join = "";
    
    for (my $i = 0; $i < @$objects; $i++) {
      my $str = $stringer->($objects->[$i]);
      $join .= $str;
      if ($i != @$objects - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }

  precompile sub split : string[] ($sep : string, $string : string) {
    my $string_length = length $string;
    my $sep_length = length $sep;
    
    if ($sep_length == 0) {
      die "Separator must not be empty string";
    }
    
    my $separated_strings_list = SPVM::StringList->new;
    
    my $match_start = 0;
    my $string_base = 0;
    for (my $string_index = 0; $string_index < $string_length; $string_index++) {
      if ($string->[$string_index] == $sep->[0]) {
        $match_start = 1;
      }
      
      if ($match_start) {
        my $match = 1;
        for (my $sep_index = 0; $sep_index < $sep_length; $sep_index++) {
          if ($string_index + $sep_index > $string_length - 1) {
            $match = 0;
            last;
          }
          else {
            unless ($string->[$string_index + $sep_index] == $sep->[$sep_index]) {
              $match = 0;
              last;
            }
          }
        }
        if ($match) {
          my $separated_string = substr($string, $string_base, $string_index - $string_base);
          $separated_strings_list->push($separated_string);
          $string_base = $string_index + $sep_length;
          $string_index += $sep_length - 1;
        }
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }
    
    my $separated_strings = $separated_strings_list->to_array;
    
    return $separated_strings;
  }

  private enum {
    SPECIFIER_C = 1,
    SPECIFIER_D,
    SPECIFIER_F,
    SPECIFIER_S,
    SPECIFIER_LD,
  }

  our $SPECIFIER_TYPE_OF : private ro byte[];

  precompile sub _setup_sprintf : void () {
    $SPECIFIER_TYPE_OF = new byte[128];
    $SPECIFIER_TYPE_OF->[(int)'c'] = SPVM::Util->SPECIFIER_C;
    $SPECIFIER_TYPE_OF->[(int)'d'] = SPVM::Util->SPECIFIER_D;
    $SPECIFIER_TYPE_OF->[(int)'f'] = SPVM::Util->SPECIFIER_F;
    $SPECIFIER_TYPE_OF->[(int)'s'] = SPVM::Util->SPECIFIER_S;
  }

  # TODO: Add the 2nd argument for width.
  precompile sub _convert_d_to_str : string ($value : int) {
    my $string = "" . $value;
    my $width = 1; # TODO: Move $width to the argument.

    my $value_length = length $string;
    if ($value_length < $width) {
      my $buffer = SPVM::StringBuffer->new;
      my $space_count = $width - $value_length;
      for (my $i = 0; $i < $space_count; ++$i) {
        $buffer->push_char(' ');
      }
      $buffer->push($string);
      $string = $buffer->to_str;
    }

    return $string;
  }

  # TODO: Add the 2nd argument for width.
  precompile sub _convert_ld_to_str : string ($value : long) {
    my $string = "" . $value;
    my $width = 1; # TODO: Move $width to the argument.

    my $value_length = length $string;
    if ($value_length < $width) {
      my $buffer = SPVM::StringBuffer->new;
      my $space_count = $width - $value_length;
      for (my $i = 0; $i < $space_count; ++$i) {
        $buffer->push_char(' ');
      }
      $buffer->push($string);
      $string = $buffer->to_str;
    }

    return $string;
  }

  # TODO: Add the 2nd argument for precision.
  precompile sub _convert_f_to_str : string ($double : double) {
    my $buffer = SPVM::StringBuffer->new;
    my $precision = 5; # TODO: Move $precision to the argument.

    if ($double == 0) {
      $buffer->push_char('0');
      if ($precision > 1) {
        $buffer->push_char('.');
        for (my $i = 0; $i < $precision - 1; ++$precision) {
          $buffer->push_char('0');
        }
      }
      return $buffer->to_str;
    }

    # https://stackoverflow.com/a/29583280
    my $exp = 1 + floor(log10(fabs($double))); # $double != 0
    my $frac_mantissa = $double * pow(10 , -$exp);
    for (my $i = 0; $i < $precision; ++$i) {
      my $upper_pow = pow(10, $exp + $i);
      my $digit = (byte)($frac_mantissa * $upper_pow);
      if ($exp == $i) {
        $buffer->push_char('.');
      }
      $buffer->push_char((byte)('0' + $digit));
      $frac_mantissa -= $digit * pow(10, -($exp + $i));
    }

    return $buffer->to_str;
  }

  precompile sub sprintf : string ($format : string, $args : object[]...) {
    my $format_length = length $format;
    my $index = 0;

    my $output = SPVM::StringBuffer->new;
    my $specifier_count = 0;

    while (1) {
      my $next_index = $index;
      while ($next_index < $format_length && $format->[$next_index] != '%') {
        ++$next_index;
      }

      if ($next_index + 1 == $format_length && $format->[$next_index] == '%') {
        die "Invalid conversion in sprintf: end of string";
      }

      if ($next_index + 1 < $format_length &&
          $format->[$next_index] == '%' && $format->[$next_index + 1] == '%') {
        $next_index += 2;
        next;
      }

      if (my $text_length = $next_index - $index) {
        $output->push_range($format, $index, $text_length);
        $index = $next_index;
      }

      unless ($index + 1 < $format_length) {
        last;
      }

      unless ($specifier_count < @$args) {
        die "Missing argument in sprintf";
      }

      my $specifier_length = 1; # '%'

      my $specifier_type : int;
      if ($format->[$index + $specifier_length] == 'l') {
        if ($index + $specifier_length + 1 < $format_length &&
            $format->[$index + $specifier_length + 1] == 'd') {
          $specifier_type = SPVM::Util->SPECIFIER_LD;
        }
        else {
          die "Invalid conversion in sprintf: \"" . substr($format, $index, $specifier_length + 1) ."\"";
        }
      }
      else {
        $specifier_type = $SPECIFIER_TYPE_OF->[$format->[$index + $specifier_length]];
      }

      switch ($specifier_type) {
        case SPVM::Util->SPECIFIER_C: {
          ++$specifier_length;
          my $arg = (SPVM::Byte)$args->[$specifier_count];
          $output->push_char($arg->val);
          break;
        }
        case SPVM::Util->SPECIFIER_S: {
          ++$specifier_length;
          my $arg = (string)$args->[$specifier_count];
          $output->push($arg);
          break;
        }
        case SPVM::Util->SPECIFIER_D: {
          ++$specifier_length;
          my $arg = (SPVM::Int)$args->[$specifier_count];
          my $str = _convert_d_to_str($arg->val);
          $output->push($str);
          break;
        }
        case SPVM::Util->SPECIFIER_LD: {
          $specifier_length += 2;
          my $arg = (SPVM::Long)$args->[$specifier_count];
          my $str = _convert_ld_to_str($arg->val);
          $output->push($str);
          break;
        }
        case SPVM::Util->SPECIFIER_F: {
          ++$specifier_length;
          my $arg = (SPVM::Double)$args->[$specifier_count];
          my $str = _convert_f_to_str($arg->val);
          $output->push($str);
          break;
        }
        case 'U': {
          die "Not implemented yet";
          break;
        }
        default: {
          die "Invalid conversion in sprintf: \"" . substr($format, $index, $specifier_length + 1) . "\"";
          break;
        }
      }

      $index += $specifier_length;
      ++$specifier_count;
    }

    if ($specifier_count < @$args) {
      die "Redundant argument in sprintf";
    }

    return $output->to_str;
  }
}
