package SPVM::Util {
  use SPVM::ByteList;
  use SPVM::IntList;
  use SPVM::Stringer;
  use SPVM::StringList;
  use SPVM::List;
  
  precompile sub joino : string ($sep : string, $objects : oarray) {
    my $join = "";
    
    for (my $i = 0; $i < @$objects; $i++) {
      my $stringer = (SPVM::Stringer)$objects->[$i];
      my $string = $stringer->to_str();
      $join .= $string;
      if ($i != @$objects - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }

  precompile sub split : string[] ($sep : string, $string : string) {
    my $string_length = length $string;
    my $sep_length = length $sep;
    
    if ($sep_length == 0) {
      die "Separator must not be empty string";
    }
    
    my $separated_strings_list = SPVM::StringList->new;
    
    my $match_start = 0;
    my $string_base = 0;
    for (my $string_index = 0; $string_index < $string_length; $string_index++) {
      if ($string->[$string_index] == $sep->[0]) {
        $match_start = 1;
      }
      
      if ($match_start) {
        my $match = 1;
        for (my $sep_index = 0; $sep_index < $sep_length; $sep_index++) {
          if ($string_index + $sep_index > $string_length - 1) {
            $match = 0;
            last;
          }
          else {
            unless ($string->[$string_index + $sep_index] == $sep->[$sep_index]) {
              $match = 0;
              last;
            }
          }
        }
        if ($match) {
          my $separated_string = substr($string, $string_base, $string_index - $string_base);
          $separated_strings_list->push($separated_string);
          $string_base = $string_index + $sep_length;
          $string_index += $sep_length - 1;
        }
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }
    
    my $separated_strings = $separated_strings_list->to_array;
    
    return $separated_strings;
  }

  private precompile sub _sprintf_parse_format : SPVM::List ($format : string) {
    my $length = length $format;
    my $parsed_format = SPVM::List->new;
    my $text_begin = 0;
    my $index = 0;
    my $placeholders_count_check = 0;

    while ($index < $length) {
      my $cand_text_end = $index;

      my $ch = $format->[$index++];

      if ($ch == '%') {
        if ($index == $length) {
          warn("Invalid conversion in sprintf: end of string");
          last;
        }

        my $type = $format->[$index++];
        if ($type == '%') {
          next;
        }

        if ($text_begin < $cand_text_end) { # avoid (begin:0, end:0)
          my $text_range = SPVM::IntList->newa([$text_begin, $cand_text_end]);
          $parsed_format->push($text_range);
        }

        # only supports simple syntax. TODO: %[flags][width][.precision][length]type
        switch ((int)$type) {
          case 'c': case 's': case 'd': case 'f': {
            my $placeholder = SPVM::ByteList->newa([$type]); # TODO: %[flags][width][.precision][length]type
            $parsed_format->push($placeholder);
            ++$placeholders_count_check;
            break;
          }
          default: {
            # "hoge%dfuga%kpiyo" is expanded like "hoge1fuga%kpiyo"
            # "%k" is treated as plain text.
            warn("Invalid conversion in sprintf: \"%" . [$type] ."\"");
            my $begin_invalid_placeholder = $cand_text_end;
            my $end_invalid_placeholder   = $index;
            my $text_range = SPVM::IntList->newa(
                [$begin_invalid_placeholder, $end_invalid_placeholder]);
            $parsed_format->push($text_range);
            break;
          }
        }

        $text_begin = $index;
      }
    }

    if ($text_begin < $length) {
      my $text_range = SPVM::IntList->newa([$text_begin, $length]);
      $parsed_format->push($text_range);
    }

    $parsed_format->push($placeholders_count_check);

    return $parsed_format;
  }

  private precompile sub _sprintf_insert_args : string ($format : string, $args : object[],
      $parsed_format : SPVM::List) {

    my $placeholders_count_check = ((SPVM::Int)$parsed_format->pop)->val;
    if ($placeholders_count_check < @$args) {
      warn("Redundant argument in sprintf");
    }
    elsif ($placeholders_count_check > @$args) {
      warn("Missing argument in sprintf");
    }

    my $parsed_format_length = $parsed_format->length;
    my $output = "";
    my $args_index = 0;

    for (my $array_index = 0; $array_index < $parsed_format_length; ++$array_index) {
      my $current_parsed_format = $parsed_format->get($array_index);
      if ($current_parsed_format isa SPVM::ByteList) {
        my $current_arg : object;
        if ($args_index < @$args) {
          $current_arg = $args->[$args_index++];
        }

        my $placeholder = (SPVM::ByteList)$current_parsed_format;
        my $type = $placeholder->get(0);

        switch ((int)$type) {
          case 'c': {
            if (!$current_arg) {
              warn("Use of uninitialized value in sprintf");
            }
            elsif ($current_arg isa SPVM::Byte) {
              $output .= [((SPVM::Byte)$current_arg)->val];
            }
            else {
              warn("Argument isn't SPVM::Byte in sprintf");
            }
            break;
          }
          case 's': {
            if (!$current_arg) {
              warn("Use of uninitialized value in sprintf");
            }
            elsif ($current_arg isa string) {
              $output .= (string)$current_arg;
            }
            else {
              warn("Argument isn't string in sprintf");
            }
            break;
          }
          case 'd': {
            if (!$current_arg) {
              warn("Use of uninitialized value in sprintf");
              $output .= "0";
            }
            elsif ($current_arg isa SPVM::Int) {
              my $val = ((SPVM::Int)$current_arg)->val;
              $output .= $val;
            }
            else {
              warn("Argument isn't SPVM::Int in sprintf");
              $output .= "0";
            }
            break;
          }
          case 'f': {
            if (!$current_arg) {
              warn("Use of uninitialized value in sprintf");
              $output .= "0";
            }
            elsif ($current_arg isa SPVM::Double) {
              my $val = ((SPVM::Double)$current_arg)->val;
              $output .= $val;
            }
            else {
              warn("Argument isn't SPVM::Double in sprintf");
              $output .= "0";
            }
            break;
          }
          default: {
            die "[BUG] Unknown conversion in sprintf: \"%" . [$type] ."\"";
            break;
          }
        }
      }
      else {
        my $text_range = (SPVM::IntList)$current_parsed_format;
        my $begin = $text_range->get(0);
        my $end = $text_range->get(1);
        $output .= sliceb((byte [])$format, $begin, $end - $begin);
      }
    }

    return $output;
  }

  precompile sub sprintf : string ($format : string, $args : object[]...) {
    my $parsed_format = _sprintf_parse_format($format);
    return _sprintf_insert_args($format, $args, $parsed_format);
  }
}
