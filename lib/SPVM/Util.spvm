package SPVM::Util {
  use SPVM::Stringer;
  use SPVM::Cloner;
  use SPVM::EqualityChecker;
  use SPVM::StringBuffer;
  use SPVM::StringList;
  use SPVM::Unicode (uchar_to_utf8);
  use SPVM::Math (fabs, floor, log10, pow);

  precompile sub copy_oarray : object[] ($objects : object[], $cloner : SPVM::Cloner) {
    my $length = @$objects;
    
    my $new_objects = new object[$length];
    
    for (my $i = 0; $i < $length; $i++) {
      $new_objects->[$i] = $cloner->($objects->[$i]);
    }
    
    return $new_objects;
  }

  precompile sub equals_oarray : int ($objs1 : oarray, $objs2 : oarray, $equality_checker : SPVM::EqualityChecker) {
    my $is_equals = 1;
    if (@$objs1 == @$objs2) {
      for (my $i = 0; $i < @$objs1; $i++) {
        if (!$equality_checker->($objs1->[$i], $objs2->[$i])) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }
    
    return $is_equals;
  }
  
  precompile sub joino : string ($sep : string, $objects : oarray, $stringer : SPVM::Stringer) {
    my $join = "";
    
    for (my $i = 0; $i < @$objects; $i++) {
      my $str = $stringer->($objects->[$i]);
      $join .= $str;
      if ($i != @$objects - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }

  precompile sub split : string[] ($sep : string, $string : string) {
    my $string_length = length $string;
    my $sep_length = length $sep;
    
    if ($sep_length == 0) {
      die "Separator must not be empty string";
    }
    
    my $separated_strings_list = SPVM::StringList->new;
    
    my $match_start = 0;
    my $string_base = 0;
    for (my $string_index = 0; $string_index < $string_length; $string_index++) {
      if ($string->[$string_index] == $sep->[0]) {
        $match_start = 1;
      }
      
      if ($match_start) {
        my $match = 1;
        for (my $sep_index = 0; $sep_index < $sep_length; $sep_index++) {
          if ($string_index + $sep_index > $string_length - 1) {
            $match = 0;
            last;
          }
          else {
            unless ($string->[$string_index + $sep_index] == $sep->[$sep_index]) {
              $match = 0;
              last;
            }
          }
        }
        if ($match) {
          my $separated_string = substr($string, $string_base, $string_index - $string_base);
          $separated_strings_list->push($separated_string);
          $string_base = $string_index + $sep_length;
          $string_index += $sep_length - 1;
        }
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }
    
    my $separated_strings = $separated_strings_list->to_array;
    
    return $separated_strings;
  }

  precompile sub _modify_specifier : string ($value_str : string, $left_justified : int, $pad_char : byte, $width : int) {
    my $value_length = length $value_str;

    unless ($value_length < $width) {
      return $value_str;
    }

    my $buffer = SPVM::StringBuffer->new;
    my $space_count = $width - $value_length;

    if ($left_justified) {
      $buffer->push($value_str);
    }
    for (my $i = 0; $i < $space_count; ++$i) {
      $buffer->push_char($pad_char);
    }
    unless ($left_justified) {
      $buffer->push($value_str);
    }

    my $result = $buffer->to_string;
    return $result;
  }

  native sub _snsprintf_double : string ($format : string, $value : double);

  precompile sub sprintf : string ($format : string, $args : object[]...) {
    my $format_length = length $format;
    my $index = 0;

    my $output = SPVM::StringBuffer->new;
    my $arg_count = 0;

    while ($index < $format_length) {

      my $normal_str_end = $index;

      # Search the next specifier '%' until the end of $format.
      while ($normal_str_end < $format_length) {
        if ($format->[$normal_str_end] == '%') {
          last;
        }
        else {
          ++$normal_str_end;
        }
      }

      if ($normal_str_end < $format_length &&
          $format->[$normal_str_end] == '%' &&
          $normal_str_end + 1 == $format_length) {
        die "Invalid conversion in sprintf: end of string";
      }

      if ($normal_str_end + 1 < $format_length &&
          $format->[$normal_str_end + 1] == '%') {
        my $normal_str_length = $normal_str_end + 1 - $index;
        $output->push_range($format, $index, $normal_str_length);
        $index = $normal_str_end + 2;
        next;
      }

      # Output the normal sub-string of $format.
      if (my $normal_str_length = $normal_str_end - $index) {
        $output->push_range($format, $index, $normal_str_length);
        $index = $normal_str_end;
      }

      unless ($index < $format_length) {
        last;
      }

      # Output the next element of $args corresponding to the specifier.
      unless ($arg_count < @$args) {
        die "Missing argument in sprintf";
      }

      # Read specifier %[flags][width][.precision][length]type

      my $specifier_base_index = $index;
      ++$index; # '%'

      # Read `flags`
      my $pad_char = ' ';
      my $plus_sign = 0;
      my $left_justified = 0;

      while ($index < $format_length) {
        my $flag = (int)($format->[$index]);
        switch($flag) {
          case '0': {
            ++$index;
            $pad_char = '0';
            break;
          }
          case '+': {
            ++$index;
            $plus_sign = 1;
            break;
          }
          case '-': {
            ++$index;
            $left_justified = 1;
            break;
          }
          default: {
            last;
            break;
          }
        }
      }

      # Read `width`
      my $width = 0;
      while ($index < $format_length) {
        my $c = $format->[$index];
        if ($c < '0' || '9' < $c) {
          last;
        }
        $width = $width * 10 + $c - '0';
        ++$index;
      }

      # Read `precision` (just skip because type 'f' is printed by native sprintf)
      if ($index < $format_length && $format->[$index] == '.') {
        ++$index;
        while ($index < $format_length) {
          my $c = $format->[$index];
          if ($c < '0' || '9' < $c) {
            last;
          }
          ++$index;
        }
      }

      unless ($index < $format_length) {
        die "Invalid conversion in sprintf: \""
            . substr($format, $specifier_base_index, $index - $specifier_base_index) . "\"";
      }

      my $specifier_char = $format->[$index];
      if ($specifier_char == 'c') {
        ++$index;
        my $arg = ((SPVM::Byte)$args->[$arg_count])->val;
        my $str = _modify_specifier([$arg], $left_justified, $pad_char, $width);
        $output->push($str);
      }
      elsif ($specifier_char == 's') {
        ++$index;
        my $arg = (string)$args->[$arg_count];
        my $str = _modify_specifier($arg, $left_justified, $pad_char, $width);
        $output->push($str);
      }
      elsif ($specifier_char == 'd') {
        ++$index;
        my $arg = ((SPVM::Int)$args->[$arg_count])->val;
        my $s = "";
        if ($plus_sign && $arg >= 0) {
          $s = "+$arg";
        } else {
          $s = "$arg";
        }
        my $str = _modify_specifier($s, $left_justified, $pad_char, $width);
        $output->push($str);
      }
      elsif ($specifier_char == 'l') {
        unless ($index + 1 < $format_length && $format->[$index + 1] == 'd') {
          die "Invalid conversion in sprintf: \""
              . substr($format, $specifier_base_index, $index - $specifier_base_index + 1) . "\"";
        }
        $index += 2;
        my $arg = ((SPVM::Long)$args->[$arg_count])->val;
        my $s = "";
        if ($plus_sign && $arg >= 0) {
          $s = "+$arg";
        } else {
          $s = "$arg";
        }
        my $str = _modify_specifier($s, $left_justified, $pad_char, $width);
        $output->push($str);
      }
      elsif ($specifier_char == 'f' || $specifier_char == 'g') {
        ++$index;
        my $arg = (SPVM::Double)$args->[$arg_count];
        my $specifier_str = substr($format, $specifier_base_index, $index - $specifier_base_index);
        my $str = _snsprintf_double($specifier_str, $arg->val);
        $output->push($str);
      }
      elsif ($specifier_char == 'U') {
        ++$index;
        my $arg = (SPVM::Int)$args->[$arg_count];
        my $utf8 = uchar_to_utf8($arg->val);
        $output->push($utf8);
      }
      else {
        die "Invalid conversion in sprintf: \""
            . substr($format, $specifier_base_index, $index - $specifier_base_index + 1) . "\"";
      }

      ++$arg_count;
    }

    if ($arg_count < @$args) {
      die "Redundant argument in sprintf";
    }

    return $output->to_string;
  }
}
