package SPVM::Util {
  use SPVM::Stringer;
  use SPVM::Cloner;
  use SPVM::EqualityChecker;
  use SPVM::StringBuffer;
  use SPVM::StringList;

  BEGIN {
    _setup_sprintf();
  }

  precompile sub copy_oarray : object[] ($objects : object[], $cloner : SPVM::Cloner) {
    my $length = @$objects;
    
    my $new_objects = new object[$length];
    
    for (my $i = 0; $i < $length; $i++) {
      $new_objects->[$i] = $cloner->($objects->[$i]);
    }
    
    return $new_objects;
  }

  precompile sub equals_oarray : int ($objs1 : oarray, $objs2 : oarray, $equality_checker : SPVM::EqualityChecker) {
    my $is_equals = 1;
    if (@$objs1 == @$objs2) {
      for (my $i = 0; $i < @$objs1; $i++) {
        if (!$equality_checker->($objs1->[$i], $objs2->[$i])) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }
    
    return $is_equals;
  }
  
  precompile sub joino : string ($sep : string, $objects : oarray, $stringer : SPVM::Stringer) {
    my $join = "";
    
    for (my $i = 0; $i < @$objects; $i++) {
      my $str = $stringer->($objects->[$i]);
      $join .= $str;
      if ($i != @$objects - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }

  precompile sub split : string[] ($sep : string, $string : string) {
    my $string_length = length $string;
    my $sep_length = length $sep;
    
    if ($sep_length == 0) {
      die "Separator must not be empty string";
    }
    
    my $separated_strings_list = SPVM::StringList->new;
    
    my $match_start = 0;
    my $string_base = 0;
    for (my $string_index = 0; $string_index < $string_length; $string_index++) {
      if ($string->[$string_index] == $sep->[0]) {
        $match_start = 1;
      }
      
      if ($match_start) {
        my $match = 1;
        for (my $sep_index = 0; $sep_index < $sep_length; $sep_index++) {
          if ($string_index + $sep_index > $string_length - 1) {
            $match = 0;
            last;
          }
          else {
            unless ($string->[$string_index + $sep_index] == $sep->[$sep_index]) {
              $match = 0;
              last;
            }
          }
        }
        if ($match) {
          my $separated_string = substr($string, $string_base, $string_index - $string_base);
          $separated_strings_list->push($separated_string);
          $string_base = $string_index + $sep_length;
          $string_index += $sep_length - 1;
        }
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }
    
    my $separated_strings = $separated_strings_list->to_array;
    
    return $separated_strings;
  }

  private enum {
    SPECIFIER_C,
    SPECIFIER_D,
    SPECIFIER_F,
    SPECIFIER_S,
    SPECIFIER_LD,
  }

  our $SPECIFIER_TYPE_OF : private ro byte[];

  precompile sub _setup_sprintf : void () {
    $SPECIFIER_TYPE_OF = new byte[128];
    $SPECIFIER_TYPE_OF->[(int)'c'] = SPVM::Util->SPECIFIER_C;
    $SPECIFIER_TYPE_OF->[(int)'d'] = SPVM::Util->SPECIFIER_D;
    $SPECIFIER_TYPE_OF->[(int)'f'] = SPVM::Util->SPECIFIER_F;
    $SPECIFIER_TYPE_OF->[(int)'s'] = SPVM::Util->SPECIFIER_S;
  }

  precompile sub sprintf : string ($format : string, $args : object[]...) {
    my $format_length = length $format;
    my $index = 0;

    my $output = SPVM::StringBuffer->new;
    my $args_index = 0;
    my $text_length = 0;

    while ($index < $format_length) {
      while ($index + $text_length < $format_length &&
          $format->[$index + $text_length] != '%') {
        ++$text_length;
      }
      if ($index + $text_length + 1 < $format_length &&
          $format->[$index + $text_length + 1] == '%') {
        ++$text_length;
        next;
      }

      $output->push_range($format, $index, $text_length);
      $index += $text_length;
      $text_length = 0;

      unless ($index + 1 < $format_length) {
        die "Invalid conversion in sprintf: end of string";
      }

      unless ($args_index < @$args) {
        die "Missing argument in sprintf";
      }

      ++$index; # read '%'

      my $specifier_type : int;
      if ($format->[$index] == 'l') {
        if ($format->[$index + 1] == 'd') {
          $specifier_type = SPVM::Util->SPECIFIER_LD;
        }
        else {
          die "Invalid conversion in sprintf: \"%" . [$format->[$index]] ."\"";
        }
      }
      else {
        $specifier_type = $SPECIFIER_TYPE_OF->[$format->[$index]];
      }

      switch ($specifier_type) {
        case SPVM::Util->SPECIFIER_C: {
          my $arg = (SPVM::Byte)$args->[$args_index++];
          $output->push_char($arg->val);
          break;
        }
        case SPVM::Util->SPECIFIER_S: {
          my $arg = (string)$args->[$args_index++];
          $output->push($arg);
          break;
        }
        case SPVM::Util->SPECIFIER_D: {
          my $arg = (SPVM::Int)$args->[$args_index++];
          $output->push($arg->val);
          break;
        }
        case SPVM::Util->SPECIFIER_LD: {
          ++$index;
          my $arg = (SPVM::Long)$args->[$args_index++];
          $output->push($arg->val);
          break;
        }
        case SPVM::Util->SPECIFIER_F: {
          my $arg = (SPVM::Double)$args->[$args_index++];
          $output->push($arg->val);
          break;
        }
        case 'U': {
          die "Not implemented yet";
          break;
        }
        default: {
          die "Invalid conversion in sprintf: \"%" . [(byte) $specifier_type] ."\"";
          break;
        }
      }

      ++$index;
    }

    if ($args_index < @$args) {
      die "Redundant argument in sprintf";
    }

    return $output->to_str;
  }
}
