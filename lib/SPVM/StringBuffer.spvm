package SPVM::StringBuffer {
  use SPVM::Hash;

  has value      : byte[];
  has length      : ro int;
  
  private enum {
    DEFAULT_CAPACITY = 16,
  }
  
  sub capacity : int ($self : self) {
    return @$self->{value};
  }
  
  sub _copy_value : byte[] ($self : self) {
    return copy_barray($self->{value});
  }
  
  private sub _reallocate : void ($self : self, $new_capacity : int) {
    my $new_string = new byte [$new_capacity];
    for (my $i = 0; $i < $self->{length}; ++$i) {
      $new_string->[$i] = $self->{value}[$i];
    }
    $self->{value} = $new_string;
  }

  sub new : SPVM::StringBuffer () {
    my $self = new SPVM::StringBuffer;
    my $default_capacity = DEFAULT_CAPACITY();
    $self->{value} = new byte [$default_capacity];
    $self->{length} = 0;
    return $self;
  }
  
  sub new_opt : SPVM::StringBuffer ($options : object[]) {
    my $options_h = SPVM::Hash->newa($options);
    
    my $self = new SPVM::StringBuffer;

    my $default_capacity : int;
    if ($options_h->exists("capacity")) {
      $default_capacity = (int)$options_h->delete("capacity");
    }
    else {
      $default_capacity = DEFAULT_CAPACITY();
    }
    
    # Minimal capacity is 1
    if ($default_capacity < 1) {
      die "Invalid capacity";
    }
    
    $self->{value} = new byte [$default_capacity];
    $self->{length} = 0;
    
    return $self;
  }

  sub substr : SPVM::StringBuffer ($self : self, $offset : int, $length : int) {
    if ($offset >= $self->{length}) {
      die("substr offset is greater or equal than string length");
      return SPVM::StringBuffer->new;
    }
    
    my $new_capacity = $length;
    
    my $new_text = SPVM::StringBuffer->new_opt([(object)capacity => $new_capacity]);
    
    for (my $i = 0; $i < $length; $i++) {
      $new_text->{value}[$i] = $self->{value}[$offset + $i];
    }
    $new_text->{length} = $length;
    
    return $new_text;
  }

  sub copy : SPVM::StringBuffer ($self : self) {
    my $ret = SPVM::StringBuffer->new;
    $ret->{value}      = $self->{value};
    $ret->{length}      = $self->{length};
    return $ret;
  }

  # O($self->{length} + $buffer)
  sub prepend : void ($self : self, $buffer : SPVM::StringBuffer) {
    my $new_string = new byte [$self->{length} + $buffer->{length}];
    for (my $i = 0; $i < $buffer->{length}; ++$i) {
      $new_string->[$i] = $buffer->{value}->[$i];
    }
    for (my $i = 0; $i < $self->{length}; ++$i) {
      $new_string->[$buffer->{length} + $i] = $self->{value}[$i];
    }
    $self->{value} = $new_string;
    $self->{length} = @$new_string;
  }

  sub append : void ($self : self, $buffer : SPVM::StringBuffer) {
    my $capacity = @$self->{value};
    if ($self->{length} + $buffer->{length} > $capacity) {
      # O($new_capacity)
      my $new_capacity : int;
      if ($self->{length} + $buffer->{length} > $capacity * 2) {
        $new_capacity = $self->{length} + $buffer->{length};
      } else {
        $new_capacity = $capacity * 2;
      }
      $self->_reallocate($new_capacity);
      for (my $i = 0; $i < $buffer->{length}; ++$i) {
        $self->{value}[$self->{length} + $i] = $buffer->{value}->[$i];
      }
      $self->{length} += $buffer->{length};
    }
    else {
      for (my $i = 0; $i < $buffer->{length}; ++$i) {
        $self->{value}[$self->{length} + $i] = $buffer->{value}->[$i];
      }
      $self->{length} += $buffer->{length};
    }
  }

  sub append_bytes : void ($self : self, $bytes : byte[]) {
    my $length = @$bytes;
    my $capacity = @$self->{value};
    if ($self->{length} + $length > $capacity) {
      # O($new_capacity)
      my $new_capacity : int;
      if ($self->{length} + $length > $capacity * 2) {
        $new_capacity = $self->{length} + $length;
      } else {
        $new_capacity = $capacity * 2;
      }
      $self->_reallocate($new_capacity);
      for (my $i = 0; $i < $length; ++$i) {
        $self->{value}[$self->{length} + $i] = $bytes->[$i];
      }
      $self->{length} += $length;
    }
    else {
      for (my $i = 0; $i < $length; ++$i) {
        $self->{value}[$self->{length} + $i] = $bytes->[$i];
      }
      $self->{length} += $length;
    }
  }

  sub push  : void ($self : self, $string : string) {
    my $length = length($string);
    my $capacity = @$self->{value};
    if ($self->{length} + $length > $capacity) {
      # O($new_capacity)
      my $new_capacity : int;
      if ($self->{length} + $length > $capacity * 2) {
        $new_capacity = $self->{length} + $length;
      } else {
        $new_capacity = $capacity * 2;
      }
      $self->_reallocate($new_capacity);
      for (my $i = 0; $i < $length; ++$i) {
        $self->{value}[$self->{length} + $i] = $string->[$i];
      }
      $self->{length} += $length;
    }
    else {
      for (my $i = 0; $i < $length; ++$i) {
        $self->{value}[$self->{length} + $i] = $string->[$i];
      }
      $self->{length} += $length;
    }
  }

  sub index : int ($self : self, $search : string, $from_index : int) {
    my $slen = length $search;
    for (my $i = $from_index; $i < $self->{length} - $slen + 1; ++$i) {
      my $found = 1;
      for (my $j = 0; $j < $slen; ++$j) {
        if ($self->{value}[$i + $j] != $search->[$j]) {
          $found = 0;
          last;
        }
      }
      if ($found) {
        return $i;
      }
    }
    return -1;
  }

  sub to_str : string ($self : self) {
    return (string)(sliceb($self->{value}, 0, $self->{length}));
  }
}
