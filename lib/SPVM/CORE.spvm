package SPVM::CORE {
  
  # NOTE
  # SPVM::CORE is core function of SPVM
  # Don't use any ohter modules in SPVM::CORE except for default loaded modules.
  # Don't use any system calls except for print or warn statement.
  
  precompile sub index : int ($str : string, $substr : string, $posision : int) {
    my $strCount = length $str;
    my $substrCount = length $substr;
    
    if ($posision >= $strCount) {
      my $ret : int;
      if ($substrCount == 0) {
        $ret = $strCount;
      }
      else {
        $ret = -1;
      }
      return $ret;
    }
    if ($posision < 0) {
      $posision = 0;
    }
    if ($substrCount == 0) {
      return $posision;
    }

    my $first : byte  = $substr->[0];
    my $max : int = ($strCount - $substrCount);

    for (my $i = $posision; $i <= $max; $i++) {
      if ($str->[$i] != $first) {
        while (++$i <= $max && $str->[$i] != $first) {}
      }

      if ($i <= $max) {
        my $j = $i + 1;
        my $end = $j + $substrCount - 1;
        for (my $k = 01; $j < $end && $str->[$j] == $substr->[$k]; ($j++, $k++)) {}

        if ($j == $end) {
          return $i;
        }
      }
    }
    return -1;
  }

  sub INT8_MIN : byte () { return -128; }
  sub INT8_MAX : byte () { return 127; }

  sub INT16_MIN : short () { return -32768; }
  sub INT16_MAX : short () { return 32767; }

  sub INT32_MIN : int () { return -2147483648; }
  sub INT32_MAX : int () { return 2147483647; }

  sub UINT32_MAX : long () { return 4294967295L; }

  sub INT64_MIN : long () { return -9223372036854775808L; }
  sub INT64_MAX : long () { return 9223372036854775807L; }

  native sub DBL_MAX : double ();
  native sub DBL_MIN : double ();

  native sub FLT_MAX : float ();
  native sub FLT_MIN : float();

  precompile sub isalnum : int ($char : int) {
    
    if (($char >= 'A' && $char <= 'Z') || ($char >= 'a' && $char <= 'z') || ($char >= '0' && $char <= '9')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub isalpha : int ($char : int) {
    
    if (($char >= 'A' && $char <= 'Z') || ($char >= 'a' && $char <= 'z')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub isblank : int ($char : int) {
    
    if ($char >= ' ' ||  $char <= '\t') {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub iscntrl : int ($char : int) {
    
    if (($char >= 0x00 && $char <= 0x1f) || $char == 0x7f) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub isdigit : int ($char : int) {
    
    if ($char >= '0' && $char <= '9') {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub isgraph : int ($char : int) {
    
    if ($char >= 0x21 && $char <= 0x7e) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub islower : int ($char : int) {
    
    if ($char >= 'a' && $char <= 'z') {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub isprint : int ($char : int) {
    
    if ($char >= 0x20 && $char <= 0x7e) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub ispunct : int ($char : int) {
    
    if (($char >= 0x21 && $char <= 0x2f) || ($char >= 0x3a && $char <= 0x40) || ($char >= 0x5b && $char <= 0x60) || ($char >= 0x7b && $char <= 0x7e)) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub isspace : int ($char : int) {
    
    if (($char >= 0x09 && $char <= 0x0d) || $char == 0x20) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub isupper : int ($char : int) {
    
    if ($char >= 'A' && $char <= 'Z') {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub isxdigit : int ($char : int) {
    
    if (($char >= 'A' && $char <= 'F') || ($char >= 'a' && $char <= 'f') || ($char >= '0' && $char <= '9')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile sub tolower : int ($char : int) {
    
    if ($char >= 'A' && $char <= 'Z') {
      $char = $char + 0x20;
    }
    return $char;
  }

  precompile sub toupper : int ($char : int) {
    
    if ($char >= 'a' && $char <= 'z') {
      $char = $char - 0x20;
    }
    return $char;
  }
  
  # This is same as Perl \s
  precompile sub is_perl_space : int ($char : int) {
    my $ispspace = 0;
    switch ($char) {
      case ' ':
      case '\r':
      case '\n':
      case '\t':
      case '\f':
      {
        $ispspace = 1;
        break;
      }
    }
    return $ispspace;
  }

  precompile sub is_perl_word : int ($char : int) {
    my $ispword = 0;
    
    if ($char >= 'a' && $char <= 'z') {
      $ispword = 1;
    }
    elsif ($char >= 'A' && $char <= 'Z') {
      $ispword = 1;
    }
    elsif ($char == '_') {
      $ispword = 1;
    }
    elsif ($char >= '0' && $char <= '9') {
      $ispword = 1;
    }
    return $ispword;
  }

  precompile sub joinb : string ($sep : string, $nums : byte[]) {
    my $join = "";
    
    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $join .= $string;
      if ($i != @$nums - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }
  
  precompile sub joins : string ($sep : string, $nums : short[]) {
    my $join = "";
    
    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $join .= $string;
      if ($i != @$nums - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }
  
  precompile sub joini : string ($sep : string, $nums : int[]) {
    my $join = "";
    
    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $join .= $string;
      if ($i != @$nums - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }
  
  precompile sub joinl : string ($sep : string, $nums : long[]) {
    my $join = "";
    
    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $join .= $string;
      if ($i != @$nums - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }
  
  precompile sub joinf : string ($sep : string, $nums : float[]) {
    my $join = "";
    
    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $join .= $string;
      if ($i != @$nums - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }
  
  precompile sub joind : string ($sep : string, $nums : double[]) {
    my $join = "";
    
    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $join .= $string;
      if ($i != @$nums - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }

  precompile sub join : string ($sep : string, $strings : string[]) {
    my $join = "";
    
    for (my $i = 0; $i < @$strings; $i++) {
      my $string = $strings->[$i];
      $join .= $string;
      if ($i != @$strings - 1) {
        $join .= $sep;
      }
    }
    
    return $join;
  }
  
  precompile sub lc : string($str : string) {
    
    unless ($str) { die "String must be defined"; }
    
    my $length = length $str;
    my $new_string = new byte [$length];
    for (my $i = 0; $i < $length; $i++) {
      my $char = $str->[$i];
      if ($char >= 'A' && $char <= 'Z') {
        $new_string->[$i] = (byte)($str->[$i] + 32);
      }
      else {
        $new_string->[$i] = $str->[$i];
      }
    }
    return (string)$new_string;
  }

  precompile sub lcfirst : string($str : string) {

    unless ($str) { die "String must be defined"; }
    
    my $length = length $str;
    my $new_string = new byte [$length];
    if ($length > 0) {
      my $char = $str->[0];
      if ($char >= 'A' && $char <= 'Z') {
        $new_string->[0] = (byte)($char + 32);
      }
      else {
        $new_string->[0] = $char;
      }
    }
    for (my $i = 1; $i < $length; ++$i) {
      $new_string->[$i] = $str->[$i];
    }
    return (string)$new_string;
  }

  native sub memcpyb : void ($dest_data : byte[], $dest_offset : int, $src_data : byte[], $src_offset : int, $length : int);
  native sub memcpys : void ($dest_data : short[], $dest_offset : int, $src_data : short[], $src_offset : int, $length : int);
  native sub memcpyi : void ($dest_data : int[], $dest_offset : int, $src_data : int[], $src_offset : int, $length : int);
  native sub memcpyl : void ($dest_data : long[], $dest_offset : int, $src_data : long[], $src_offset : int, $length : int);
  native sub memcpyf : void ($dest_data : float[], $dest_offset : int, $src_data : float[], $src_offset : int, $length : int);
  native sub memcpyd : void ($dest_data : double[], $dest_offset : int, $src_data : double[], $src_offset : int, $length : int);

  native sub memmoveb : void ($dest_data : byte[], $dest_offset : int, $src_data : byte[], $src_offset : int, $length : int);
  native sub memmoves : void ($dest_data : short[], $dest_offset : int, $src_data : short[], $src_offset : int, $length : int);
  native sub memmovei : void ($dest_data : int[], $dest_offset : int, $src_data : int[], $src_offset : int, $length : int);
  native sub memmovel : void ($dest_data : long[], $dest_offset : int, $src_data : long[], $src_offset : int, $length : int);
  native sub memmovef : void ($dest_data : float[], $dest_offset : int, $src_data : float[], $src_offset : int, $length : int);
  native sub memmoved : void ($dest_data : double[], $dest_offset : int, $src_data : double[], $src_offset : int, $length : int);

  native sub new_object_array_proto : oarray ($proto_array : oarray, $length : int);

  sub PI : double () { return 3.14159265358979323846; }

  precompile sub rand : int ($seed_ref : int&) {
    my $y = $$seed_ref;
    $y = $y ^ ($y << 13);
    $y = $y ^ ($y >>> 17);
    $y = $y ^ ($y << 5);
    return $y;
  }

  precompile sub random : double ($rand : int) {
    my $random = (double)((long)$rand & 0xFFFFFFFFL) / (UINT32_MAX() + 1);
    return $random;
  }
  
  precompile sub replace : string ($str : string, $substr : string, $replace : string, $start_offset : int, $found_offset_ref : int&) {
    unless ($substr && length $substr > 0) {
      die "Sub string must have length";
    }
    my $found_offset = index($str, $substr, $start_offset);
    $$found_offset_ref = $found_offset;
    if ($found_offset >= 0) {
      my $str_len = length $str;
      my $substr_len = length $substr;
      my $replace_len = length $replace;
      
      my $result_str_len = $str_len + $replace_len - $substr_len;
      my $result_str = new byte[$result_str_len];
      
      if ($found_offset > 0) {
        memmoveb((byte[])$result_str, 0, (byte[])$str, 0, $found_offset);
      }
      memmoveb((byte[])$result_str, $found_offset, (byte[])$replace, 0, $replace_len);
      
      my $str_rest_offset = $found_offset + $substr_len;
      my $str_rest_length = $str_len - $str_rest_offset;
      my $result_rest_offset = $found_offset + $replace_len;
      my $result_rest_length = $result_str_len - $result_rest_offset;
      memmoveb((byte[])$result_str, $result_rest_offset, (byte[])$str, $str_rest_offset, $str_rest_length);
      
      return $result_str;
    }
    else {
      my $copy_str = copy_str($str);
      return $copy_str;
    }
  }

  precompile sub replace_all : string ($str : string, $substr : string, $replace : string) {

    unless ($str) { die "String must be defined"; }
    
    my $offset = 0;
    my $found_offset : int;
    my $substr_len = length $substr;
    my $result_str = $str;
    while (1) {
      $result_str = replace($result_str, $substr, $replace, $offset, \$found_offset);
      if ($found_offset >= 0) {
        $offset = $found_offset + $substr_len;
      }
      else {
        return $result_str;
      }
    }
  }

  native sub strtoi : int ($string : string, $digit : int);
  native sub strtol : long ($string : string, $digit : int);
  native sub strtof : float ($string : string);
  native sub strtod : double ($string : string);
  
  precompile sub uc : string($str : string) {

    unless ($str) { die "String must be defined"; }
    
    my $length = length $str;
    my $new_string = new byte [$length];
    for (my $i = 0; $i < $length; $i++) {
      my $char = $str->[$i];
      if ($char >= 'a' && $char <= 'z') {
        $new_string->[$i] = (byte)($str->[$i] - 32);
      }
      else {
        $new_string->[$i] = $str->[$i];
      }
    }
    return (string)$new_string;
  }

  precompile sub ucfirst : string($str : string) {

    unless ($str) { die "String must be defined"; }
    
    my $length = length $str;
    my $new_string = new byte [$length];
    if ($length > 0) {
      my $char = $str->[0];
      if ($char >= 'a' && $char <= 'z') {
        $new_string->[0] = (byte)($char - 32);
      }
      else {
        $new_string->[0] = $char;
      }
    }
    for (my $i = 1; $i < $length; ++$i) {
      $new_string->[$i] = $str->[$i];
    }
    return (string)$new_string;
  }

  precompile sub rindex : int ($str : string, $substr : string, $offset : int) {
    my $str_len = length $str;
    my $substr_len = length $substr;
    if ($offset > $str_len - $substr_len) {
      $offset = $str_len - $substr_len;
    }
    for (my $i = $offset; $i >= 0; --$i) {
      my $match = 1;
      for (my $j = 0; $j < $substr_len; ++$j) {
        if ($str->[$i + $j] != $substr->[$j]) {
          $match = 0;
          last;
        }
      }
      if ($match) {
        return $i;
      }
    }
    return -1;
  }

  precompile sub contains : int ($str : string, $substr : string) {
    if (!$str) {
      die "Target string must be defined";
    }
    if (!$substr) {
      die "Search string must be defined";
    }

    my $pat_len = length $substr;
    my $str_len = length $str;
    my $i = 0;
    my $j = 0;
    
    while ($i < $str_len && $j < $pat_len) {
      if ($str->[$i] == $substr->[$j]) {
        $i++;
        $j++;
      } else {
        $i = $i - $j + 1;
        $j = 0;
      }
    }
    
    if ($j == $pat_len) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  native sub abs : int ($x : int);
  native sub labs : long ($x : long);
  
  native sub reverseb : void ($nums : byte[]);
  native sub reverses : void ($nums : short[]);
  native sub reversei : void ($nums : int[]);
  native sub reversel : void ($nums : long[]);
  native sub reversef : void ($nums : float[]);
  native sub reversed : void ($nums : double[]);
  native sub reverseo : void ($objs : oarray);

  precompile sub substr : string ($string : string, $offset : int, $length : int) {
    
    if ($string == undef) {
      die "String must be defined";
    }
    
    my $string_length = length $string;
    
    if ($offset < 0 || $offset > $string_length - 1) {
      die "Invalid offset $offset";
    }
    
    if ($length < 0) {
      die "Length must be non-zero value";
    }
    
    if ($offset + $length > $string_length) {
      die "Offset + length must not be over array length";
    }
    
    my $slice = new byte[$length];
    
    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $string->[$i];
      $pos++;
    }
    
    return (string)$slice;
  }

  precompile sub sliceb : byte[] ($nums : byte[], $offset : int, $length : int) {
    
    if ($nums == undef) {
      die "Array must be defined";
    }
    
    my $array_length = @$nums;
    
    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }
    
    if ($length < 0) {
      die "Length must be non-zero value";
    }
    
    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }
    
    my $slice = new byte[$length];
    
    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }
    
    return $slice;
  }

  precompile sub slices : short[] ($nums : short[], $offset : int, $length : int) {
    
    if ($nums == undef) {
      die "Array must be defined";
    }
    
    my $array_length = @$nums;
    
    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }
    
    if ($length < 0) {
      die "Length must be non-zero value";
    }
    
    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }
    
    my $slice = new short[$length];
    
    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }
    
    return $slice;
  }

  precompile sub slicei : int[] ($nums : int[], $offset : int, $length : int) {
    
    if ($nums == undef) {
      die "Array must be defined";
    }
    
    my $array_length = @$nums;
    
    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }
    
    if ($length < 0) {
      die "Length must be non-zero value";
    }
    
    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }
    
    my $slice = new int[$length];
    
    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }
    
    return $slice;
  }

  precompile sub slicel : long[] ($nums : long[], $offset : int, $length : int) {
    
    if ($nums == undef) {
      die "Array must be defined";
    }
    
    my $array_length = @$nums;
    
    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }
    
    if ($length < 0) {
      die "Length must be non-zero value";
    }
    
    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }
    
    my $slice = new long[$length];
    
    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }
    
    return $slice;
  }

  precompile sub slicef : float[] ($nums : float[], $offset : int, $length : int) {
    
    if ($nums == undef) {
      die "Array must be defined";
    }
    
    my $array_length = @$nums;
    
    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }
    
    if ($length < 0) {
      die "Length must be non-zero value";
    }
    
    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }
    
    my $slice = new float[$length];
    
    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }
    
    return $slice;
  }

  precompile sub sliced : double[] ($nums : double[], $offset : int, $length : int) {
    
    if ($nums == undef) {
      die "Array must be defined";
    }
    
    my $array_length = @$nums;
    
    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }
    
    if ($length < 0) {
      die "Length must be non-zero value";
    }
    
    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }
    
    my $slice = new double[$length];
    
    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }
    
    return $slice;
  }

  precompile sub sliceo : oarray ($elems : oarray, $offset : int, $length : int) {
    
    if ($elems == undef) {
      die "Array must be defined";
    }
    
    my $array_length = @$elems;
    
    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }
    
    if ($length < 0) {
      die "Length must be non-zero value";
    }
    
    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }
    
    my $slice = new_object_array_proto($elems, $length);
    
    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $elems->[$i];
      $pos++;
    }
    
    return $slice;
  }
  precompile sub copy_str : string ($string : string) {
    my $bytes = (byte[])$string;
    
    return (string)$bytes;
  }
  
}
