# SPVM::Matrix::QuatInt is created by regen/regen_matrix.pl
package SPVM::Matrix::QuatInt {
  use SPVM::StringBuffer;
  
  has values : ro SPVM::Quat_4i[];
  has row : ro int;
  has col : ro int;
  
  sub new : SPVM::Matrix::QuatInt ($values : SPVM::Quat_4i[], $row : int, $col : int) {
    unless ($values) {
      die "Values must defined";
    }

    unless ($row * $col == scalar @$values) {
      die "Values length must be row * col";
    }
    my $matrix = new SPVM::Matrix::QuatInt;
    $matrix->{values} = $values;
    $matrix->{row} = $row;
    $matrix->{col} = $col;
    return $matrix;
  }

  sub new_zero : SPVM::Matrix::QuatInt ($row : int, $col : int) {

    unless ($row > 0) {
      die "Row must be more than 0";
    }
    unless ($col > 0) {
      die "Col must be more than 0";
    }
    my $matrix = new SPVM::Matrix::QuatInt;
    my $length = $row * $col;
    $matrix->{values} = new  SPVM::Quat_4i[$length];
    $matrix->{row} = $row;
    $matrix->{col} = $col;
    return $matrix;
  }

  sub new_unit : SPVM::Matrix::QuatInt ($dim : int) {
    unless ($dim < 1) {
      die "Dimension must be more than 0";
    }
    
    my $matrix = SPVM::Matrix::QuatInt->new_zero($dim, $dim);
    my $values = $matrix->{values};
    for (my $i = 0; $i < $dim; $i++) {
      $values->[$i * $dim + $i] = 1;
    }

    return $matrix;
  }

  sub transpose : SPVM::Matrix::QuatInt ($self : self) {
    my $row = $self->{row};
    my $col = $self->{col};
    my $length = $row * $col;
    
    my $mat_trans = SPVM::Matrix::QuatInt->new(new SPVM::Quat_4i[$length], $col, $row);
    
    my $values = $self->{values};
    my $mat_trans_values = $mat_trans->{values};
    
    for (my $row_index = 0; $row_index < $row; $row_index++) {
      for (my $col_index = 0; $col_index < $col; $col_index++) {
        $mat_trans_values->[$row_index * $col + $col_index].t = $values->[$col_index * $row + $row_index].t;
        $mat_trans_values->[$row_index * $col + $col_index].x = $values->[$col_index * $row + $row_index].x;
        $mat_trans_values->[$row_index * $col + $col_index].y = $values->[$col_index * $row + $row_index].y;
        $mat_trans_values->[$row_index * $col + $col_index].z = $values->[$col_index * $row + $row_index].z;

      }
    }
    
    return $mat_trans;
  }
  
  sub str : string ($self : self) {
    my $values = $self->{values};
    my $row = $self->{row};
    my $col = $self->{col};
    my $length = $row * $col;
    
    my $buffer = SPVM::StringBuffer->new;
    for (my $row_index = 0; $row_index < $row; $row_index++) {
      for (my $elem_index = $row_index; $elem_index < $length; $elem_index += $row) {
        $buffer->push($values->[$elem_index]);
        if ($elem_index < $length - $col + 1) {
          $buffer->push(" ");
        }
      }
      $buffer->push("\n");
    }
    
    my $str = $buffer->to_string;
    
    return $str;
  }

  sub add : SPVM::Matrix::QuatInt ($self : self, $mat : SPVM::Matrix::QuatInt) {
    my $self_values = $self->{values};
    my $self_row = $self->{row};
    my $self_col = $self->{col};
    
    my $mat_row = $mat->{row};
    my $mat_col = $mat->{col};
    my $mat_values = $mat->{values};
    
    if ($self_row != $mat_row) {
      die "Self row must be equals to mat row";
    }

    if ($self_col != $mat_col) {
      die "Self col must be equals to mat col";
    }

    my $self_length = $self_row * $self_col;
    my $mat_result = SPVM::Matrix::QuatInt->new(new SPVM::Quat_4i[$self_length], $self_col, $self_row);
    my $mat_result_values = $mat_result->{values};
    
    for (my $i = 0; $i < $self_length; $i++) {
      $mat_result_values->[$i] = (SPVM::Quat_4i)($self_values->[$i] + $mat_values->[$i]);
    }
    
    return $mat_result;
  }

  sub sub : SPVM::Matrix::QuatInt ($self : self, $mat : SPVM::Matrix::QuatInt) {
    my $self_values = $self->{values};
    my $self_row = $self->{row};
    my $self_col = $self->{col};
    
    my $mat_row = $mat->{row};
    my $mat_col = $mat->{col};
    my $mat_values = $mat->{values};
    
    if ($self_row != $mat_row) {
      die "Self row must be equals to mat row";
    }

    if ($self_col != $mat_col) {
      die "Self col must be equals to mat col";
    }

    my $self_length = $self_row * $self_col;
    my $mat_result = SPVM::Matrix::QuatInt->new(new SPVM::Quat_4i[$self_length], $self_col, $self_row);
    my $mat_result_values = $mat_result->{values};
    
    for (my $i = 0; $i < $self_length; $i++) {
      $mat_result_values->[$i] = (SPVM::Quat_4i)($self_values->[$i] - $mat_values->[$i]);
    }
    
    return $mat_result;
  }

  sub scamul : SPVM::Matrix::QuatInt ($self : self, $scalar : SPVM::Quat_4i) {
    my $self_values = $self->{values};
    my $self_row = $self->{row};
    my $self_col = $self->{col};

    my $self_length = $self_row * $self_col;
    my $mat_result = SPVM::Matrix::QuatInt->new(new SPVM::Quat_4i[$self_length], $self_col, $self_row);
    my $mat_result_values = $mat_result->{values};
    
    for (my $i = 0; $i < $self_length; $i++) {
      $mat_result_values->[$i] = (SPVM::Quat_4i)($scalar * $self_values->[$i]);
    }
    
    return $mat_result;
  }

  sub mul : SPVM::Matrix::QuatInt ($self : self, $mat : SPVM::Matrix::QuatInt) {
    my $self_values = $self->{values};
    my $self_row = $self->{row};
    my $self_col = $self->{col};
    
    my $mat_row = $mat->{row};
    my $mat_col = $mat->{col};
    my $mat_values = $mat->{values};
    
    if ($self_col != $mat_row) {
      die "Self col must be equals to mat row";
    }

    my $self_length = $self_row * $self_col;
    my $mat_result = SPVM::Matrix::QuatInt->new(new SPVM::Quat_4i[$self_length], $self_row, $mat_row);
    my $mat_result_values = $mat_result->{values};
    my $mat_result_col = $mat_result->{col};
    my $mat_result_row = $mat_result->{row};
    
    for(my $i = 0; $i < $self_row; $i++) {
      for(my $j = 0; $j < $mat_col; $j++) {
        for(my $k = 0; $k < $self_col; $k++) {
          $mat_result_values->[$i * $mat_result_col + $j]  += + $self_values->[$i * $self_col + $k] * $mat_values->[$k * $mat_col + $j];
        }
      }
    }
    
    return $mat_result;
  }

}
