# SPVM::Matrix::Float is created by regen/regen_matrix.pl
package SPVM::Matrix::Float : public {
use SPVM::StringBuffer;

has values : public ro float[];
has rows_length : public ro int;
has columns_length : public ro int;

sub new : SPVM::Matrix::Float ($values : float[], $rows_length: int, $columns_length : int) {
  unless ($values) {
    die "Values must defined";
  }

  unless ($rows_length* $columns_length == scalar @$values) {
    die "Values length must be row * col";
  }
  my $matrix = new SPVM::Matrix::Float;
  $matrix->{values} = $values;
  $matrix->{rows_length} = $rows_length;
  $matrix->{columns_length} = $columns_length;
  return $matrix;
}

sub new_zero : SPVM::Matrix::Float ($rows_length: int, $columns_length : int) {

  unless ($rows_length> 0) {
    die "Row must be more than 0";
  }
  unless ($columns_length > 0) {
    die "Col must be more than 0";
  }
  my $matrix = new SPVM::Matrix::Float;
  my $length = $rows_length* $columns_length;
  $matrix->{values} = new  float[$length];
  $matrix->{rows_length} = $rows_length;
  $matrix->{columns_length} = $columns_length;
  return $matrix;
}

sub new_ident : SPVM::Matrix::Float ($dim : int) {
  if ($dim < 1) {
    die "Dimension must be more than 0";
  }
  
  my $matrix = SPVM::Matrix::Float->new_zero($dim, $dim);
  my $values = $matrix->{values};
  for (my $i = 0; $i < $dim; $i++) {
    $values->[$i * $dim + $i] = 1;
  }

  return $matrix;
}

sub transpose : SPVM::Matrix::Float ($self : self) {
  my $rows_length = $self->{rows_length};
  my $columns_length = $self->{columns_length};
  my $length = $rows_length * $columns_length;
  
  my $mat_trans = SPVM::Matrix::Float->new(new float[$length], $columns_length, $rows_length);
  
  my $values = $self->{values};
  my $mat_trans_values = $mat_trans->{values};
  
  for (my $row_index = 0; $row_index < $rows_length; $row_index++) {
    for (my $column_index = 0; $column_index < $columns_length; $column_index++) {
      $mat_trans_values->[$row_index * $columns_length + $column_index] = $values->[$column_index * $rows_length+ $row_index];

    }
  }
  
  return $mat_trans;
}

sub str : string ($self : self) {
  my $values = $self->{values};
  my $rows_length = $self->{rows_length};
  my $columns_length = $self->{columns_length};
  my $length = $rows_length * $columns_length;
  
  my $buffer = SPVM::StringBuffer->new;
  for (my $row_index = 0; $row_index < $rows_length; $row_index++) {
    for (my $elem_index = $row_index; $elem_index < $length; $elem_index += $rows_length) {
      $buffer->push($values->[$elem_index]);
      if ($elem_index < $length - $columns_length + 1) {
        $buffer->push(" ");
      }
    }
    $buffer->push("\n");
  }
  
  my $str = $buffer->to_string;
  
  return $str;
}

sub add : SPVM::Matrix::Float ($self : self, $mat : SPVM::Matrix::Float) {
  my $self_values = $self->{values};
  my $self_rows_length = $self->{rows_length};
  my $self_columns_length = $self->{columns_length};
  
  my $mat_rows_length = $mat->{rows_length};
  my $mat_columns_length = $mat->{columns_length};
  my $mat_values = $mat->{values};
  
  if ($self_rows_length != $mat_rows_length) {
    die "Self row must be equals to mat row";
  }

  if ($self_columns_length != $mat_columns_length) {
    die "Self col must be equals to mat col";
  }

  my $self_length = $self_rows_length * $self_columns_length;
  my $mat_result = SPVM::Matrix::Float->new(new float[$self_length], $self_rows_length, $self_columns_length);
  my $mat_result_values = $mat_result->{values};
  
  for (my $i = 0; $i < $self_length; $i++) {
    $mat_result_values->[$i] = (float)($self_values->[$i] + $mat_values->[$i]);
  }
  
  return $mat_result;
}

sub sub : SPVM::Matrix::Float ($self : self, $mat : SPVM::Matrix::Float) {
  my $self_values = $self->{values};
  my $self_rows_length = $self->{rows_length};
  my $self_columns_length = $self->{columns_length};
  
  my $mat_rows_length = $mat->{rows_length};
  my $mat_columns_length = $mat->{columns_length};
  my $mat_values = $mat->{values};
  
  if ($self_rows_length != $mat_rows_length) {
    die "Self row must be equals to mat row";
  }

  if ($self_columns_length != $mat_columns_length) {
    die "Self col must be equals to mat col";
  }

  my $self_length = $self_rows_length * $self_columns_length;
  my $mat_result = SPVM::Matrix::Float->new(new float[$self_length], $self_rows_length, $self_columns_length);
  my $mat_result_values = $mat_result->{values};
  
  for (my $i = 0; $i < $self_length; $i++) {
    $mat_result_values->[$i] = (float)($self_values->[$i] - $mat_values->[$i]);
  }
  
  return $mat_result;
}

sub scamul : SPVM::Matrix::Float ($self : self, $scalar : float) {
  my $self_values = $self->{values};
  my $self_rows_length = $self->{rows_length};
  my $self_columns_length = $self->{columns_length};

  my $self_length = $self_rows_length * $self_columns_length;
  my $mat_result = SPVM::Matrix::Float->new(new float[$self_length], $self_rows_length, $self_columns_length);
  my $mat_result_values = $mat_result->{values};
  
  for (my $i = 0; $i < $self_length; $i++) {
    $mat_result_values->[$i] = (float)($scalar * $self_values->[$i]);
  }
  
  return $mat_result;
}

sub mul : SPVM::Matrix::Float ($self : self, $mat : SPVM::Matrix::Float) {
  my $self_values = $self->{values};
  my $self_rows_length = $self->{rows_length};
  my $self_columns_length = $self->{columns_length};
  
  my $mat_rows_length = $mat->{rows_length};
  my $mat_columns_length = $mat->{columns_length};
  my $mat_values = $mat->{values};
  
  if ($self_columns_length != $mat_rows_length) {
    die "Self col must be equals to mat row";
  }

  my $mat_result_length = $self_rows_length * $mat_columns_length;
  my $mat_result = SPVM::Matrix::Float->new(new float[$mat_result_length], $self_rows_length, $mat_columns_length);
  my $mat_result_values = $mat_result->{values};
  my $mat_result_col = $mat_result->{columns_length};
  my $mat_result_row = $mat_result->{rows_length};
  
  for(my $row_index = 0; $row_index < $self_rows_length; $row_index++) {
    for(my $column_index = 0; $column_index < $mat_columns_length; $column_index++) {
      for(my $incol = 0; $incol < $self_columns_length; $incol++) {
        $mat_result_values->[$row_index + $column_index * $mat_result_row]
         += $self_values->[$row_index + $incol * $self_rows_length] * $mat_values->[$incol + $column_index * $mat_rows_length];
      }
    }
  }
  
  return $mat_result;
}
}
