package SPVM::Text {
  has string      : byte [];
  has capacity    : int;
  has length      : ro int;
  has is_utf8     : int;
  
  sub _reallocate_with_capacity : void ($self : self, $new_capacity : int) {
    my $new_string = new byte [$new_capacity];
    for (my $i = 0; $i < $self->{length}; ++$i) {
      $new_string->[$i] = $self->{string}[$i];
    }
    $self->{capacity} = $new_capacity;
    $self->{string} = $new_string;
  }

  sub to_string : string ($self : self) {
    return (string)sliceb($self->{string}, 0, $self->{length});
  }

  sub _capacity : int ($self : self) {
    return $self->{capacity};
  }

  sub _string : byte[] ($self : self) {
    return $self->{string};
  }

  sub new : SPVM::Text () {
    my $self = new SPVM::Text;
    my $default_capacity = 16;
    $self->{capacity} = $default_capacity;
    $self->{string} = new byte [$default_capacity];
    return $self;
  }

  sub new_with_capacity : SPVM::Text ($capacity : int) {
    my $self = new SPVM::Text;
    unless ($capacity > 0) {
      croak "capacity must be positive";
    }
    $self->{capacity} = $capacity;
    $self->{string} = new byte [$capacity];
    return $self;
  }

  sub new_with_string : SPVM::Text ($string : string) {
    my $self = new SPVM::Text;
    $self->{capacity} = length($string);
    $self->{string} = (byte [])$string;
    $self->{length} = $self->{capacity};
    return $self;
  }

  sub substr : SPVM::Text ($self : self, $offset : int, $length : int) {
    if ($offset >= $self->{length}) {
      croak("substr offset is greater or equal than string length");
      return SPVM::Text->new;
    }
    
    my $string = $self->{string};
    
    my $new_capacity = $length;
    
    my $new_text = SPVM::Text->new_with_capacity($new_capacity);
    
    for (my $i = 0; $i < $length; $i++) {
      $new_text->{string}[$i] = $self->{string}[$offset + $i];
    }
    $new_text->{length} = $length;
    
    return $new_text;
  }

  sub copy : SPVM::Text ($self : self) {
    my $ret = SPVM::Text->new;
    $ret->{string}      = $self->{string};
    $ret->{capacity}    = $self->{capacity};
    $ret->{length}      = $self->{length};
    $ret->{is_utf8} = $self->{is_utf8};
    return $ret;
  }

  # O($self->{length} + $text)
  sub prepend : void ($self : self, $text : SPVM::Text) {
    my $rc = $self->{string};
    if (refcnt $rc > 2) {
      # copy-on-write
      my $new_string = new byte [$self->{length}];
      for (my $i = 0; $i < $self->{length}; ++$i) {
        $new_string->[$i] = $self->{string}[$i];
      }
      $self->{string} = $new_string;
    }
    
    # TODO: Think how to deal with capacity.
    my $capacity = $self->{capacity}; # capacity is not shrunk.
    if ($capacity < $self->{length} + $text->{length}) { # don't consider about x2 allocation.
      $capacity = $self->{length} + $text->{length};
    }
    my $new_string = new byte [$capacity];
    for (my $i = 0; $i < $text->{length}; ++$i) {
      $new_string->[$i] = $text->_string->[$i];
    }
    for (my $i = 0; $i < $self->{length}; ++$i) {
      $new_string->[$text->{length} + $i] = $self->{string}[$i];
    }
    $self->{string} = $new_string;
    $self->{capacity} = $capacity;
    $self->{length} += $text->{length};
  }

  sub append : void ($self : self, $text : SPVM::Text) {
    if ($self->{length} + $text->{length} > $self->{capacity}) {
      # O($new_capacity)
      my $new_capacity : int;
      if ($self->{length} + $text->{length} > $self->{capacity} * 2) {
        $new_capacity = $self->{length} + $text->{length};
      } else {
        $new_capacity = $self->{capacity} * 2;
      }
      $self->_reallocate_with_capacity($new_capacity);
      for (my $i = 0; $i < $text->{length}; ++$i) {
        $self->{string}[$self->{length} + $i] = $text->_string->[$i];
      }
      $self->{length} += $text->{length};
    }
    else {
      # O($text)
      my $rc = $self->{string};
      if (refcnt $rc > 2) {
        # copy-on-write
        my $new_string = new byte [$self->{length}];
        for (my $i = 0; $i < $self->{length}; ++$i) {
          $new_string->[$i] = $self->{string}[$i];
        }
        $self->{string} = $new_string;
      }
      
      for (my $i = 0; $i < $text->{length}; ++$i) {
        $self->{string}[$self->{length} + $i] = $text->_string->[$i];
      }
      $self->{length} += $text->{length};
    }
  }

  # O($self->{capacity})
  sub replace : void ($self : self, $offset : int, $length : int, $replace : string) {
    if ($offset > $self->{length}) {
      warn("replace offset past end of string");
      $offset = $self->{length};
      $length = 0;
    }

    if ($length > $self->{length} - $offset) {
      $length = $self->{length} - $offset;
    }

    my $replace_length = 0;
    if ($replace) {
      $replace_length = length($replace);
    }

    my $rc = $self->{string};
    if (refcnt $rc > 2) {
      # copy-on-write
      my $new_string = new byte [$self->{length}];
      for (my $i = 0; $i < $self->{length}; ++$i) {
        $new_string->[$i] = $self->{string}[$i];
      }
      $self->{string} = $new_string;
    }

    if ($self->{length} - $length + $replace_length > $self->{capacity}) {
      # O($new_string_length)
      $self->_reallocate_with_capacity($self->{length} - $length + $replace_length);
    }

    my $last_sequence_length = $self->{length} - $offset - $length;
    if ($length > $replace_length) {
      # move last sequence to forward
      for (my $i = 0; $i < $last_sequence_length; ++$i) {
        my $origin = $offset + $length + $i;
        my $target = $offset + $replace_length + $i;
        $self->{string}[$target] = $self->{string}[$origin];
      }
    }
    else {
      # move last sequence to backward
      for (my $i = 0; $i < $last_sequence_length; ++$i) {
        my $origin = $self->{length} - 1 - $i;
        my $target = $offset + $replace_length + $last_sequence_length - 1 - $i;
        $self->{string}[$target] = $self->{string}[$origin];
      }
    }

    # replace with new array
    for (my $i = 0; $i < $replace_length; ++$i) {
      my $target = $offset + $i;
      $self->{string}[$target] = $replace->[$i];
    }

    $self->{length} += $replace_length - $length;
  }

  sub equals : int ($self : self, $text : SPVM::Text) {
    unless ($self->{length} == $text->{length}) {
      return 0;
    }
    for (my $i = 0; $i < $self->{length}; ++$i) {
      unless ($self->{string}[$i] == $text->_string->[$i]) {
        return 0;
      }
    }
    return 1;
  }
}
