package SPVM::HTTP::Client {
  use SPVM::HTTP::Client::Handle;
  use SPVM::HTTP::Client::Request;
  use SPVM::HTTP::Headers;
  use SPVM::HTTP::URL;

  has default_headers : public SPVM::HTTP::Headers;
  has timeout : public double;

  sub new : SPVM::HTTP::Client () {
    my $self = new SPVM::HTTP::Client;
    $self->{default_headers} = SPVM::HTTP::Headers->new;
    $self->{timeout} = 60;
    return $self;
  }

  sub new_with : SPVM::HTTP::Client ($args : SPVM::Hash) {
    my $self = new SPVM::HTTP::Client;
    $self->{default_headers} = SPVM::HTTP::Headers->new;
    $self->{timeout} = 60;
    return $self;
  }

  private sub _prepare_headers : void ($self : self,
      $request : SPVM::HTTP::Client::Request) {
    $request->{headers} = $self->{default_headers};
    $request->{headers}->add("Host", $request->host_port);
  }

  private sub _open_handle : SPVM::HTTP::Client::Handle ($self : self,
      $host : string, $port : int) {
    my $handle = SPVM::HTTP::Client::Handle->new_with(hash([(object)
      timeout => $self->{timeout},
    ]));
    return $handle->connect(hash([(object)
      host => $host,
      port => $port,
    ]));
  }

  sub request : void ($self : self, $method : string,
      $url : string, $args : SPVM::Hash) {

    my $u = SPVM::HTTP::URL->parse($url);
    $u->force_root_path_slashed;

    my $request = SPVM::HTTP::Client::Request->new_with(hash([(object)
      method  => $method,
      scheme  => $u->{scheme},
      host    => $u->{host},
      port    => $u->{port},
      path    => $u->{path},
      query   => $u->{params},
    ]));

    $self->_prepare_headers($request);

    my $handle = $self->_open_handle($request->{host}, $request->{port});
    $handle->write_request($request);

    my $response = $handle->read_response_header;
    my $known_message_length = $handle->read_body($response);
  }
}

package SPVM::HTTP::Client::Handle {
  use SPVM::HTTP::Client::Request;
  use SPVM::HTTP::Client::Response;
  use SPVM::HTTP::Client::Handle::SocketWrapper;
  use SPVM::HTTP::Headers;
  use SPVM::StringBuffer;

  has timeout : public double;
  has socket : public SPVM::IO::Socket;

  sub new_with : SPVM::HTTP::Client::Handle ($args : SPVM::Hash) {
    my $self = new SPVM::HTTP::Client::Handle;
    if (my $o = $args->get("timeout")) {
      $self->{timeout} = ((SPVM::Double)$o)->val;
    }
    return $self;
  }

  sub connect : SPVM::HTTP::Client::Handle ($self : self, $args : SPVM::Hash) {
    unless ($args->exists("host")) {
      die "Missing argument 'host'.";
    }
    my $host = (string)($args->get("host"));

    unless ($args->exists("port")) {
      die "Missing argument 'port'.";
    }
    my $port = ((SPVM::Int)($args->get("port")))->val;

    $self->{socket} = SPVM::IO::Socket->new($host, $port);

    return $self;
  }

  sub write : void ($self : self, $buf : SPVM::StringBuffer) {
    my $len = $buf->length;
    my $off = 0;
    while (1) {
      my $writable = $buf->substr($off, $len)->to_str;
      my $write_length = $self->{socket}->write($writable, $len);
      $len -= $write_length;
      $off += $write_length;
      unless ($len > 0) {
        last;
      }
    }
  }

  sub write_header_lines : void ($self : self,
      $headers : SPVM::HTTP::Headers, $prefix_data : string) {
    my $buf = SPVM::StringBuffer->new;
    if ($prefix_data) {
      $buf->append_string($prefix_data);
    }
    $headers->append_to_buffer($buf);
    $buf->append_string("\r\n");
    $self->write($buf);
  }

  sub write_request_header : void ($self : self, $method : string,
      $path_query : string, $headers : SPVM::HTTP::Headers) {
    $self->write_header_lines($headers, "$method $path_query\r\n");
  }

  sub write_request : void ($self : self,
      $request : SPVM::HTTP::Client::Request) {
    $self->write_request_header(
        $request->{method}, $request->path_query, $request->{headers});
    #$self->_write_body();
  }

  sub read_response_header : SPVM::HTTP::Client::Response ($self : self) {
    return undef;
  }

  sub read_body : int ($self : self, $response : SPVM::HTTP::Client::Response) {
    return 0;
  }
}
