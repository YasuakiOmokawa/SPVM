package SPVM::HTTP::Client {
  use SPVM::HTTP::Client::Handle;
  use SPVM::HTTP::Client::Request;
  use SPVM::HTTP::Headers;
  use SPVM::HTTP::URL;

  has default_headers : public SPVM::HTTP::Headers;
  has timeout : public double;

  sub new : SPVM::HTTP::Client () {
    my $self = new SPVM::HTTP::Client;
    $self->{default_headers} = SPVM::HTTP::Headers->new;
    $self->{timeout} = 60;
    return $self;
  }

  sub new_with : SPVM::HTTP::Client ($args : SPVM::Hash) {
    my $self = new SPVM::HTTP::Client;
    $self->{default_headers} = SPVM::HTTP::Headers->new;
    $self->{timeout} = 60;
    return $self;
  }

  private sub _prepare_headers : void ($self : self,
      $request : SPVM::HTTP::Client::Request) {
    $request->{headers} = $self->{default_headers};
    $request->{headers}->add("Host", $request->host_port);
  }

  private sub _open_handle : SPVM::HTTP::Client::Handle ($self : self,
      $host : string, $port : int) {
    my $handle = SPVM::HTTP::Client::Handle->new_with(hash([(object)
      timeout => $self->{timeout},
    ]));
    return $handle->connect(hash([(object)
      host => $host,
      port => $port,
    ]));
  }

  sub request : void ($self : self, $method : string,
      $url : string, $args : SPVM::Hash) {

    my $u = SPVM::HTTP::URL->parse($url);
    $u->force_root_path_slashed;

    my $request = SPVM::HTTP::Client::Request->new_with(hash([(object)
      method  => $method,
      scheme  => $u->{scheme},
      host    => $u->{host},
      port    => $u->{port},
      path    => $u->{path},
      query   => $u->{params},
    ]));

    $self->_prepare_headers($request);

    my $handle = $self->_open_handle($request->{host}, $request->{port});
    $handle->write_request($request);

    my $response = $handle->read_response_header;
    warn("$method - $url");
    warn("parsed status line:");
    warn("protocol: " . $response->protocol);
    warn("status: " . $response->status);
    warn("reason: " . $response->reason);
    #my $known_message_length = $handle->read_body($response);
  }
}

package SPVM::HTTP::Client::Handle {
  use SPVM::HTTP::Client::Request;
  use SPVM::HTTP::Client::Response;
  use SPVM::HTTP::Headers;
  use SPVM::IO::Socket;
  use SPVM::StringBuffer;

  has timeout : public double;
  has socket : public SPVM::IO::Socket;
  has rbuf : SPVM::StringBuffer;

  our $_BUFSIZE : rw int;

  BEGIN {
    $_BUFSIZE = 32768;
  }

  sub new_with : SPVM::HTTP::Client::Handle ($args : SPVM::Hash) {
    my $self = new SPVM::HTTP::Client::Handle;
    if (my $o = $args->get("timeout")) {
      $self->{timeout} = ((SPVM::Double)$o)->val;
    }
    $self->{rbuf} = SPVM::StringBuffer->new;
    return $self;
  }

  sub connect : SPVM::HTTP::Client::Handle ($self : self, $args : SPVM::Hash) {
    unless ($args->exists("host")) {
      die "Missing argument 'host'.";
    }
    my $host = (string)($args->get("host"));
    unless ($args->exists("port")) {
      die "Missing argument 'port'.";
    }
    my $port = ((SPVM::Int)($args->get("port")))->val;
    $self->{socket} = SPVM::IO::Socket->new($host, $port);
    $self->{rbuf} = SPVM::StringBuffer->new;
    return $self;
  }

  sub write : void ($self : self, $buf : SPVM::StringBuffer) {
    my $len = $buf->length;
    my $off = 0;
    while (1) {
      my $writable = $buf->substr($off, $len)->to_str;
      my $write_length = $self->{socket}->write($writable, $len);
      $len -= $write_length;
      $off += $write_length;
      unless ($len > 0) {
        last;
      }
    }
  }

  sub write_header_lines : void ($self : self,
      $headers : SPVM::HTTP::Headers, $prefix_data : string) {
    my $buf = SPVM::StringBuffer->new;
    if ($prefix_data) {
      $buf->append_string($prefix_data);
    }
    $headers->append_to_buffer($buf);
    $buf->append_string("\r\n");
    $self->write($buf);
  }

  sub write_request_header : void ($self : self, $method : string,
      $path_query : string, $headers : SPVM::HTTP::Headers) {
    $self->write_header_lines($headers, "$method $path_query\r\n");
  }

  sub write_request : void ($self : self,
      $request : SPVM::HTTP::Client::Request) {
    $self->write_request_header(
        $request->{method}, $request->path_query, $request->{headers});
    #$self->_write_body();
  }

  private sub _extract_line : string ($self : self) {
    my $index = $self->{rbuf}->index("\n", 0);
    if ($index < 0) {
      return undef;
    }
    my $ret = $self->{rbuf}->substr(0, $index + 1)->to_str;
    $self->{rbuf} = $self->{rbuf}->substr(
        $index + 1, $self->{rbuf}->length - $index - 1);
    return $ret;
  }

  sub readline : string ($self : self) {
    while (1) {
      if (my $line = $self->_extract_line) {
        return $line;
      }
      my $buf = new byte [$_BUFSIZE];
      my $r = $self->{socket}->read($buf);
      if ($r > 0) {
        $self->{rbuf}->append_bytes(sliceb($buf, 0, $r));
      }
      elsif ($r == 0) {
        die "Unexpected end of stream while looking for line";
      }
    }
    return $self->{rbuf}->to_str;
  }

  private sub _read_as : void ($target : string, $token : string, $pos : int&) {
    unless (index($target, $token, $$pos) == 0) {
      die "Malformed string. '$token' is expected: '$target'";
    }
    $$pos += length $token;
  }

  private sub _read_as_ws : void ($target : string, $pos : int&) {
    unless ($target->[$$pos] == ' ' || $target->[$$pos] == '\t') {
      die "Malformed string. No white spaces: '$target'";
    }
    my $len = length $target;
    for (; $$pos < $len &&
        $target->[$$pos] == ' ' ||
        $target->[$$pos] == '\t';
        ++$$pos) {}
  }

  private sub _capture : string ($target : string, $length : int, $pos : int&) {
    my $ret = "";
    eval {
      $ret = substr($target, $$pos, $length);
    };
    if ($@) {
      die "Malformed string, parse failed at " . $$pos . ". string: '$target'";
    }
    $$pos += $length;
    return $ret;
  }

  private sub _as_digits : int ($string : string) {
    my $length = length $string;
    my $ret = 0;
    for (my $i = 0; $i < $length; ++$i) {
      $ret *= 10;
      $ret += $string->[$i] - '0';
    }
    return $ret;
  }

  sub read_header_lines : SPVM::Hash ($self : self) {
    return undef;
  }

  sub read_response_header : SPVM::HTTP::Client::Response ($self : self) {
    my $line = $self->readline;
    my $pos = 0;
    _read_as($line, "HTTP/", \$pos);
    my $version = _capture($line, 3, \$pos);
    unless ($version eq "1.0" || $version eq "1.1") {
      die "Unsupported HTTP protocol HTTP/$version";
    }
    _read_as_ws($line, \$pos);
    my $status = _capture($line, 3, \$pos);
    _read_as_ws($line, \$pos);
    my $reason = substr($line, $pos, length($line) - $pos - 2);
    return SPVM::HTTP::Client::Response->new_with(hash([(object)
      protocol => "HTTP/$version",
      status   => _as_digits($status),
      reason   => $reason,
      headers  => $self->read_header_lines,
    ]));
  }

  sub read_body : int ($self : self, $response : SPVM::HTTP::Client::Response) {
    return 0;
  }
}
