package SPVM::HTTP::URL::Parameters {
  use SPVM::Hash;
  use SPVM::HTTP::URL::Escape;

  has params : SPVM::Hash;

  sub new : SPVM::HTTP::URL::Parameters () {
    my $self = new SPVM::HTTP::URL::Parameters;
    $self->{params} = SPVM::Hash->new;
    return $self;
  }

  sub add : void ($self : self, $key : string, $value : string) {
    unless ($self->{params}->exists($key)) {
      $self->{params}->set($key, $value);
    }
  }

  sub get : string ($self : self, $key : string) {
    if ($self->{params}->exists($key)) {
      return (string)($self->{params}->get($key));
    } else {
      return undef;
    }
  }

  sub keys : string[] ($self : self) {
    return $self->{params}->keys;
  }

  sub parse : SPVM::HTTP::URL::Parameters ($str : string) {
    my $self = SPVM::HTTP::URL::Parameters->new;
    my $length = length($str);
    my $start_token = 0;
    for (my $i = 0; $i < $length; ++$i) {
      if ($str->[$i] == '=') {
        my $start_val = $i + 1;
        my $end_val = -1;
        for (my $j = $start_val; $j < $length; ++$j) {
          if ($str->[$j] == '&') {
            $end_val = $j;
            last;
          }
        }
        if ($end_val < 0) {
          $end_val = $length;
        }
        my $key = sliceb((byte [])$str, $start_token, $i - $start_token);
        my $val = SPVM::HTTP::URL::Escape->unescape(
            sliceb((byte [])$str, $start_val, $end_val - $start_val));
        $self->add($key, $val);
        $start_token = $end_val + 1; # if $end_val < $length
        $i = $end_val;
      }
    }
    return $self;
  }

  sub escape : string ($self : self) {
    my $keys = $self->{params}->keys();
    unless (@$keys) {
      return "";
    }
    sorto($keys, sub : int ($self : self, $left : object, $right : object) {
      if ((string)$left gt (string)$right) {
        return 1;
      }
      return 0;
    });
    my $result = "";
    for (my $i = 0; $i < @$keys; ++$i) {
      if ($i > 0) {
        $result .= "&";
      }
      $result .= $keys->[$i] . "=" .
        SPVM::HTTP::URL::Escape->escape($self->get($keys->[$i]));
    }
    return $result;
  }
}
