package SPVM::JSON {
  use SPVM::JSON::Bool;
  use SPVM::Hash;
  use SPVM::ObjectList;
  use SPVM::Int;
  use SPVM::Long;
  use SPVM::Double;
  use SPVM::Math;
  use SPVM::Sort (sortstr);
  use SPVM::StringBuffer;
  
  has canonical : rw byte;
  
  private enum {
    NUM_DEFAULT,
    NUM_ALLOW_LONG,
  }
  
  private enum {
    DBL_DIG = 15,
    LDBL_DIG = 18
  }

  precompile private sub _custom_die : void ($die_message : string, $json_str : string, $start : int, $end : int) {
    my $max_dump_length = 10;
    if ($max_dump_length > $end - $start) {
      $max_dump_length = $end - $start;
    }
    my $hint = "";
    if ($max_dump_length > 0) {
      $hint = "near '" . substr($json_str, $start, $end - $start) . "'";
    }
    else {
      $hint = "end of string";
    }
    die $die_message . " ... $hint";
  }

  precompile private sub _skip_spaces : void ($self : self, $json_str : string, $iter : int&, $end : int) {
    for (; 1 ; ++$$iter) {
      if ($$iter == $end) {
        return;
      }
      unless ($json_str->[$$iter] == ' ' || $json_str->[$$iter] == '\n' || $json_str->[$$iter] == '\t' || $json_str->[$$iter] == '\r') {
        last;
      }
    }
  }

  precompile private sub _expect_token : void ($json_str : string, $iter : int&, $end : int, $expected : string) {
    my $length = length $expected;
    unless ($$iter + $length <= $end) {
      _custom_die("Expected token: $expected doesn't exist", $json_str, $$iter, $end);
    }
    my $begin = $$iter;
    while (1) {
      unless ($json_str->[$$iter] == $expected->[$$iter - $begin]) {
        _custom_die("Expected token: $expected doesn't exist", $json_str, $$iter, $end);
      }
      ++$$iter;
      if ($$iter - $begin == $length) {
        last;
      }
    }
  }

  precompile private sub _decode_string : string ($self : self, $json_str : string, $iter : int&, $end : int) {
    my $chars = SPVM::ObjectList->new;
    _expect_token($json_str, $iter, $end, "\"");
    my $special_char_expected = 0;
    while (1) {
      if ($$iter >= $end || (!$special_char_expected && $json_str->[$$iter] == '"')) {
        last;
      }
      my $got_char = $json_str->[$$iter];
      if ($special_char_expected) {
        switch ((int)$got_char) {
          case 34: # '"'
          case 92: # '\\'
          {
            $chars->push(SPVM::Int->new($got_char));
            break;
          }
          case 116: { # 't'
            $chars->push(SPVM::Int->new('\t'));
            break;
          }
          case 110: { # 'n'
            $chars->push(SPVM::Int->new('\n'));
            break;
          }
          case 114: { # 'r'
            $chars->push(SPVM::Int->new('\r'));
            break;
          }
          default: {
            _custom_die("Undefined special char", $json_str, $$iter, $end);
          }
        }
        $special_char_expected = 0;
      }
      elsif ($got_char == '\\') {
        $special_char_expected = 1;
      }
      else {
        if ($got_char == '\t') {
          _custom_die("Literal ASCII tab characters are not allowed in string", $json_str, $$iter, $end);
        }
        $chars->push(SPVM::Int->new($got_char));
      }
      ++$$iter;
    }
    if ($$iter == $end) {
      _custom_die("Invalid string. end-quote doesn't exist", $json_str, $$iter, $end);
    }
    _expect_token($json_str, $iter, $end, "\"");
    my $chars_length = $chars->length;
    my $value = new byte [$chars_length];
    for (my $k = 0; $k < $chars_length; ++$k) {
      my $got = ((SPVM::Int)$chars->shift)->val;
      $value->[$k] = (byte)$got;
    }
    return (string)$value;
  }

  precompile private sub _atof_scan1 : double ($json_str : string, $iter : int, $end : int,
      $accum : double&, $expo : int&, $postdp : int, $maxdepth : int) {
    my $long_accum : long = 0;
    my $expo_accum = 0;

    # if we recurse too deep, skip all remaining digits
    # to avoid a stack overflow attack
    if (--$maxdepth <= 0) {
      while ($iter < $end && ($json_str->[$iter] - '0') < 10) {
        ++$iter;
      }
    }

    while ($iter < $end) {
      if ($json_str->[$iter] == '.') {
        ++$iter;
        _atof_scan1($json_str, $iter, $end, $accum, $expo, 1, $maxdepth);
        last;
      }
      elsif ($json_str->[$iter] == 'e' || $json_str->[$iter] == 'E') {
        my $exp2 = 0;
        my $neg = 0;

        ++$iter;

        if ($iter >= $end) {
          _custom_die ("malformed number (no digits after e/E)", $json_str, $iter, $end);
        }

        if ($json_str->[$iter] == '-') {
          ++$iter;
          $neg = 1;
        }
        elsif ($json_str->[$iter] == '+') {
          ++$iter;
        }

        if ($iter >= $end) {
          _custom_die ("malformed number (no digits after e/E)", $json_str, $iter, $end);
        }

        while ($iter < $end) {
          my $dig = $json_str->[$iter] - '0';
          if ($dig < 10) {
            $exp2 = $exp2 * 10 + $json_str->[$iter++] - '0';
          }
          else {
            last;
          }
        }

        if ($neg) {
          $$expo -= $exp2;
        }
        else {
          $$expo += $exp2;
        }
        last;
      }
      elsif ($json_str->[$iter] >= '0' && $json_str->[$iter] <= '9') {
        my $dig = $json_str->[$iter] - '0';

        ++$iter;

        $long_accum = $long_accum * 10 + $dig;
        ++$expo_accum;

        # if we have too many digits, then recurse for more
        # we actually do this for rather few digits
        if ($long_accum >= (INT64_MAX() - 9) / 10) {
          if ($postdp) {
            $$expo -= $expo_accum;
          }
          _atof_scan1($json_str, $iter, $end, $accum, $expo, $postdp, $maxdepth);
          if ($postdp) {
            $$expo += $expo_accum;
          }
          last;
        }
      }
      else {
        last;
      }
    }

    if ($postdp) {
      $$expo -= $expo_accum;
    }

    $$accum += $long_accum * SPVM::Math->pow(10, $$expo);
    $$expo += $expo_accum;
  }

  precompile private sub _atof : double ($json_str : string, $start : int, $end : int) {
    my $accum = 0.0;
    my $expo = 0;
    my $neg = 0;

    if ($json_str->[$start] == '-') {
      ++$start;
      $neg = 1;
    }

    # a recursion depth of ten gives us >>500 bits
    _atof_scan1($json_str, $start, $end, \$accum, \$expo, 0, 10);

    if ($neg) {
      return -$accum;
    }
    else {
      return $accum;
    }
  }

  precompile private sub _grok_non_neg : int ($json_str : string, $start : int, $len : int, $val : long&) {
    my $number_type = 0;
    $$val = 0;
    for (my $digit_index = 0; $digit_index < $len; ++$digit_index) {
      if ($$val <= (long)INT32_MAX()) {
        $$val = $$val * 10 + $json_str->[$start + $digit_index] - '0';
      }
      elsif ($$val < INT64_MAX() / 10 ||
          ($$val == INT64_MAX() / 10 && $json_str->[$start + $digit_index] - '0' <= INT64_MAX() % 10)) {
        $number_type = 1;
        $$val = $$val * 10 + $json_str->[$start + $digit_index] - '0';
      }
      else {
        return -1;
      }
    }
    return $number_type;
  }

  precompile private sub _grok_neg : int ($json_str : string, $start : int, $len : int, $val : long&) {
    my $number_type = 0;
    $$val = 0;
    for (my $digit_index = 0; $digit_index < $len; ++$digit_index) {
      if ($$val >= (long)INT32_MIN()) {
        $$val = $$val * 10 - ($json_str->[$start + $digit_index] - '0');
      }
      elsif ($$val > INT64_MIN() / 10 ||
          ($$val == INT64_MIN() / 10 &&
              $json_str->[$start + $digit_index] - '0' <= -(INT64_MIN() + INT64_MIN() / 10 * 10))) {
        $number_type = 1;
        $$val = $$val * 10 - ($json_str->[$start + $digit_index] - '0');
      }
      else {
        return -1;
      }
    }
    return $number_type;
  }

  # https://metacpan.org/pod/Cpanel::JSON::XS#number
  precompile private sub _decode_num : object ($self : self, $json_str : string, $iter : int&, $end : int) {
    if ($json_str->[$$iter] == 'n') {
      if ($$iter + 2 < $end && substr($json_str, $$iter, 3) eq "nan") {
        $$iter += 3;
      }
      elsif ($$iter + 3 < $end && substr($json_str, $$iter, 4) eq "null") {
        $$iter += 4;
      }
      else {
        _custom_die("malformed number.", $json_str, $$iter, $end);
      }
      return undef;
    }

    my $is_double = 0;
    my $start = $$iter;

    # minus
    if ($json_str->[$$iter] == '-') {
      ++$$iter;
    }

    if ($json_str->[$$iter] == 'i') {
      if ($$iter + 2 < $end && substr($json_str, $$iter, 3) eq "inf") {
        $$iter += 3;
      }
      else {
        _custom_die("malformed number.", $json_str, $$iter, $end);
      }
      return undef;
    }

    if ($json_str->[$$iter] == '0') {
      ++$$iter;
      if ($$iter < $end && ($json_str->[$$iter] >= '0' && $json_str->[$$iter] <= '9')) {
        _custom_die("malformed number (leading zero must not be followed by another digit)", $json_str, $$iter, $end);
      }
    }
    elsif ($$iter >= $end || $json_str->[$$iter] < '0' || $json_str->[$$iter] > '9') {
      _custom_die ("malformed number (no digits after initial minus)", $json_str, $$iter, $end);
    }

    while ($$iter < $end && $json_str->[$$iter] >= '0' && $json_str->[$$iter] <= '9') {
      ++$$iter;
    }

    # frac
    if ($$iter < $end && $json_str->[$$iter] == '.') {
      ++$$iter;
      if ($$iter >= $end || $json_str->[$$iter] < '0' || $json_str->[$$iter] > '9') {
        _custom_die ("malformed number (no digits after decimal point)", $json_str, $$iter, $end);
      }
      while ($$iter < $end && $json_str->[$$iter] >= '0' && $json_str->[$$iter] <= '9') {
        ++$$iter;
      }

      $is_double = 1;
    }

    # exp
    if ($$iter < $end && ($json_str->[$$iter] == 'e' || $json_str->[$$iter] == 'E')) {
      ++$$iter;

      if ($$iter < $end && ($json_str->[$$iter] == '-' || $json_str->[$$iter] == '+')) {
        ++$$iter;
      }

      if ($$iter >= $end || $json_str->[$$iter] < '0' || $json_str->[$$iter] > '9') {
        _custom_die ("malformed number (no digits after exp sign)", $json_str, $$iter, $end);
      }

      while ($$iter < $end && ($json_str->[$$iter] >= '0' && $json_str->[$$iter] <= '9')) {
        ++$$iter;
      }

      $is_double = 1;
    }

    if (!$is_double) {
      my $len = $$iter - $start;

      if ($json_str->[$start] == '-') {
        switch ($len) {
          case 2: {
            return -(                                                                                                      $json_str->[$start + 1] - '0' *     1);
            break;
          }
          case 3: {
            return -(                                                                              $json_str->[$start + 1] * 10 + $json_str->[$start + 2] - '0' *    11);
            break;
          }
          case 4: {
            return -(                                                     $json_str->[$start + 1] * 100 + $json_str->[$start + 2] * 10 + $json_str->[$start + 3] - '0' *   111);
            break;
          }
          case 5: {
            return -(                           $json_str->[$start + 1] * 1000 + $json_str->[$start + 2] * 100 + $json_str->[$start + 3] * 10 + $json_str->[$start + 4] - '0' *  1111);
            break;
          }
          case 6: {
            return -($json_str->[$start + 1] * 10000 + $json_str->[$start + 2] * 1000 + $json_str->[$start + 3] * 100 + $json_str->[$start + 4] * 10 + $json_str->[$start + 5] - '0' * 11111);
            break;
          }
        }
      }
      else {
        switch ($len) {
          case 1: {
            return (                                                                                                           $json_str->[$start] - '0' *     1);
            break;
          }
          case 2: {
            return (                                                                                   $json_str->[$start] * 10 + $json_str->[$start + 1] - '0' *    11);
            break;
          }
          case 3: {
            return (                                                          $json_str->[$start] * 100 + $json_str->[$start + 1] * 10 + $json_str->[$start + 2] - '0' *   111);
            break;
          }
          case 4: {
            return (                                $json_str->[$start] * 1000 + $json_str->[$start + 1] * 100 + $json_str->[$start + 2] * 10 + $json_str->[$start + 3] - '0' *  1111);
            break;
          }
          case 5: {
            return (     $json_str->[$start] * 10000 + $json_str->[$start + 1] * 1000 + $json_str->[$start + 2] * 100 + $json_str->[$start + 3] * 10 + $json_str->[$start + 4] - '0' * 11111);
            break;
          }
        }
      }

      my $val : long;
      my $number_type = 0;

      if ($json_str->[$start] == '-') {
        $number_type = _grok_neg($json_str, $start + 1, $len - 1, \$val);
        if ($number_type == 0) {
          return (int)$val;
        }
        elsif ($number_type == 1) {
          return $val;
        }
      }
      else {
        $number_type = _grok_non_neg($json_str, $start, $len, \$val);
        if ($number_type == 0) {
          return (int)$val;
        }
        elsif ($number_type == 1) {
          return $val;
        }
      }

      if ($json_str->[$start] == '-') {
        --$len;
      }

      # does not fit into long, try double
      if (DBL_DIG() >= $len) {
        return _atof($json_str, $start, $end);
      }

      # everything else fails, convert it to a string
      return substr($json_str, $start, $$iter - $start);
    }

    # loss of precision here
    return _atof($json_str, $start, $end);
  }

  precompile private sub _decode_true : SPVM::JSON::Bool ($self : self, $json_str : string, $iter : int&, $end : int) {
    _expect_token($json_str, $iter, $end, "true");
    return SPVM::JSON::Bool->TRUE;
  }

  precompile private sub _decode_false : SPVM::JSON::Bool ($self : self, $json_str : string, $iter : int&, $end : int) {
    _expect_token($json_str, $iter, $end, "false");
    return SPVM::JSON::Bool->FALSE;
  }

  precompile private sub _decode_hash : SPVM::Hash ($self : self, $json_str : string, $iter : int&, $end : int) {
    my $hash = SPVM::Hash->new;
    my $has_element = 0;
    _expect_token($json_str, $iter, $end, "{");
    while (1) {
      $self->_skip_spaces($json_str, $iter, $end);
      if ($$iter == $end) {
        _custom_die("Incomplete object in JSON: end of string", $json_str, $$iter, $end);
      }

      # end of hash
      if ($json_str->[$$iter] == '}') {
        last;
      }

      # comma
      if ($has_element) {
        _expect_token($json_str, $iter, $end, ",");
        $self->_skip_spaces($json_str, $iter, $end);
      }
      else {
        $has_element = 1;
      }

      # key
      my $key = $self->_decode_string($json_str, $iter, $end);

      # separator
      $self->_skip_spaces($json_str, $iter, $end);
      _expect_token($json_str, $iter, $end, ":");

      # value
      $self->_skip_spaces($json_str, $iter, $end);
      $hash->set($key, $self->_decode_recursive($json_str, $iter, $end));
    }
    _expect_token($json_str, $iter, $end, "}");
    return $hash;
  }

  precompile private sub _decode_list : SPVM::ObjectList ($self : self, $json_str : string, $iter : int&, $end : int) {
    _expect_token($json_str, $iter, $end, "[");
    my $list = SPVM::ObjectList->new;
    my $has_element = 0;
    while (1) {
      $self->_skip_spaces($json_str, $iter, $end);
      if ($$iter == $end) {
        _custom_die("Incomplete array in JSON: end of string", $json_str, $$iter, $end);
      }

      # end of list
      if ($json_str->[$$iter] == ']') {
        last;
      }

      # comma
      if ($has_element) {
        _expect_token($json_str, $iter, $end, ",");
        $self->_skip_spaces($json_str, $iter, $end);
      }
      else {
        $has_element = 1;
      }
      $list->push($self->_decode_recursive($json_str, $iter, $end));
    }
    _expect_token($json_str, $iter, $end, "]");
    return $list;
  }

  precompile private sub _decode_recursive : object ($self : self, $json_str : string, $iter : int&, $end : int) {
    $self->_skip_spaces($json_str, $iter, $end);
    if ($$iter == $end) {
      _custom_die("Incomplete JSON", $json_str, $$iter, $end);
    }

    my $c = (int)($json_str->[$$iter]);
    switch ($c) {
      case '{': {
        # objects
        return $self->_decode_hash($json_str, $iter, $end);
        break;
      }
      case '[': {
        return $self->_decode_list($json_str, $iter, $end);
        break;
      }
      case '"': {
        return $self->_decode_string($json_str, $iter, $end);
        break;
      }
      case '-': case 'i': case 'n':
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9': {
        return $self->_decode_num($json_str, $iter, $end);
        break;
      }
      case 't': {
        return $self->_decode_true($json_str, $iter, $end);
        break;
      }
      case 'f': {
        return $self->_decode_false($json_str, $iter, $end);
        break;
      }
      default: {
        _custom_die("Unexpected token.", $json_str, $$iter, $end);
      }
    }
  }

  precompile private sub _escape_string : string ($string : string) {
    my $length = length $string;
    my $chars = SPVM::ObjectList->new;
    for (my $str_index = 0; $str_index < $length; ++$str_index) {
      my $got_char = (int)($string->[$str_index]);
      my $special = -1;
      switch ($got_char) {
        case 9: {# '\t'
          # Note: Decoded char from literal ASCII tab will be encoded with "\\t" (non-reversible).
          $special = 't';
          break;
        }
        case 10: { # '\n'
          $special = 'n';
          break;
        }
        case 13: { # '\r'
          $special = 'r';
          break;
        }
        case 34: { # '"'
          $special = '"';
          break;
        }
        case 92: { # '\\'
          $special = '\\';
          break;
        }
      }
      if ($special == -1) {
        $chars->push(SPVM::Int->new($got_char));
      }
      else {
        $chars->push(SPVM::Int->new('\\'));
        $chars->push(SPVM::Int->new($special));
      }
    }
    my $chars_length = $chars->length;
    my $escaped = new byte [$chars_length];
    for (my $k = 0; $k < $chars_length; ++$k) {
      my $got = ((SPVM::Int)$chars->shift)->val;
      $escaped->[$k] = (byte)$got;
    }
    return (string)$escaped;
  }

  precompile private sub _encode_recursive : string ($self : self, $spvm_data : object, $depth : int) {
    
    my $json : string;
    
    # undef
    if ($spvm_data == undef) {
      $json = "null";
    }
    # Hash
    elsif ($spvm_data isa SPVM::Hash) {
      my $buffer = SPVM::StringBuffer->new;
      $buffer->push("{");
      my $hash = (SPVM::Hash)$spvm_data;
      my $keys = $hash->keys;
      if ($self->canonical) {
        sortstr($keys);
      }
      for (my $keys_index = 0; $keys_index < @$keys; ++$keys_index) {
        if ($keys_index > 0) {
          $buffer->push(",");
        }
        $buffer->push("\"");
        $buffer->push($keys->[$keys_index]);
        $buffer->push("\":");
        my $json_part = $self->_encode_recursive($hash->get($keys->[$keys_index]), $depth + 1);
        $buffer->push($json_part);
      }
      $buffer->push("}");
      
      $json = $buffer->to_str;
    }
    # Array
    elsif ($spvm_data isa SPVM::ObjectList) {
      my $buffer = SPVM::StringBuffer->new;
      $buffer->push("[");
      
      my $list = (SPVM::ObjectList)$spvm_data;
      my $length = $list->length;
      for (my $list_index = 0; $list_index < $length; ++$list_index) {
        if ($list_index > 0) {
          $buffer->push(",");
        }
        my $json_part = $self->_encode_recursive($list->get($list_index), $depth + 1);
        $buffer->push($json_part);
      }
      $buffer->push("]");
      
      $json = $buffer->to_str;
    }
    # string
    elsif ($spvm_data isa string) {
      my $escaped = _escape_string((string)$spvm_data);
      $json = "\"" . $escaped . "\"";
    }
    # byte
    elsif ($spvm_data isa SPVM::Byte) {
      $json = (string)(double)(((SPVM::Byte)$spvm_data)->val);
    }
    # short
    elsif ($spvm_data isa SPVM::Short) {
      $json = (string)(double)(((SPVM::Short)$spvm_data)->val);
    }
    # int
    elsif ($spvm_data isa SPVM::Int) {
      $json = (string)(double)(((SPVM::Int)$spvm_data)->val);
    }
    # long
    elsif ($spvm_data isa SPVM::Long) {
      $json = (string)(double)(((SPVM::Long)$spvm_data)->val);
    }
    # float
    elsif ($spvm_data isa SPVM::Float) {
      $json = (string)(double)(((SPVM::Float)$spvm_data)->val);
    }
    # double
    elsif ($spvm_data isa SPVM::Double) {
      $json = (string)(((SPVM::Double)$spvm_data)->val);
    }
    # bool
    elsif ($spvm_data isa SPVM::JSON::Bool) {
      if (((SPVM::JSON::Bool)$spvm_data)->val) {
        $json = "true";
      }
      else {
        $json = "false";
      }
    }
    else {
      die "Invalid data type";
    }
    
    return $json;
  }

  precompile sub new : SPVM::JSON () {
    my $json = new SPVM::JSON;
    return $json;
  }

  precompile sub encode : string ($self : self, $object : object) {
    return $self->_encode_recursive($object, 0);
  }

  precompile sub decode : object ($self : self, $json_text : string) {
    my $length = length $json_text;
    my $iter = 0;
    $self->_skip_spaces($json_text, \$iter, $length);
    if ($iter == $length) {
      return undef;
    }
    my $ret = $self->_decode_recursive($json_text, \$iter, $length);
    $self->_skip_spaces($json_text, \$iter, $length);
    unless ($iter == $length) {
      _custom_die("Not all json_text is decoded yet", $json_text, $iter, $length);
    }
    return $ret;
  }
}
