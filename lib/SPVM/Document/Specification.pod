=head1 NAME

SPVM::Document::Specification - SPVM Language Specification(BETA before 1.0)

=head1 SPVM Language Specification

=head1 1. Introduction

SPVM is designed to help Perl week points. Perl week points is:

=over 2

=item * Perl numeric and array operation is slow because Perl can't have Static Type.

=item * Perl can't calcurate number correctly, for exampele, float operation, bit operation of integral type, etc.

=item * Perl can't bind C/C++ library easily becuase Perl don't have type semaintics.

=back

SPVM provide Fast and Correct Numeric and Array operation, and C/C++ binding become much easy.

SPVM Module is used from Perl directory. SPVM is not single language. You can call SPVM subroutine easily from Perl .

If you use SPVM, you can create module which need numeric and array operation.

For example:

AI, Machine Learning, Deep Learning, Statistics, IoT, Image Recognition, Voice Recognition, 
Signal Processing.

SPVM have Primitive Type, Array Type, Package Type. Primitive Type is byte, short, int, long, float, double.
You can calcurate number by these types. Array Type is Contiguous Area of primitive type. Package Type have, for example, x, y field.

SPVM have Type Inference, GC, Memory Safety, Destructor, Package Template. GC is Reference Count GC. Template Package is like C++ Class Template.

=head2 1.1. Organization of the Specification

Chapter 2

Chapter 3

Chapter 4

Chapter 5

Chapter 6

Chapter 7

Chapter 8

Chapter 9

=head2 1.2. Example Programs

Most of the example programs given in the text are ready to be executed and are similar in form to:

  # lib/SPVM/Foo.spvm
  package Foo {
    sub bar() : void {
      std::say("Hello, world.");
    }
  }

You can use this class from Perl directory.
  
  use FindBin;
  use lib "$FindBin::Bin/lib";
  use SPVM 'Foo';
  
  # Call SVPM subroutine
  SPVM::Foo::bar();

producing the output:

  Hello, world.

=head1 Syntax

=head2 Package Declaration

Package declaration is the following.

  package PackageName {
    
  }

C<PackageName> is package name.

Package name is consist of Upper Case and Lower Case and Number and C<::>.
Package name must start with Upper Case. Package name which start with Lower Case is forbidden.
Package name which start with Lower Case is resolved for core.

Note that package name can't contain Under Score C<_>.
Under Score is used for C<Package Template>.

  # Legal
  Foo
  Foo2
  Foo::Bar
  Foo::Bar::Baz
  Foo::bar
  
  # Illegal
  foo
  foo::Bar
  2Foo
  Foo_Bar

Package Declaration must be just under file itself.

  # Legal
  package PackageName {
    
  }
  
  # Illegal
  sub foo() : int {
    package PackageName {
      
    }
  }

=head2 Field Declaration

Field declaration is the following.

  has field_name : type_name;

C<filed_name> is field name. 
Field name is consist of Upper Case and Lower Case and Number and Under Score C<_>.
Field name must not start with Number. Under score must not continue more than one.

  # Legal
  foo
  foo_bar
  foo2
  foo_bar2
  FOO
  
  # Illegal
  2foo
  foo__bar

C<type_name> is a type. Type is explained in L</"Type"> section.

Field Declaration must be just under Package Declaration.

  # Legal
  package PackageName {
    has field_name : type_name;
  }

  # Illeagal
  has field_name : type_name;
  sub foo() : int {
    has field_name : type_name
  }

=head2 Subroutine Decralation

Subroutine declaration is the following.

  sub sub_name(arg_name : type_name, ...) : descripter_name return_type_name {
    
  }

C<sub_name> is subroutine name. 
Subroutine name is consist of Upper Case and Lower Case and Number and Under Score C<_>.
Subroutine name must not start with Number. Under score must not continue more than one.

  # Legal
  foo
  foo_bar
  foo2
  foo_bar2
  FOO
  
  # Illegal
  2foo
  foo__bar

C<arg_name> is Argument Name. This is Variable name. Variable name is explained in L</"Variable Declaration"> section,

C<type_name> is a Type. Type is explained L</"Type"> section.

C<arg_name : type_name> can be repeated with C<,>. If argument is none, that is ok. Max arguments count is C<255>.

C<descripter_name> is a Descripter. If descripter is none, that is ok. Available descripters are following.
Currently only one descripter is available.
  
  [Name]     [Description]
  native     the subroutine is native

Native subroutine is explained in L</"Native Subroutine">.

C<return_type_name> is a Type or C<void>. C<void> mean the subroutine don't have return value.
Type is explained L</"Type"> section.

Subroutine Declaration must be just under Package Declaration.

  # Legal
  package PackageName {
    sub foo($nums : int[]) : int {
    
    }
  }
  
  # Illeagal
  sub foo() : double {
    sub var() : void {
      
    }
  }

=head2 Variable Declaration

Variable Declaration is the following.

  my var_name : type_name;

C<var_name> is Variable Name. Variable Name first character is C<$>.
Rest characters is consist of Upper case, Lower case, Number and Under score C<_>.

  # Legal
  $foo
  $FOO
  $foo2
  $foo_bar

If Variable Declaration is done, you can use variable after the declaration.

C<type_name> is a <Type>. Type is explained at L</"Type"> section.

You can Initialize the variable as same time as Variable Declaration.

  my $num : int = 3;

B<Variable Declaration Example:>
  
  # Primitive Type
  my $value : byte;
  my $value : short;
  my $value : int;
  my $value : long;
  my $value : float;
  my $value : double;
  
  # Array Type
  my $values : byte[];
  my $values : short[];
  my $values : int[];
  my $values : long[];
  my $values : float[];
  my $values : double[];
  my $values : PackageName[];

  # Multiple Dimension Array Type
  my $values : byte[][];
  my $values : short[][];
  my $values : int[][];
  my $values : long[][];
  my $values : float[][];
  my $values : double[][];
  my $values : PackageName[][];

  # Package Type
  my $obj : PackageName;

=head2 Type Inference

If the Type of right value is known, the type of left value is automatically decided.

  my $num = 2;
  my $obj = new Foo;
  my $nums = new int[3];

Above is same as the following.

  my $num : int = 2;
  my $obj : Foo = new Foo;
  my $nums : int[3] = new int[3];

=head2 Number Literal

=head3 Integer Literal

Integer Literal is composed of 

   [+|-][0x|0|0q|0b][0123456789ABCDEF]...[U|u|L|l]

Default Number Literal Type is C<int>.

  123

You can use hex number literal by start C<0x>.

C<a>, C<b>, C<c>, C<d>, C<e>, C<f>, C<A>, C<B>, C<C>, C<D>, C<E>, C<F> is used as hex number.

  0xAF
  0xaf

You can use under line C<_> in number literal. Under line is meanless, only for visuality.

  123_456
  0xAB_CD

=head3 Floating Point Literal

If you use C<.> in number literal, the number is floating point literal. Default type of floating point value is C<double>.

  1.23

You can use C<E> or C<e> to specify exponential notation.

  1.23E+12
  1.23E-12
  1.23e+12
  1.23e-12

You can use type specifier to specify number leteral type

=over 2

=item * y

  # Byte
  123y

=item * s
  
  # Short
  123s

=item * L
  
  # Long
  123L

=item * f
  
  # Float
  123f

=item * d

  # Double
  123d

=back

If you know more Type, see L</"Type"> section.

Note that C<b> is type specifiler, not hex literal. This means C<b> can't be used as hex number C<11>. You must use C<B> to express hex number C<11>.

=head2 String Literal

String Literal is the following.

  "abc"

Type of String literal is C<byte[]>.

  my $string : byte[] = "abc";

Note that String Literal is Not Shared. New Byte Array is created and String literal is Copied to the byte array. 

=head3 Escape Sequences

A character preceded by a backslash (\) is an escape sequence and has special meaning to the compiler. The following table shows the SPVM escape sequences:

  [Escape Sequences]    [Escape Sequence	Description]
  \t                    Insert a tab in the text at this point.
  \b                    Insert a backspace in the text at this point.
  \n                   	Insert a newline in the text at this point.
  \r                    Insert a carriage return in the text at this point.
  \f                    Insert a formfeed in the text at this point.
  \'                    Insert a single quote character in the text at this point.
  \"                    Insert a double quote character in the text at this point.
  \\                    Insert a backslash character in the text at this point.

=head2 Type

=head3 Primitive Type

Primitive types are C<byte>, C<short>, C<int>, C<long>, C<float>, C<double>.
  
  [Type]  [Type Description]      [Type Byte Size]
  byte    signed integer          1byte
  short   signed integer          2byte
  int     signed integer          4byte
  long    signed integer          8byte
  float   floating-point number   4byte
  double  floating-point number   8byte

Varialbe Declaration with Type is the following.

  my $value : byte;
  my $value : short;
  my $value : int;
  my $value : long;
  my $value : float;
  my $value : double;

If you know more Variable Declaration, see L</"Variable Declaration"> section.

=head3 Array Type

Array Type describe multiple values.

  [Type]         [Type Description]
  byte[]         byte array
  short[]        short array
  int[]          int array array
  long[]         long array
  float[]        float array
  doube[]        double array
  PackageName[]  object array

Array Type is a Object Type. You can create Array by C<new> keyword.

  my $values : int[] = new int[3];

If you know more Array Creating, see L</"New Array"> section.

=head3 Multiple Dimention Array Type

Multiple Dimention Array Type is a Array Type.
  
  [Two Dimension Array Type]
  byte[][];
  short[][];
  int[][];
  long[][];
  float[][];
  double[][];
  PackageName[][];
  
  [Three Dimension Array Type]
  byte[][][];
  short[][][];
  int[][][];
  long[][][];
  float[][][];
  double[][][];
  PackageName[][][];
  
Max Dimension is C<255>.

You can create Multiple Dimension Array by C<new> keyword.

  my $values : int[][] = new int[][3];

This mean that Multiple Dimension Array is created, the multiple dimension array have 3 C<int[]> type array.
The elements is initialized by C<undef>.

If you know Multiple Dimension Array Creating, see L</"New Multiple Dimention Array">.

=head3 Package Type

If you declare package, Package name is used as Package Type.

  PackageName

If you know more Package Declaration, see L</"Package Declaration"> section.

You can create Package Type Object by C<new> keyword.

  my $obj : PackageName = new PackageName;

=head2 New Array

Array is created by new. Elements values is not initialized.

  my $nums = new byte[3];
  my $nums = new short[3];
  my $nums = new int[3];
  my $nums = new long[3];
  my $nums = new float[3];
  my $nums = new double[3];

=head2 Array Manipulation

=head3 Get Array Length

You can use the three ways to get Array Length.

  @$nums;
  @{$nums};
  len $nums;

=head3 Get and Set Array Element

Get Array Element:

  # Get
  $nums->[0];

Set Array Element:

  # Set
  $nums->[0] = 5;

=head2 Condition branch

  if (1) {

  }
  elsif (2) {

  }
  else {

  }

=head2 Loop

=head3 for

  my $nums = new int[10];
  for (my $i = 0; $i < @$nums; $i++) {
    $nums->[$i] = 0;
  }

=head3 while

  my $nums = new int[10];
  my $i = 0;
  while ($i < @$nums) {
    $nums->[$i] = 0;
  }

=head2 POD

  =pod
    AAAA
  =cut

=head2 __END__

  __END__

=head2 Exception

=head3 Throw Exception

  die "Error";

=head3 Catch Exception

  eval {
    die "Error";
  };

=head3 Exception Message

  $@;

=head2 Weak Reference

Using weak reference, recursive reference is resolved.

  my $foo = new Foo;
  my $bar = new Bar;
  
  # Recursive reference
  $foo->{bar} = $foo;
  $bar->{foo} = $foo;
  
  # Weak reference
  weaken $foo->{bar};

=head2 Destructor

Destructor.
  
  package Foo {
  
    sub DESTROY($self : Foo) : void {
      
    }
  }

=head2 Enumeration

Enumeration.

  package Foo {
    enum {
      ONE,
      TWO,
      THREE
    }
    
    enum {
      FORE = 4,
      FIVE,
    }
  }

=head2 Extension native function

  package TestCase::Extension {
    sub sum($num1 : int, $num2 : int) : native int;
  }
