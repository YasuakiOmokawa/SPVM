=head1 NAME

SPVM::Document::Specification - SPVM Language Specification(BETA before 1.0)

=head1 SPVM Language Specification

=head2 Package Declaration

Package declaration is the following.

  package PackageName {
    
  }

C<PackageName> is package name.

Package name is consist of Upper Case and Lower Case and Number and C<::>.
Package name must start with Upper Case. Package name which start with Lower Case is forbidden.
Package name which start with Lower Case is resolved for core.

Note that package name can't contain Under Score C<_>.
Under Score is used for C<Package Template>.

  # Legal
  Foo
  Foo2
  Foo::Bar
  Foo::Bar::Baz
  Foo::bar
  
  # Illegal
  foo
  foo::Bar
  2Foo
  Foo_Bar

Package Declaration must be just under file itself.

  # Legal
  package PackageName {
    
  }
  
  # Illegal
  sub foo() : int {
    package PackageName {
      
    }
  }

=head2 Field Declaration

Field declaration is the following.

  has field_name : type_name;

C<filed_name> is field name. 
Field name is consist of Upper Case and Lower Case and Number and Under Score C<_>.
Field name must not start with Number. Under score must not continue more than one.

  # Legal
  foo
  foo_bar
  foo2
  foo_bar2
  FOO
  
  # Illegal
  2foo
  foo__bar

C<type_name> is a type. Type is explained in L</"Type"> section.

Field Declaration must be just under Package Declaration.

  # Legal
  package PackageName {
    has field_name : type_name;
  }

  # Illeagal
  has field_name : type_name;
  sub foo() : int {
    has field_name : type_name
  }

=head2 Subroutine Decralation

Subroutine declaration is the following.

  sub sub_name(arg_name : type_name, ...) : descripter_name return_type_name {
    
  }

C<sub_name> is subroutine name. 
Subroutine name is consist of Upper Case and Lower Case and Number and Under Score C<_>.
Subroutine name must not start with Number. Under score must not continue more than one.

  # Legal
  foo
  foo_bar
  foo2
  foo_bar2
  FOO
  
  # Illegal
  2foo
  foo__bar

C<arg_name> is Argument Name. This is Variable name. Variable name is explained in L</"Variable Declaration"> section,

C<type_name> is a Type. Type is explained L</"Type"> section.

C<arg_name : type_name> can be repeated with C<,>. If argument is none, that is ok. Max arguments count is C<255>.

C<descripter_name> is a Descripter. If descripter is none, that is ok. Available descripters are following.
Currently only one descripter is available.
  
  [Name]     [Description]
  native     the subroutine is native

Native subroutine is explained in L</"Native Subroutine">.

C<return_type_name> is a Type or C<void>. C<void> mean the subroutine don't have return value.
Type is explained L</"Type"> section.

Subroutine Declaration must be just under Package Declaration.

  # Legal
  package PackageName {
    sub foo($nums : int[]) : int {
    
    }
  }
  
  # Illeagal
  sub foo() : double {
    sub var() : void {
      
    }
  }

=head2 Variable Declaration

Variable Declaration is the following.

  my var_name : type_name;

C<var_name> is Variable Name. Variable Name first character is C<$>.
Rest characters is consist of Upper case, Lower case, Number and Under score C<_>.

  # Legal
  $foo
  $FOO
  $foo2
  $foo_bar

If Variable Declaration is done, you can use variable after the declaration.

C<type_name> is a <Type>. Type is explained L</"Type"> section.

You can Initialize the variable as same time as Variable Declaration.

  my $num : int = 3;

=head2 Type Inference

If the Type of right value is known, the type of left value is automatically decided.

  my $num = 2;
  my $obj = new Foo;
  my $nums = new int[3];

Above is same as the following.

  my $num : int = 2;
  my $obj : Foo = new Foo;
  my $nums : int[3] = new int[3];

=head2 Number literal

Default number literal type is C<int>.

  123

You can use hex number literal by start C<0x>. C<A>, C<B>, C<C>, C<D>, C<E>, C<F> must be upper case.

  0xAF

If you use C<.> in number literal, the number is floating point literal.

  1.23

You can use C<E> or C<e> to specify exponential notation.

  1.23E+12
  1.23E-12
  1.23e+12
  1.23e-12

You can use under line C<_> in number literal. Under line is meanless, only for visuality.

  123_456
  0xAB_CD

You can use specifier to specify number leteral type

=over 2

=item * b

  # Byte
  123b

=item * s
  
  # Short
  123s

=item * L
  
  # Long
  123L

=item * f
  
  # Float
  123f

=item * d

  # Double
  123d

=back

=head2 String Literal

String Literal is the following.

  "abc"

Type of String literal is C<byte[]>. You can assign string literal to variable whith type is C<byte[]>.

  my $string : byte[] = "abc";

=head2 Type

=head3 Numeric type

Numeric types are byte, short, int, long, float, double.

  byte    signed integer          1byte
  short   signed integer          2byte
  int     signed integer          4byte
  long    signed integer          8byte
  float   floating-point number   4byte
  double  floating-point number   8byte

Declaration

  my $value : byte;
  my $value : short;
  my $value : int;
  my $value : long;
  my $value : float;
  my $value : double;

=head3 Reference type

Reference types are `array` and `object`.

B<Object type>

    PackageName

Declaration

    my $object : PackageName;

B<Array type>

  byte[]   byte array
  short[]  short array
  int[]    int array array
  long[]   long array
  float[]  float array
  doube[]  double array
  PackageName[] object array

Declaration

  my $values : byte[];
  my $values : short[];
  my $values : int[];
  my $values : long[];
  my $values : float[];
  my $values : double[];
  my $values : PackageName[];

B<Multiple array type>

  my $values : byte[][];
  my $values : short[][];
  my $values : int[][];
  my $values : long[][];
  my $values : float[][];
  my $values : double[][];
  my $values : PackageName[][];

  my $values : byte[][][];
  my $values : short[][][];
  my $values : int[][][];
  my $values : long[][][];
  my $values : float[][][];
  my $values : double[][][];
  my $values : PackageName[][][];

=head2 Array

=head3 Create array

Array is created by new. Elements values is not initialized.

  my $nums = new byte[3];
  my $nums = new short[3];
  my $nums = new int[3];
  my $nums = new long[3];
  my $nums = new float[3];
  my $nums = new double[3];

=head3 Get array length

  my $len = @$nums;
  my $len = @{$nums};
  my $len = len $nums;

=head3 Get and set array element

  # Get
  my $num = $nums->[0];

  # Set
  $nums->[0] = 5;

=head2 Condition branch

  if (1) {

  }
  elsif (2) {

  }
  else {

  }

=head2 Loop

=head3 for

  my $nums = new int[10];
  for (my $i = 0; $i < @$nums; $i++) {
    $nums->[$i] = 0;
  }

=head3 while

  my $nums = new int[10];
  my $i = 0;
  while ($i < @$nums) {
    $nums->[$i] = 0;
  }

=head2 Constant

=head3 Constant type

Type of constant default integral value is `int`.

  # int type
  1;
  3;

Type of constant default floating-point value is `double`.

  # double
  1.2
  5.3

Type of constant is specified by type specifier.

  # long
  3L

  # float
  3.2f

  # double
  3.2d

=head2 POD

  =pod
    AAAA
  =cut

=head2 __END__

  __END__

=head2 Exception

=head3 Exception occur

  die "Error";

=head3 Catch exception

  eval {
    die "Error";
  };

=head3 Exception message

  $@;

=head2 Name

=head3 Package name

Package name is a combination of alphabets, numbers, and `::`. Numbers should not appear as the first character. `_` can't be used in class name.

  # OK
  Foo
  Foo::Bar
  Foo1::Bar1

  # Not OK
  1Foo
  Foo::2Bar
  Foo_Bar;

=head3 Subroutine name

Subroutine name is a combination of alphabets, numbers, and `_` separators. Continual `_`(For example `__`) can't be used in subroutine name.

  # OK
  foo
  foo1
  foo_bar

  # Not OK
  1foo
  foo__bar

=head3 Field name

Field name is a combination of alphabets, numbers, and `_` separators. Continual `_`(For example `__`) can't be used in field name.

  # OK
  foo
  foo1
  foo_bar

  # Not OK
  1foo
  foo__bar

=head3 Absolute name

Absolute name is combination of package name and subroutine name, or package name and field name.

  PackageName1::foo
  PackageName1::PackageName2::foo_bar

=head2 Weak reference

Using weak reference, recursive reference is resolved.

  my $foo = new Foo;
  my $bar = new Bar;
  
  # Recursive reference
  $foo->{bar} = $foo;
  $bar->{foo} = $foo;
  
  # Weak reference
  weaken $foo->{bar};

=head2 Destructor

Destructor.
  
  package Foo {
  
    sub DESTROY($self : Foo) : void {
      
    }
  }

=head2 enumeration

Enumeration.

  package Foo {
    enum {
      ONE,
      TWO,
      THREE
    }
    
    enum {
      FORE = 4,
      FIVE,
    }
  }

=head2 Extension native function

  package TestCase::Extension {
    sub sum($num1 : int, $num2 : int) : native int;
  }

  __NATIVE__

  #include <spvm_api.h>

  int32_t SPVM__TestCase__Extension__sum(SPVM_API* api, SPVM_API_VALUE* args) {

    int32_t total = args[0].int_value + args[1].int_value;
    
    return total;
  }
