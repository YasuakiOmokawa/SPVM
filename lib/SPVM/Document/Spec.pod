=head1 NAME

SPVM::Document::Spec - SPVM language specification(BETA before 1.0)

=head1 SPVM Language Specification

=head2 Package Declaration

Package declaration is the following.

  package PackageName {
    
  }

C<PackageName> is package name.

Package name is consist of Upper Case and Lower Case and Number and C<::>.
Package name must start with Upper Case. lower case package name is forbidden.
lower case package name is resolved by core.

Note that package name can't contain Under Score C<_>.
Under Score is used for C<Package Template>.

  # Legal
  Foo
  Foo2
  Foo::Bar
  Foo::Bar::Baz
  Foo::bar
  
  # Illegal
  foo
  foo::Bar
  2Foo
  Foo_Bar

Package Decraration must be just under file itself.

  # Legal
  package PackageName {
    
  }
  
  # Illegal
  sub foo() : int {
    package PackageName {
      
    }
  }

=head2 Field Declaration

Field decration is the following.

  has field_name : type_name;

C<filed_name> is field name. 
Field name name is consist of Upper Case and Lower Case and Number and Under Score C<_>.
Package name must not start with Number.

  # Legal
  foo
  foo_bar
  foo2
  foo_bar2
  FOO
  
  # Illegal
  2foo

C<type_name> is a type. Type is explained C<Type> section. List some type examples.

  byte
  short
  int
  long
  float
  double
  string
  PackageName

Field Declaration must be just under Package Declaration.

  # Legal
  package PackageName {
    has field_name : type_name;
  }

  # Illeagal
  has field_name : type_name;
  sub foo() : int {
    has field_name : type_name
  }

=head2 Number literal

Default number literal type is C<int>.

  123

You can use hex number literal by start C<0x>. C<A>, C<B>, C<C>, C<D>, C<E>, C<F> must be upper case.

  0xAF

If you use C<.> in number literal, the number is floating point literal.

  1.23

You can use C<E> or C<e> to specify exponential notation.

  1.23E+12
  1.23E-12
  1.23e+12
  1.23e-12

You can use under line C<_> in number literal. Under line is meanless, only for visuality.

  123_456
  0xAB_CD

You can use specifier to specify number leteral type

=over 2

=item * b

  # Byte
  123b

=item * s
  
  # Short
  123s

=item * L
  
  # Long
  123L

=item * f
  
  # Float
  123f

=item * d

  # Double
  123d

=back

=head2 Type

=head3 Numeric type

Numeric types are byte, short, int, long, float, double.

  byte    signed integer          1byte
  short   signed integer          2byte
  int     signed integer          4byte
  long    signed integer          8byte
  float   floating-point number   4byte
  double  floating-point number   8byte

Declaration

  my $value : byte;
  my $value : short;
  my $value : int;
  my $value : long;
  my $value : float;
  my $value : double;

=head3 String type

String type is string.

This is same as byte[] at internal data structure.

Declaration

  my $string : string;

=head3 Reference type

Reference types are `array` and `object`.

B<Object type>

    PackageName

Declaration

    my $object : PackageName;

B<Array type>

  byte[]   byte array
  short[]  short array
  int[]    int array array
  long[]   long array
  float[]  float array
  doube[]  double array
  PackageName[] object array

Declaration

  my $values : byte[];
  my $values : short[];
  my $values : int[];
  my $values : long[];
  my $values : float[];
  my $values : double[];
  my $values : PackageName[];

B<Multiple array type>

  my $values : byte[][];
  my $values : short[][];
  my $values : int[][];
  my $values : long[][];
  my $values : float[][];
  my $values : double[][];
  my $values : PackageName[][];

  my $values : byte[][][];
  my $values : short[][][];
  my $values : int[][][];
  my $values : long[][][];
  my $values : float[][][];
  my $values : double[][][];
  my $values : PackageName[][][];

=head2 Type inference

If the type of right value is known, the type of left value is automatically decided.

  # Type of $value2 is byte.
  my $value1 : byte;
  my $value2 = $value1;

  # Type of $values2 is int[]
  my $values1 = new int[3];
  my $values2 = $values1;

  # Type of $object2 is PackageName
  my $object1 = new PackageName
  my $object2 = $object1;

=head2 Array

=head3 Create array

Array is created by new. Elements values is not initialized.

  my $nums = new byte[3];
  my $nums = new short[3];
  my $nums = new int[3];
  my $nums = new long[3];
  my $nums = new float[3];
  my $nums = new double[3];

=head3 Get array length

  my $len = @$nums;
  my $len = @{$nums};
  my $len = len $nums;

=head3 Get and set array element

  # Get
  my $num = $nums->[0];

  # Set
  $nums->[0] = 5;

=head2 Condition branch

  if (1) {

  }
  elsif (2) {

  }
  else {

  }

=head2 Loop

=head3 for

  my $nums = new int[10];
  for (my $i = 0; $i < @$nums; $i++) {
    $nums->[$i] = 0;
  }

=head3 while

  my $nums = new int[10];
  my $i = 0;
  while ($i < @$nums) {
    $nums->[$i] = 0;
  }

=head2 Constant

=head3 Constant type

Type of constant default integral value is `int`.

  # int type
  1;
  3;

Type of constant default floating-point value is `double`.

  # double
  1.2
  5.3

Type of constant is specified by type specifier.

  # long
  3L

  # float
  3.2f

  # double
  3.2d

=head2 POD

  =pod
    AAAA
  =cut

=head2 __END__

  __END__

=head2 Exception

=head3 Exception occur

  die "Error";

=head3 Catch exception

  eval {
    die "Error";
  };

=head3 Exception message

  $@;

=head2 Name

=head3 Package name

Package name is a combination of alphabets, numbers, and `::`. Numbers should not appear as the first character. `_` can't be used in class name.

  # OK
  Foo
  Foo::Bar
  Foo1::Bar1

  # Not OK
  1Foo
  Foo::2Bar
  Foo_Bar;

=head3 Subroutine name

Subroutine name is a combination of alphabets, numbers, and `_` separators. Continual `_`(For example `__`) can't be used in subroutine name.

  # OK
  foo
  foo1
  foo_bar

  # Not OK
  1foo
  foo__bar

=head3 Field name

Field name is a combination of alphabets, numbers, and `_` separators. Continual `_`(For example `__`) can't be used in field name.

  # OK
  foo
  foo1
  foo_bar

  # Not OK
  1foo
  foo__bar

=head3 Absolute name

Absolute name is combination of package name and subroutine name, or package name and field name.

  PackageName1::foo
  PackageName1::PackageName2::foo_bar

=head2 Weak reference

Using weak reference, recursive reference is resolved.

  my $foo = new Foo;
  my $bar = new Bar;
  
  # Recursive reference
  $foo->{bar} = $foo;
  $bar->{foo} = $foo;
  
  # Weak reference
  weaken $foo->{bar};

=head2 Destructor

Destructor.
  
  package Foo {
  
    sub DESTROY($self : Foo) : void {
      
    }
  }

=head2 enumeration

Enumeration.

  package Foo {
    enum {
      ONE,
      TWO,
      THREE
    }
    
    enum {
      FORE = 4,
      FIVE,
    }
  }

=head2 Inline native function

  package TestCase::Inline {
    sub sum($num1 : int, $num2 : int) : native int;
  }

  __NATIVE__

  #include <spvm_api.h>

  int32_t SPVM__TestCase__Inline__sum(SPVM_API* api, SPVM_API_VALUE* args) {

    int32_t total = args[0].int_value + args[1].int_value;
    
    return total;
  }
