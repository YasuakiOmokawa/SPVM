package TestCase {
  use TestCase::Weaken;
  use TestCase::Minimal;
  use TestCase::Simple;
  use TestCase::Destructor;
  use TestCase::Empty;
  use TestCase::Private;
  use TestCase::Point_i3;

  use SPVM::Byte;
  use SPVM::Short;
  use SPVM::Int;
  use SPVM::Long;
  use SPVM::Float;
  use SPVM::Double;

  use SPVM::Example;

  our $PACKAGE_VAR_INT : int;
  our $PACKAGE_VAR_LONG : long;
  our $PACKAGE_VAR_MINIMAL : TestCase::Minimal;

  our $PACKAGE_VAR_INT2 : int;
  our $PACKAGE_VAR_LONG2 : long;
  our $PACKAGE_VAR_MINIMAL2 : TestCase::Minimal;

  has x_byte : byte;
  has x_short : short;
  has x_int : int;
  has x_long : long;
  has x_float : float;
  has x_double : double;
  has x_int_array : int[];
  has x_string : byte[];
  has x_test_case : TestCase;
  has x_weaken : TestCase::Weaken;
  has weaken1 : TestCase::Weaken;
  has weaken2 : TestCase::Weaken;
  has weaken3 : TestCase::Weaken;
  has weaken4 : TestCase::Weaken;
  has minimal : TestCase::Minimal;
  has private_field : private int;
  
  precompile sub INT : int () { return 127; }
  precompile sub FLOAT_PRECICE : float () { return 16384.5f; }
  precompile sub DOUBLE_PRECICE : double () { return 65536.5; }
  
  precompile sub get_private_field : int ($self : self) {
    return $self->{private_field};
  }
  
  precompile sub set_x_int_array : void ($self : self, $x_int_array : int[]) {
    $self->{x_int_array} = $x_int_array;
  }

  precompile sub set_x_string : void ($self : self, $x_string : byte[]) {
    $self->{x_string} = $x_string;
  }

  precompile sub set_x_byte : void ($self : self, $x_byte : byte) {
    $self->{x_byte} = $x_byte;
  }

  precompile sub set_x_short : void ($self : self, $x_short : short) {
    $self->{x_short} = $x_short;
  }

  precompile sub set_x_int : void ($self : self, $x_int : int) {
    $self->{x_int} = $x_int;
  }

  precompile sub set_x_long : void ($self : self, $x_long : long) {
    $self->{x_long} = $x_long;
  }

  precompile sub set_x_float : void ($self : self, $x_float : float) {
    $self->{x_float} = $x_float;
  }

  precompile sub set_x_double : void ($self : self, $x_double : double) {
    $self->{x_double} = $x_double;
  }

  precompile sub get_x_byte : byte ($self : self) {
    return $self->{x_byte};
  }

  precompile sub get_x_short : short ($self : self) {
    return $self->{x_short};
  }

  precompile sub get_x_int : int ($self : self) {
    return $self->{x_int};
  }

  precompile sub get_x_long : long ($self : self) {
    return $self->{x_long};
  }

  precompile sub get_x_float : float ($self : self) {
    return $self->{x_float};
  }

  precompile sub get_x_double : double ($self : self) {
    return $self->{x_double};
  }
  
  # Only compile check
  precompile sub eval_block_stack_check : void () {
    eval {
      my $obj_error1 = "Error1";
      
      croak $obj_error1;
    };
    
    {
      my $obj_error2 = "Error2";
      
      croak $obj_error2;
    }
  }
  
  precompile sub new : TestCase () {
    return new TestCase;
  }
  
  precompile sub my_var_in_loop_free : int () {
    for (my $i = 0; $i < 5; $i++) {
      my $minimal = new TestCase::Minimal;
    }
  }
  
  precompile sub package_var : int () {
    if ($TestCase::PACKAGE_VAR_INT == 0) {
      $TestCase::PACKAGE_VAR_INT = INT32_MAX();
      if ($TestCase::PACKAGE_VAR_INT == INT32_MAX()) {
        $TestCase::PACKAGE_VAR_LONG = INT64_MAX();
        if ($TestCase::PACKAGE_VAR_LONG == INT64_MAX()) {
          $TestCase::PACKAGE_VAR_MINIMAL = TestCase::Minimal->new();
          
          $TestCase::PACKAGE_VAR_MINIMAL->{x} = 4;
          
          if ($TestCase::PACKAGE_VAR_MINIMAL->{x} == 4) {
            $TestCase::PACKAGE_VAR_MINIMAL = undef;
            return 1;
          }
        }
      }
    }
    return 0;
  }

  precompile sub package_var_rel_name : int () {
    if ($PACKAGE_VAR_INT2 == 0) {
      $PACKAGE_VAR_INT2 = INT32_MAX();
      if ($PACKAGE_VAR_INT2 == INT32_MAX()) {
        $PACKAGE_VAR_LONG2 = INT64_MAX();
        if ($PACKAGE_VAR_LONG2 == INT64_MAX()) {
          $PACKAGE_VAR_MINIMAL2 = TestCase::Minimal->new();
          
          $PACKAGE_VAR_MINIMAL2->{x} = 4;
          
          if ($PACKAGE_VAR_MINIMAL2->{x} == 4) {
            $PACKAGE_VAR_MINIMAL2 = undef;
            return 1;
          }
        }
      }
    }
    return 0;
  }

  precompile sub package_var_other_package : int () {
    if ($TestCase::Simple::FOO == 0) {
      $TestCase::Simple::FOO = 1;
      if ($TestCase::Simple::FOO == 1) {
        return 1;
      }
    }
    return 0;
  }
  
  precompile sub get_minimal : TestCase::Minimal ($self : self) {
    return $self->{minimal};
  }

  precompile sub set_minimal : void ($self : self, $value : TestCase::Minimal) {
    $self->{minimal} = $value;
  }

  # Resorved word
  precompile sub int : int ($obj : TestCase) {
    
    return 5;
  }
  
  precompile sub use_reserved_word : int () {
    
    my $test_case = new TestCase;
    
    if (TestCase->int($test_case) == 5) {
      if (TestCase->int($test_case) == 5) {
        return 1;
      }
    }
    
    return 0;
  }
  
  # SPVM set and get
  precompile sub spvm_set_and_get_byte : int ($nums : byte[]) {
    
    if ($nums->[0] == 0) {
      if ($nums->[1] == INT8_MAX()) {
        return 1;
      }
    }
    
    return 0;
  }
  precompile sub spvm_set_and_get_short : int ($nums : short[]) {
    
    if ($nums->[0] == 0) {
      if ($nums->[1] == INT16_MAX()) {
        return 1;
      }
    }
    
    return 0;
  }
  precompile sub spvm_set_and_get_int : int ($nums : int[]) {
    
    if ($nums->[0] == 0) {
      if ($nums->[1] == INT32_MAX()) {
        return 1;
      }
    }
    
    return 0;
  }
  precompile sub spvm_set_and_get_long : int ($nums : long[]) {
    
    if ($nums->[0] == 0L) {
      if ($nums->[1] == INT64_MAX()) {
        return 1;
      }
    }
    
    return 0;
  }
  precompile sub spvm_set_and_get_float : int ($nums : float[]) {
    
    if ($nums->[0] == 0.0f) {
      if ($nums->[1] == FLOAT_PRECICE()) {
        return 1;
      }
    }
    
    return 0;
  }
  precompile sub spvm_set_and_get_double : int ($nums : double[]) {
    
    if ($nums->[0] == 0.0) {
      if ($nums->[1] == DOUBLE_PRECICE()) {
        return 1;
      }
    }
    
    return 0;
  }

  precompile sub spvm_set_and_get_value_t_int : int ($points : TestCase::Point_i3[]) {
    
    if ($points->[1]{x} == INT32_MIN()) {
      if ($points->[1]{y} == 1) {
        if ($points->[1]{z} == 2) {
          return 1;
        }
      }
    }
    
    return 0;
  }
  
  precompile sub concat : string () {
    "a" . "b";
    
    my $value = "a" . "b";
    
    return $value;
  }
  
  # string
  precompile sub string_utf8 : string () {
    my $value = "あいうえお";
    
    return $value;
  }
  precompile sub string_empty : string () {
    my $value = "";
    
    return $value;
  }

  precompile sub weaken_target4_weaken_object_assign : int () {
    my $test_case = new TestCase;
    $test_case->{x_int} = 2;
    my $weaken1 = TestCase::Weaken->new();
    my $weaken2 = TestCase::Weaken->new();
    my $weaken3 = TestCase::Weaken->new();
    my $weaken4 = TestCase::Weaken->new();
    
    $test_case->{weaken1} = $weaken1;
    $test_case->{weaken2} = $weaken2;
    $test_case->{weaken3} = $weaken3;
    $test_case->{weaken4} = $weaken4;
    
    $weaken1->{test_case} = $test_case;
    $weaken2->{test_case} = $test_case;
    $weaken3->{test_case} = $test_case;
    $weaken4->{test_case} = $test_case;
    
    $weaken1->weaken_test_case;
    $weaken2->weaken_test_case;
    $weaken3->weaken_test_case;
    $weaken4->weaken_test_case;
    
    $weaken2->{test_case} = undef;
    my $test_case2 = new TestCase;
    $weaken4->{test_case} = $test_case2;
    
    if ($test_case->{x_int} == 2) {
      return 1;
    }
    return 0;
  }
  
  precompile sub weaken_target4 : int () {
    my $test_case = new TestCase;
    $test_case->{x_int} = 2;
    my $weaken1 = TestCase::Weaken->new();
    my $weaken2 = TestCase::Weaken->new();
    my $weaken3 = TestCase::Weaken->new();
    my $weaken4 = TestCase::Weaken->new();
    
    $test_case->{weaken1} = $weaken1;
    $test_case->{weaken2} = $weaken2;
    $test_case->{weaken3} = $weaken3;
    $test_case->{weaken4} = $weaken4;
    
    $weaken1->{test_case} = $test_case;
    $weaken2->{test_case} = $test_case;
    $weaken3->{test_case} = $test_case;
    $weaken4->{test_case} = $test_case;
    
    $weaken1->weaken_test_case;
    $weaken2->weaken_test_case;
    $weaken3->weaken_test_case;
    $weaken4->weaken_test_case;

    if ($test_case->{x_int} == 2) {
      return 1;
    }
    return 0;
  }
  
  precompile sub weaken_weaken_object_undef : int () {
    my $weaken = TestCase::Weaken->new();
    my $test_case = new TestCase;
    $test_case->{x_int} = 2;
    
    $test_case->{x_weaken} = $weaken;
    $weaken->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    $test_case->{x_weaken} = undef;
    
    if ($test_case->{x_weaken} == undef) {
      if ($test_case->{x_int} == 2) {
        return 1;
      }
    }
    return 0;
  }
  
  precompile sub weaken_target_object_undef : int () {
    my $weaken = TestCase::Weaken->new();
    my $test_case = new TestCase;

    $test_case->{x_weaken} = $weaken;
    $weaken->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    $weaken = undef;
    
    if ($test_case->{x_weaken} == undef) {
      return 1;
    }
    return 0;
  }
  
  precompile sub weaken_recursive3 : int () {
    my $weaken = TestCase::Weaken->new();
    my $weaken2 = TestCase::Weaken2->new();
    my $test_case = new TestCase;
    $test_case->{x_weaken} = $weaken;
    $weaken->{weaken2} = $weaken2;
    $weaken2->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    
    return 1;
  }
  
  precompile sub weaken_reference_count1_object : int () {
    my $weaken = TestCase::Weaken->new();
    my $test_case = new TestCase;
    
    $test_case->{x_weaken} = $weaken;
    $weaken = undef;
    weaken $test_case->{x_weaken};
    
    if ($test_case->{x_weaken} == undef) {
      return 1;
    }
    
    return 0;
  }

  precompile sub weaken_recursive_again : void () {
    my $weaken = TestCase::Weaken->new();
    
    # Recuresive reference
    my $test_case = new TestCase;
    $test_case->{x_weaken} = $weaken;
    
    $weaken->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    weaken $test_case->{x_weaken};
  }
  
  precompile sub weaken_recursive : int () {
    my $weaken = TestCase::Weaken->new();
    $weaken->{x1} = 1;
    
    # Recuresive reference
    my $test_case = new TestCase;
    $test_case->{x_weaken} = $weaken;
    $test_case->{x_int} = 2;
    
    $weaken->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    
    if ($weaken->{x1} == 1) {
      if ($test_case->{x_int} == 2) {
        return 1;
      }
    }
    return 0;
  }
  
  precompile sub weaken_self_recuresive : int () {
    my $test_case = new TestCase;
    $test_case->{x_int} = 5;
    
    # Recuresive reference
    $test_case->{x_test_case} = $test_case;
    
    weaken $test_case->{x_test_case};
    
    if ($test_case->{x_int} == 5) {
      return 1;
    }
    
    return 0;
  }

  precompile sub spvm_new_object_array_len_element_byte_array : int ($nums : byte[][]) {
    
    if ($nums->[0][0] == 1) {
      if ($nums->[0][1] == 2) {
        if ($nums->[0][2] == 3) {
          if ($nums->[1][0] == 4) {
            if ($nums->[1][1] == 5) {
              if ($nums->[1][2] == 6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_object_array_len_element_short_array : int ($nums : short[][]) {
    if ((int)$nums->[0][0] == (int)(short)1) {
      if ((int)$nums->[0][1] == (int)(short)2) {
        if ((int)$nums->[0][2] == (int)(short)3) {
          if ((int)$nums->[1][0] == (int)(short)4) {
            if ((int)$nums->[1][1] == (int)(short)5) {
              if ((int)$nums->[1][2] == (int)(short)6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_object_array_len_element_int_array : int ($nums : int[][]) {
    if ($nums->[0][0] == 1) {
      if ($nums->[0][1] == 2) {
        if ($nums->[0][2] == 3) {
          if ($nums->[1][0] == 4) {
            if ($nums->[1][1] == 5) {
              if ($nums->[1][2] == 6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_object_array_len_element_long_array : int ($nums : long[][]) {
    if ($nums->[0][0] == (long)1) {
      if ($nums->[0][1] == (long)2) {
        if ($nums->[0][2] == (long)3) {
          if ($nums->[1][0] == (long)4) {
            if ($nums->[1][1] == (long)5) {
              if ($nums->[1][2] == (long)6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_object_array_len_element_float_array : int ($nums : float[][]) {
    if ($nums->[0][0] == (float)1) {
      if ($nums->[0][1] == (float)2) {
        if ($nums->[0][2] == (float)3) {
          if ($nums->[1][0] == (float)4) {
            if ($nums->[1][1] == (float)5) {
              if ($nums->[1][2] == (float)6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_object_array_len_element_double_array : int ($nums : double[][]) {
    if ($nums->[0][0] == (double)1) {
      if ($nums->[0][1] == (double)2) {
        if ($nums->[0][2] == (double)3) {
          if ($nums->[1][0] == (double)4) {
            if ($nums->[1][1] == (double)5) {
              if ($nums->[1][2] == (double)6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_object_array_len_element_object_array : int ($nums : TestCase[]) {
    if ($nums->[0]{x_int} == 1) {
      if ($nums->[1]{x_int} == 2) {
        return 1;
      }
    }
    
    return 0;
  }

  precompile sub my_var_scope : int () {
    my $ok1 = 0;
    my $ok2 = 0;
    my $ok3 = 0;
    
    my $var1 = 1;
    my $var2 = 2;
    
    if ($var1 == 1) {
      if ($var2 == 2) {
        $ok1 = 1;
      }
    }
    
    {
      my $var1 = 3;
      my $var2 = 4;
      my $var3 = 5;
      
      if ($var1 == 3) {
        if ($var2 == 4) {
          if ($var3 == 5) {
            $ok2 = 1;
          }
        }
      }
    }
    
    my $var3 = 6;
    
    if ($var1 == 1) {
      if ($var2 == 2) {
        if ($var3 == 6) {
          $ok3 = 1;
        }
      }
    }
    
    if ($ok1) {
      if ($ok2) {
        if ($ok3) {
          return 1;
        }
      }
    }
    
    return 0;
  }
  
  # My variable is initialized zero
  precompile sub my_var_initialized_zero : int () {
    my $var1 : int;
    my $var2 : TestCase;
    
    if ($var1 == 0) {
      if ($var2 == undef) {
        return 1;
      }
    }
    return 0;
  }

  precompile sub my_var_block : int () {
    my $success = 1;
    
    my $var1 = 1;
    if ($var1 != 1) {
      $success = 0;
    }
    
    {
      my $var1 = 2;
      if ($var1 != 2) {
        $success = 0;
      }
      
      {
        my $var1 = $var1;
        if ($var1 != 2) {
          $success = 0;
        }
        $var1 = 3;
      }
      if ($var1 != 2) {
        $success = 0;
      }
    }
    
    if ($success) {
      return 1;
    }
    return 0;
  }
  
  # new near small base_object_max_byte_size_use_memory_pool
  precompile sub new_near_small_base_object_max_byte_size_use_memory_pool : int () {
    my $block = new byte[0xFFF0];
    
    return 1;
  }

  enum {
    INT_ZERO,
    INT_ONE,
    INT_THREE = 3,
    INT_FOUR,
    INT_SIX = 6,
    INT_MINUS_MAX = -2147483648
  }
  precompile sub enum_int  : int () {
    
    if (TestCase->INT_ZERO == 0) {
      if (TestCase->INT_ONE == 1) {
        if (TestCase->INT_THREE == 3) {
          if (TestCase->INT_FOUR == 4) {
            if (TestCase->INT_SIX == 6) {
              if (TestCase->INT_MINUS_MAX == -2147483648) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }
  
  
  precompile sub spvm_object_set_object : int ($obj : TestCase) {
    my $nums = $obj->{x_int_array};
    my $values = ($obj->{x_string});
    
    
    # [INT32_MAX, INT32_MAX]
    if (@$nums == 2) {
      if ($nums->[0] == 2147483647) {
        if ($nums->[1] == 2147483647) {
          # abc
          if ($values->[0] == 97) {
            if ($values->[1] == 98) {
              if ($values->[2] == 99) {
                if (@$values == 3) {
                  return 1;
                }
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_object_set : int ($obj : TestCase) {
    if ($obj->{x_byte} == 127) {
      if ($obj->{x_short} == 32767) {
        if ($obj->{x_int} == 2147483647) {
          if ($obj->{x_long} == 9223372036854775807L) {
            if ($obj->{x_float} == FLOAT_PRECICE()) {
              if ($obj->{x_double} == DOUBLE_PRECICE()) {
                if ($obj->{minimal}->{x} == 3) {
                  return 1;
                }
              }
            }
          }
        }
      }
    }
    
    return 0;
  }
  
  # SPVM Functions
  precompile sub spvm_new_byte_array_string : int ($values : byte[]) {
    
    if ((int)$values->[0] == (int)(byte)0xE3) {
      if ((int)$values->[1] == (int)(byte)0x81) {
        if ((int)$values->[2] == (int)(byte)0x82) {
          if (@$values == 3) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_byte_array_bin : int ($values : byte[]) {
    
    if ($values->[0] == 97) {
      if ($values->[1] == 98) {
        if ($values->[2] == 99) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_byte_array_bin_pack : int ($values : byte[]) {
    
    if ($values->[0] == 97) {
      if ($values->[1] == 98) {
        if ($values->[2] == INT8_MAX()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_short_array_bin_pack : int ($values : short[]) {
    
    if ((int)$values->[0] == (int)(short)97) {
      if ((int)$values->[1] == (int)(short)98) {
        if ((int)$values->[2] == (int)(short)INT16_MAX()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }
  
  precompile sub spvm_new_int_array_bin_pack : int ($values : int[]) {
    
    if ($values->[0] == (int)97) {
      if ($values->[1] == (int)98) {
        if ($values->[2] == (int)INT32_MAX()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_long_array_bin_pack : int ($values : long[]) {
    
    if ($values->[0] == (long)97) {
      if ($values->[1] == (long)98) {
        if ($values->[2] == (long)INT64_MAX()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }

  precompile sub spvm_new_float_array_bin_pack : int ($values : float[]) {
    
    if ($values->[0] == (float)97) {
      if ($values->[1] == (float)98) {
        if ($values->[2] == (float)FLOAT_PRECICE()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }
  
  precompile sub spvm_new_double_array_bin_pack : int ($values : double[]) {
    
    if ($values->[0] == (double)97) {
      if ($values->[1] == (double)98) {
        if ($values->[2] == (double)DOUBLE_PRECICE()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }
  
  
  # Sum
  precompile sub sum_byte : byte ($a : byte, $b :byte,) {
    
    my $total = (byte)((int)$a + (int)$b);
    
    return $total;
  }

  precompile sub sum_short : short ($a : short, $b :short) {
    
    my $total = (short)((int)$a + (int)$b);
    
    return $total;
  }

  precompile sub sum_int : int ($a : int, $b :int) {
    
    my $total = $a + $b;
    
    return $total;
  }

  precompile sub sum_long : long ($a : long, $b :long) {
    
    my $total = $a + $b;
    
    return $total;
  }

  precompile sub sum_float : float ($a : float, $b :float) {
    
    my $total = $a + $b;
    
    return $total;
  }

  precompile sub sum_double : double ($a : double, $b :double) {
    
    my $total = $a + $b;
    
    return $total;
  }
  
}
