package TestCase {
  use TestCase::Weaken;
  use TestCase::Minimal;
  use TestCase::Destructor;
  use TestCase::Empty;
  use TestCase::Private;

  use SPVM::Byte;
  use SPVM::Short;
  use SPVM::Int;
  use SPVM::Long;
  use SPVM::Float;
  use SPVM::Double;

  use SPVM::Example;

  our $PACKAGE_VAR_INT : int;
  our $PACKAGE_VAR_LONG : long;
  our $PACKAGE_VAR_MINIMAL : TestCase::Minimal;

  our $PACKAGE_VAR_INT2 : int;
  our $PACKAGE_VAR_LONG2 : long;
  our $PACKAGE_VAR_MINIMAL2 : TestCase::Minimal;

  has x_byte : byte;
  has x_short : short;
  has x_int : int;
  has x_long : long;
  has x_float : float;
  has x_double : double;
  has x_int_array : int[];
  has x_string : byte[];
  has x_test_case : TestCase;
  has x_weaken : TestCase::Weaken;
  has weaken1 : TestCase::Weaken;
  has weaken2 : TestCase::Weaken;
  has weaken3 : TestCase::Weaken;
  has weaken4 : TestCase::Weaken;
  has minimal : TestCase::Minimal;
  has private_field : private int;
  
  sub INT : int () { return 127; }
  sub FLOAT_PRECICE : float () { return 16384.5f; }
  sub DOUBLE_PRECICE : double () { return 65536.5; }
  
  sub get_private_field : int ($self : self) {
    return $self->{private_field};
  }
  
  sub set_x_int_array : void ($self : self, $x_int_array : int[]) {
    $self->{x_int_array} = $x_int_array;
  }

  sub set_x_string : void ($self : self, $x_string : byte[]) {
    $self->{x_string} = $x_string;
  }

  sub set_x_byte : void ($self : self, $x_byte : byte) {
    $self->{x_byte} = $x_byte;
  }

  sub set_x_short : void ($self : self, $x_short : short) {
    $self->{x_short} = $x_short;
  }

  sub set_x_int : void ($self : self, $x_int : int) {
    $self->{x_int} = $x_int;
  }

  sub set_x_long : void ($self : self, $x_long : long) {
    $self->{x_long} = $x_long;
  }

  sub set_x_float : void ($self : self, $x_float : float) {
    $self->{x_float} = $x_float;
  }

  sub set_x_double : void ($self : self, $x_double : double) {
    $self->{x_double} = $x_double;
  }

  sub get_x_byte : byte ($self : self) {
    return $self->{x_byte};
  }

  sub get_x_short : short ($self : self) {
    return $self->{x_short};
  }

  sub get_x_int : int ($self : self) {
    return $self->{x_int};
  }

  sub get_x_long : long ($self : self) {
    return $self->{x_long};
  }

  sub get_x_float : float ($self : self) {
    return $self->{x_float};
  }

  sub get_x_double : double ($self : self) {
    return $self->{x_double};
  }
  
  # Only compile check
  sub eval_block_stack_check : void () {
    eval {
      my $obj_error1 = "Error1";
      
      croak $obj_error1;
    };
    
    {
      my $obj_error2 = "Error2";
      
      croak $obj_error2;
    }
  }
  
  sub new : TestCase () {
    return new TestCase;
  }
  
  sub my_var_in_loop_free : int () {
    for (my $i = 0; $i < 5; $i++) {
      my $minimal = new TestCase::Minimal;
    }
  }
  
  sub next_statement : int () {
    my $total = 0;
    for (my $i = 0; $i < 5; $i++) {
      if ($i == 1) {
        next;
      }
      if ($i == 3) {
        next;
      }
      $total += $i;
    }
    if ($total == 6) {
      return 1;
    }
    return 0;
  }
  
  sub convert_to_string : int () {
    my $byte_string = (string)(byte)23;
    my $short_string = (string)(short)23;
    my $int_string = (string)23;
    my $long_string = (string)23L;
    my $float_string = (string)0.25000f;
    my $double_string = (string)0.25000;
    
    if ($byte_string eq "23") {
      if ($short_string eq "23") {
        if ($int_string eq "23") {
          if ($long_string eq "23") {
            if ($float_string eq "0.25") {
              if ($double_string eq "0.25") {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }
  
  sub isa_basic : int () {
    my $minimal = new TestCase::Minimal;
    if ($minimal isa TestCase::Minimal) {
      if (!($minimal isa TestCase)) {
        return 1;
      }
    }
    
    return 0;
  }
  
  sub package_var : int () {
    if ($TestCase::PACKAGE_VAR_INT == 0) {
      $TestCase::PACKAGE_VAR_INT = INT32_MAX();
      if ($TestCase::PACKAGE_VAR_INT == INT32_MAX()) {
        $TestCase::PACKAGE_VAR_LONG = INT64_MAX();
        if ($TestCase::PACKAGE_VAR_LONG == INT64_MAX()) {
          $TestCase::PACKAGE_VAR_MINIMAL = TestCase::Minimal->new();
          
          $TestCase::PACKAGE_VAR_MINIMAL->{x} = 4;
          
          if ($TestCase::PACKAGE_VAR_MINIMAL->{x} == 4) {
            $TestCase::PACKAGE_VAR_MINIMAL = undef;
            return 1;
          }
        }
      }
    }
    return 0;
  }

  sub package_var_rel_name : int () {
    if ($PACKAGE_VAR_INT2 == 0) {
      $PACKAGE_VAR_INT2 = INT32_MAX();
      if ($PACKAGE_VAR_INT2 == INT32_MAX()) {
        $PACKAGE_VAR_LONG2 = INT64_MAX();
        if ($PACKAGE_VAR_LONG2 == INT64_MAX()) {
          $PACKAGE_VAR_MINIMAL2 = TestCase::Minimal->new();
          
          $PACKAGE_VAR_MINIMAL2->{x} = 4;
          
          if ($PACKAGE_VAR_MINIMAL2->{x} == 4) {
            $PACKAGE_VAR_MINIMAL2 = undef;
            return 1;
          }
        }
      }
    }
    return 0;
  }

  sub get_field_exception_object_undef : int () {
    
    my $test_case : TestCase = undef;
    
    eval {
      $test_case->{x_byte};
    }
    if ($@) {
      return 1;
      
      eval {
        $test_case->{x_short};
      }
      
      if ($@) {
        return 1;

        eval {
          $test_case->{x_int};
        }
        
        if ($@) {
          eval {
            $test_case->{x_long};
          }
          
          if ($@) {
            eval {
              $test_case->{x_float};
            }
            
            if ($@) {
              eval {
                $test_case->{x_double};
              }
              
              if ($@) {
                eval {
                  $test_case->{x_test_case};
                }
                
                if ($@) {

                  return 1;
                }
              }
            }
          }
        }

      }
      
    }
    
    return 0;
  }
  
  sub set_field_exception_object_undef : int () {
    
    my $test_case : TestCase = undef;
    
    eval {
      $test_case->{x_byte} = (byte)1;
    }
    if ($@) {
      return 1;
      
      eval {
        $test_case->{x_short} = (short)1;
      }
      
      if ($@) {
        return 1;

        eval {
          $test_case->{x_int} = 1;
        }
        
        if ($@) {
          eval {
            $test_case->{x_long} = 1L;
          }
          
          if ($@) {
            eval {
              $test_case->{x_float} = 1f;
            }
            
            if ($@) {
              eval {
                $test_case->{x_double} = 1d;
              }
              
              if ($@) {
                eval {
                  $test_case->{x_test_case} = undef;
                }
                
                if ($@) {

                  return 1;
                }
              }
            }
          }
        }
      }
      
    }
    
    return 0;
  }
  
  sub get_minimal : TestCase::Minimal ($self : self) {
    return $self->{minimal};
  }

  sub set_minimal : void ($self : self, $value : TestCase::Minimal) {
    $self->{minimal} = $value;
  }

  # Resorved word
  sub int : int ($obj : TestCase) {
    
    return 5;
  }
  
  sub use_reserved_word : int () {
    
    my $test_case = new TestCase;
    
    if (TestCase->int($test_case) == 5) {
      if (TestCase->int($test_case) == 5) {
        return 1;
      }
    }
    
    return 0;
  }
  
  # SPVM set and get
  sub spvm_set_and_get_byte : int ($nums : byte[]) {
    
    if ($nums->[0] == 0) {
      if ($nums->[1] == INT8_MAX()) {
        return 1;
      }
    }
    
    return 0;
  }
  sub spvm_set_and_get_short : int ($nums : short[]) {
    
    if ($nums->[0] == 0) {
      if ($nums->[1] == INT16_MAX()) {
        return 1;
      }
    }
    
    return 0;
  }
  sub spvm_set_and_get_int : int ($nums : int[]) {
    
    if ($nums->[0] == 0) {
      if ($nums->[1] == INT32_MAX()) {
        return 1;
      }
    }
    
    return 0;
  }
  sub spvm_set_and_get_long : int ($nums : long[]) {
    
    if ($nums->[0] == 0L) {
      if ($nums->[1] == INT64_MAX()) {
        return 1;
      }
    }
    
    return 0;
  }
  sub spvm_set_and_get_float : int ($nums : float[]) {
    
    if ($nums->[0] == 0.0f) {
      if ($nums->[1] == FLOAT_PRECICE()) {
        return 1;
      }
    }
    
    return 0;
  }
  sub spvm_set_and_get_double : int ($nums : double[]) {
    
    if ($nums->[0] == 0.0) {
      if ($nums->[1] == DOUBLE_PRECICE()) {
        return 1;
      }
    }
    
    return 0;
  }
  
  sub concat : string () {
    "a" . "b";
    
    my $value = "a" . "b";
    
    return $value;
  }
  
  # string
  sub string_utf8 : string () {
    my $value = "あいうえお";
    
    return $value;
  }
  sub string_empty : string () {
    my $value = "";
    
    return $value;
  }

  sub exception_eval_call_sub : int () {
    eval {
      exception_croak_return_int();
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }
  
  sub exception_call_stack : int () {
    exception_croak_return_int();
  }
  
  sub exception_croak_return_byte : byte () {
    croak "Error";
  }
  
  sub exception_croak_return_short : short () {
    croak "Error";
  }
  
  sub exception_croak_return_int : int () {
    croak "Error";
  }
  
  sub exception_croak_return_long : long () {
    croak "Error";
  }
  
  sub exception_croak_return_float : float () {
    croak "Error";
  }
  
  sub exception_croak_return_double : double () {
    croak "Error";
  }
  
  sub exception_croak_return_object : TestCase::Minimal () {
    croak "Error";
  }
  
  sub exception_croak_return_void : void () {
    croak "Error";
  }

  sub exception_croak_return_int_eval_catch : int () {
    eval {
      croak "Error";
    };
    
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  sub destructor : int () {
    my $minimal = TestCase::Minimal->new();
    destructor_call($minimal);
    
    if ($minimal->{x} == 3) {
      return 1;
    }
    return 0;
  }
  
  sub destructor_call : int ($minimal: TestCase::Minimal) {
    my $dest = TestCase::Destructor->new();
    $dest->{minimal} = $minimal;
  }
  
  sub weaken_target4_weaken_object_assign : int () {
    my $test_case = new TestCase;
    $test_case->{x_int} = 2;
    my $weaken1 = TestCase::Weaken->new();
    my $weaken2 = TestCase::Weaken->new();
    my $weaken3 = TestCase::Weaken->new();
    my $weaken4 = TestCase::Weaken->new();
    
    $test_case->{weaken1} = $weaken1;
    $test_case->{weaken2} = $weaken2;
    $test_case->{weaken3} = $weaken3;
    $test_case->{weaken4} = $weaken4;
    
    $weaken1->{test_case} = $test_case;
    $weaken2->{test_case} = $test_case;
    $weaken3->{test_case} = $test_case;
    $weaken4->{test_case} = $test_case;
    
    $weaken1->weaken_test_case;
    $weaken2->weaken_test_case;
    $weaken3->weaken_test_case;
    $weaken4->weaken_test_case;
    
    $weaken2->{test_case} = undef;
    my $test_case2 = new TestCase;
    $weaken4->{test_case} = $test_case2;
    
    if ($test_case->{x_int} == 2) {
      return 1;
    }
    return 0;
  }
  
  sub weaken_target4 : int () {
    my $test_case = new TestCase;
    $test_case->{x_int} = 2;
    my $weaken1 = TestCase::Weaken->new();
    my $weaken2 = TestCase::Weaken->new();
    my $weaken3 = TestCase::Weaken->new();
    my $weaken4 = TestCase::Weaken->new();
    
    $test_case->{weaken1} = $weaken1;
    $test_case->{weaken2} = $weaken2;
    $test_case->{weaken3} = $weaken3;
    $test_case->{weaken4} = $weaken4;
    
    $weaken1->{test_case} = $test_case;
    $weaken2->{test_case} = $test_case;
    $weaken3->{test_case} = $test_case;
    $weaken4->{test_case} = $test_case;
    
    $weaken1->weaken_test_case;
    $weaken2->weaken_test_case;
    $weaken3->weaken_test_case;
    $weaken4->weaken_test_case;

    if ($test_case->{x_int} == 2) {
      return 1;
    }
    return 0;
  }
  
  sub weaken_weaken_object_undef : int () {
    my $weaken = TestCase::Weaken->new();
    my $test_case = new TestCase;
    $test_case->{x_int} = 2;
    
    $test_case->{x_weaken} = $weaken;
    $weaken->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    $test_case->{x_weaken} = undef;
    
    if ($test_case->{x_weaken} == undef) {
      if ($test_case->{x_int} == 2) {
        return 1;
      }
    }
    return 0;
  }
  
  sub weaken_target_object_undef : int () {
    my $weaken = TestCase::Weaken->new();
    my $test_case = new TestCase;

    $test_case->{x_weaken} = $weaken;
    $weaken->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    $weaken = undef;
    
    if ($test_case->{x_weaken} == undef) {
      return 1;
    }
    return 0;
  }
  
  sub weaken_recursive3 : int () {
    my $weaken = TestCase::Weaken->new();
    my $weaken2 = TestCase::Weaken2->new();
    my $test_case = new TestCase;
    $test_case->{x_weaken} = $weaken;
    $weaken->{weaken2} = $weaken2;
    $weaken2->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    
    return 1;
  }
  
  sub weaken_reference_count1_object : int () {
    my $weaken = TestCase::Weaken->new();
    my $test_case = new TestCase;
    
    $test_case->{x_weaken} = $weaken;
    $weaken = undef;
    weaken $test_case->{x_weaken};
    
    if ($test_case->{x_weaken} == undef) {
      return 1;
    }
    
    return 0;
  }

  sub weaken_recursive_again : void () {
    my $weaken = TestCase::Weaken->new();
    
    # Recuresive reference
    my $test_case = new TestCase;
    $test_case->{x_weaken} = $weaken;
    
    $weaken->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    weaken $test_case->{x_weaken};
  }
  
  sub weaken_recursive : int () {
    my $weaken = TestCase::Weaken->new();
    $weaken->{x1} = 1;
    
    # Recuresive reference
    my $test_case = new TestCase;
    $test_case->{x_weaken} = $weaken;
    $test_case->{x_int} = 2;
    
    $weaken->{test_case} = $test_case;
    
    weaken $test_case->{x_weaken};
    
    if ($weaken->{x1} == 1) {
      if ($test_case->{x_int} == 2) {
        return 1;
      }
    }
    return 0;
  }
  
  sub weaken_self_recuresive : int () {
    my $test_case = new TestCase;
    $test_case->{x_int} = 5;
    
    # Recuresive reference
    $test_case->{x_test_case} = $test_case;
    
    weaken $test_case->{x_test_case};
    
    if ($test_case->{x_int} == 5) {
      return 1;
    }
    
    return 0;
  }

  sub spvm_new_object_array_len_element_byte_array : int ($nums : byte[][]) {
    
    if ($nums->[0][0] == 1) {
      if ($nums->[0][1] == 2) {
        if ($nums->[0][2] == 3) {
          if ($nums->[1][0] == 4) {
            if ($nums->[1][1] == 5) {
              if ($nums->[1][2] == 6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_object_array_len_element_short_array : int ($nums : short[][]) {
    if ((int)$nums->[0][0] == (int)(short)1) {
      if ((int)$nums->[0][1] == (int)(short)2) {
        if ((int)$nums->[0][2] == (int)(short)3) {
          if ((int)$nums->[1][0] == (int)(short)4) {
            if ((int)$nums->[1][1] == (int)(short)5) {
              if ((int)$nums->[1][2] == (int)(short)6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_object_array_len_element_int_array : int ($nums : int[][]) {
    if ($nums->[0][0] == 1) {
      if ($nums->[0][1] == 2) {
        if ($nums->[0][2] == 3) {
          if ($nums->[1][0] == 4) {
            if ($nums->[1][1] == 5) {
              if ($nums->[1][2] == 6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_object_array_len_element_long_array : int ($nums : long[][]) {
    if ($nums->[0][0] == (long)1) {
      if ($nums->[0][1] == (long)2) {
        if ($nums->[0][2] == (long)3) {
          if ($nums->[1][0] == (long)4) {
            if ($nums->[1][1] == (long)5) {
              if ($nums->[1][2] == (long)6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_object_array_len_element_float_array : int ($nums : float[][]) {
    if ($nums->[0][0] == (float)1) {
      if ($nums->[0][1] == (float)2) {
        if ($nums->[0][2] == (float)3) {
          if ($nums->[1][0] == (float)4) {
            if ($nums->[1][1] == (float)5) {
              if ($nums->[1][2] == (float)6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_object_array_len_element_double_array : int ($nums : double[][]) {
    if ($nums->[0][0] == (double)1) {
      if ($nums->[0][1] == (double)2) {
        if ($nums->[0][2] == (double)3) {
          if ($nums->[1][0] == (double)4) {
            if ($nums->[1][1] == (double)5) {
              if ($nums->[1][2] == (double)6) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_object_array_len_element_object_array : int ($nums : TestCase[]) {
    if ($nums->[0]{x_int} == 1) {
      if ($nums->[1]{x_int} == 2) {
        return 1;
      }
    }
    
    return 0;
  }

  # Exception
  sub exception_zero_divide_int : int () {
    1 / 0;
  }

  sub my_var_scope : int () {
    my $ok1 = 0;
    my $ok2 = 0;
    my $ok3 = 0;
    
    my $var1 = 1;
    my $var2 = 2;
    
    if ($var1 == 1) {
      if ($var2 == 2) {
        $ok1 = 1;
      }
    }
    
    {
      my $var1 = 3;
      my $var2 = 4;
      my $var3 = 5;
      
      if ($var1 == 3) {
        if ($var2 == 4) {
          if ($var3 == 5) {
            $ok2 = 1;
          }
        }
      }
    }
    
    my $var3 = 6;
    
    if ($var1 == 1) {
      if ($var2 == 2) {
        if ($var3 == 6) {
          $ok3 = 1;
        }
      }
    }
    
    if ($ok1) {
      if ($ok2) {
        if ($ok3) {
          return 1;
        }
      }
    }
    
    return 0;
  }
  
  # My variable is initialized zero
  sub my_var_initialized_zero : int () {
    my $var1 : int;
    my $var2 : TestCase;
    
    if ($var1 == 0) {
      if ($var2 == undef) {
        return 1;
      }
    }
    return 0;
  }

  sub my_var_block : int () {
    my $success = 1;
    
    my $var1 = 1;
    if ($var1 != 1) {
      $success = 0;
    }
    
    {
      my $var1 = 2;
      if ($var1 != 2) {
        $success = 0;
      }
      
      {
        my $var1 = $var1;
        if ($var1 != 2) {
          $success = 0;
        }
        $var1 = 3;
      }
      if ($var1 != 2) {
        $success = 0;
      }
    }
    
    if ($success) {
      return 1;
    }
    return 0;
  }
  
  # object field is initialized zero
  sub object_field_initialized_zero : int () {
    my $obj = new TestCase;
    if ($obj->{x_byte} == 0) {
      if ($obj->{x_int} == 0) {
        if ($obj->{x_string} == undef) {
          return 1;
        }
      }
    }
    return 0;
  }
  
  # object field set and get
  sub object_field_set_and_get : int () {
    my $test_case = new TestCase;
    
    $test_case->{x_byte} = INT8_MAX();
    $test_case->{x_short} = INT16_MAX();
    $test_case->{x_int} = INT32_MAX();
    $test_case->{x_long} = INT64_MAX();
    $test_case->{x_float} = TestCase->FLOAT_PRECICE();
    $test_case->{x_double} = TestCase->DOUBLE_PRECICE();
    my $minimal = TestCase::Minimal->new();
    $minimal->{x} = 3;
    $test_case->{minimal} = $minimal;
    if ((int)$test_case->{x_byte} == (int)INT8_MAX()) {
      if ((int)$test_case->{x_short} == (int)INT16_MAX()) {
        if ($test_case->{x_int} == INT32_MAX()) {
          if ($test_case->{x_long} == INT64_MAX()) {
            if ($test_case->{x_float} == TestCase->FLOAT_PRECICE()) {
              if ($test_case->{x_double} == TestCase->DOUBLE_PRECICE()) {
                if ($test_case->{minimal}->{x} == 3) {
                  return 1;
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }

  # object field set and get
  sub object_field_set_and_get_again : int () {
    my $test_case = new TestCase;
    
    $test_case->{x_byte} = INT8_MAX();
    $test_case->{x_short} = INT16_MAX();
    $test_case->{x_int} = INT32_MAX();
    $test_case->{x_long} = INT64_MAX();
    $test_case->{x_float} = FLOAT_PRECICE();
    $test_case->{x_double} = DOUBLE_PRECICE();
    my $minimal = TestCase::Minimal->new();
    $minimal->{x} = 3;
    $test_case->{minimal} = $minimal;

    $test_case->{x_byte} = INT8_MAX();
    $test_case->{x_short} = INT16_MAX();
    $test_case->{x_int} = INT32_MAX();
    $test_case->{x_long} = INT64_MAX();
    $test_case->{x_float} = FLOAT_PRECICE();
    $test_case->{x_double} = DOUBLE_PRECICE();
    $test_case->{minimal} = $minimal;

    if ((int)$test_case->{x_byte} == (int)INT8_MAX()) {
      if ((int)$test_case->{x_short} == (int)INT16_MAX()) {
        if ($test_case->{x_int} == INT32_MAX()) {
          if ($test_case->{x_long} == INT64_MAX()) {
            if ($test_case->{x_float} == FLOAT_PRECICE()) {
              if ($test_case->{x_double} == DOUBLE_PRECICE()) {
                if ($test_case->{minimal}->{x} == 3) {
                  return 1;
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }

  # new near small base_object_max_byte_size_use_memory_pool
  sub new_near_small_base_object_max_byte_size_use_memory_pool : int () {
    my $block = new byte[0xFFF0];
    
    return 1;
  }

  sub get_object_from_freelist  : int () {
    get_object_from_freelist_check();
    
    my $result = new int[65];
    $result->[64] = 0;
    
    return 1;
  }
  sub get_object_from_freelist_check : int[] () {
    my $result = new int[63];
    my $true_result = new int[1];
    return $true_result;
  }

  enum {
    INT_ZERO,
    INT_ONE,
    INT_THREE = 3,
    INT_FOUR,
    INT_SIX = 6,
    INT_MINUS_MAX = -2147483648
  }
  sub enum_int  : int () {
    
    if (TestCase->INT_ZERO == 0) {
      if (TestCase->INT_ONE == 1) {
        if (TestCase->INT_THREE == 3) {
          if (TestCase->INT_FOUR == 4) {
            if (TestCase->INT_SIX == 6) {
              if (TestCase->INT_MINUS_MAX == -2147483648) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }
  
  # Convert type - floating point narrowing convertion
  sub convert_float_to_byte : int () {
    my $value = (byte)127.1f;
    
    if ($value == 127) {
      return 1;
    }
    
    return 0;
  }
  sub convert_float_to_short : int () {
    my $value = (short)32767.1f;
    
    if ($value == 32767) {
      return 1;
    }
    
    return 0;
  }
  sub convert_float_to_int : int () {
    my $value = (int)132767.1f;
    
    if ($value == 132767) {
      return 1;
    }
    
    return 0;
  }
  sub convert_float_to_long : int () {
    my $value = (long)132767.1f;
    
    if ($value == 132767L) {
      return 1;
    }
    
    return 0;
  }
  sub convert_double_to_byte : int () {
    my $value = (byte)127.1;
    
    if ($value == 127) {
      return 1;
    }
    
    return 0;
  }
  sub convert_double_to_short : int () {
    my $value = (short)32767.1;
    
    if ((int)$value == (int)(short)32767) {
      return 1;
    }
    
    return 0;
  }
  sub convert_double_to_int : int () {
    my $value = (int)2147483646.1;
    
    if ($value == 2147483646) {
      return 1;
    }
    
    return 0;
  }
  sub convert_double_to_long : int () {
    my $value = (long)2147483646.1;
    
    if ($value == 2147483646L) {
      return 1;
    }
    
    return 0;
  }
  sub convert_double_to_float : int () {
    my $value = (float)0.5;
    
    if ($value == 0.5f) {
      return 1;
    }
    
    return 0;
  }
  
  # Convert type - floating point widning convertion
  sub convert_byte_to_float : int () {
    my $value = (float)(byte)127;
    
    if ($value == 127.0f) {
      return 1;
    }
    
    return 0;
  }
  sub convert_short_to_float : int () {
    my $value = (float)(short)32767;
    
    if ($value == 32767.0f) {
      return 1;
    }
    
    return 0;
  }
  sub convert_int_to_float : int () {
    my $value = (float)32767;
    
    if ($value == 32767.0f) {
      return 1;
    }
    
    return 0;
  }
  sub convert_long_to_float : int () {
    my $value = (float)32767L;
    
    if ($value == 32767.0f) {
      return 1;
    }
    
    return 0;
  }
  sub convert_byte_to_double : int () {
    my $value = (double)(byte)127;
    
    if ($value == 127.0) {
      return 1;
    }
    
    return 0;
  }
  sub convert_short_to_double : int () {
    my $value = (double)(short)32767;
    
    if ($value == 32767.0) {
      return 1;
    }
    
    return 0;
  }
  sub convert_int_to_double : int () {
    my $value = (double)2147483647;
    if ($value == 2147483647.0) {
      return 1;
    }
    
    return 0;
  }
  sub convert_long_to_double : int () {
    my $value = (double)2147483647L;
    
    if ($value == 2147483647.0) {
      return 1;
    }
    
    return 0;
  }
  sub convert_float_to_double : int () {
    my $value = (double)32767.0f;
    
    if ($value == 32767.0) {
      return 1;
    }
    
    return 0;
  }
  
  # Convert type - widning convertion
  sub convert_byte_to_short_plus : int () {
    my $value = (short)(byte)0x7F;
    
    if ((int)$value == (int)(short)0x007F) {
      return 1;
    }
    
    return 0;
  }
  sub convert_byte_to_short_minus : int () {
    my $value = (short)(byte)0xFF;
    
    if ((int)$value == (int)(short)0xFFFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_byte_to_int_plus : int () {
    my $value = (int)(byte)0x7F;
    
    if ($value == 0x0000007F) {
      return 1;
    }
    
    return 0;
  }
  sub convert_byte_to_int_minus : int () {
    my $value = (int)(byte)0xFF;
    
    if ($value == 0xFFFFFFFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_byte_to_long_plus : int () {
    my $value = (long)(byte)0x7F;
    
    if ($value == 0x000000000000007FL) {
      return 1;
    }
    
    return 0;
  }
  sub convert_byte_to_long_minus : int () {
    my $value = (long)(byte)0xFF;
    
    if ($value == 0xFFFFFFFFFFFFFFFFL) {
      return 1;
    }
    
    return 0;
  }
  sub convert_short_to_int_plus : int () {
    my $value = (int)(short)0x7FFF;
    
    if ($value == 0x0000007FFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_short_to_int_minus : int () {
    my $value = (int)(short)0xFFFF;
    
    if ($value == 0xFFFFFFFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_short_to_long_plus : int () {
    my $value = (long)(short)0x7FFF;
    
    if ($value == 0x000000000000007FFFL) {
      return 1;
    }
    
    return 0;
  }
  sub convert_short_to_long_minus : int () {
    my $value = (long)(short)0xFFFF;
    
    if ($value == 0xFFFFFFFFFFFFFFFFL) {
      return 1;
    }
    
    return 0;
  }
  sub convert_int_to_long_plus : int () {
    my $value = (long)0x7FFFFFFF;
    
    if ($value == 0x000000007FFFFFFFL) {
      return 1;
    }
    
    return 0;
  }
  sub convert_int_to_long_minus : int () {
    my $value = (long)0xFFFFFFFF;
    
    if ($value == 0xFFFFFFFFFFFFFFFFL) {
      return 1;
    }
    
    return 0;
  }
  
  # Convert type - convert to same type
  sub convert_long_to_long : int () {
    my $value = (long)0xFFFFFFFFFFFFFFFFL;
    
    if ($value == 0xFFFFFFFFFFFFFFFFL) {
      return 1;
    }
    
    return 0;
  }
  sub convert_int_to_int : int () {
    my $value = (int)0xFFFFFFFF;
    
    if ($value == 0xFFFFFFFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_short_to_short : int () {
    my $value = (short)(short)0xFFFF;
    
    if ((int)$value == (int)(short)0xFFFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_byte_to_byte : int () {
    my $value = (byte)(byte)0xFF;
    
    if ($value == (byte)0xFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_float_to_float : int () {
    my $value = (float)0.5f;
    
    if ($value == 0.5f) {
      return 1;
    }
    
    return 0;
  }
  sub convert_double_to_double : int () {
    my $value = (double)0.5;
    
    if ($value == 0.5) {
      return 1;
    }
    
    return 0;
  }
  
  # Convert type - integral narrowing convertion
  sub convert_long_to_int : int () {
    my $value = (int)0xFFFFFFFFFFFFFFFFL;
    
    if ($value == 0xFFFFFFFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_long_to_short : int () {
    my $value = (short)0xFFFFFFFFFFFFFFFFL;
    
    if ((int)$value == (int)(short)0xFFFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_long_to_byte : int () {
    my $value = (byte)0xFFFFFFFFFFFFFFFFL;
    
    if ((int)$value == (int)(byte)0xFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_int_to_short : int () {
    my $value = (short)0xFFFFFFFF;
    
    if ((int)$value == (int)(short)0xFFFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_int_to_byte : int () {
    my $value = (byte)0xFFFFFFFF;
    
    if ((int)$value == (int)(byte)0xFF) {
      return 1;
    }
    
    return 0;
  }
  sub convert_short_to_byte : int () {
    my $value = (byte)(short)0xFFFF;
    
    if ((int)$value == (int)(byte)0xFF) {
      return 1;
    }
    
    return 0;
  }
  
  sub spvm_object_set_object : int ($obj : TestCase) {
    my $nums = $obj->{x_int_array};
    my $values = ($obj->{x_string});
    
    
    # [INT32_MAX, INT32_MAX]
    if (@$nums == 2) {
      if ($nums->[0] == 2147483647) {
        if ($nums->[1] == 2147483647) {
          # abc
          if ($values->[0] == 97) {
            if ($values->[1] == 98) {
              if ($values->[2] == 99) {
                if (@$values == 3) {
                  return 1;
                }
              }
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub spvm_object_set : int ($obj : TestCase) {
    if ($obj->{x_byte} == 127) {
      if ($obj->{x_short} == 32767) {
        if ($obj->{x_int} == 2147483647) {
          if ($obj->{x_long} == 9223372036854775807L) {
            if ($obj->{x_float} == FLOAT_PRECICE()) {
              if ($obj->{x_double} == DOUBLE_PRECICE()) {
                if ($obj->{minimal}->{x} == 3) {
                  return 1;
                }
              }
            }
          }
        }
      }
    }
    
    return 0;
  }
  
  sub logical_not_true : int () {
    if (!1) {
      return 0;
    }
    
    return 1;
  }
  sub logical_not_false : int () {
    if (!0) {
      return 1;
    }
    
    return 0;
  }

  # logical or
  sub logical_or_both_true : int () {
    if (1 || 1) {
      return 1;
    }
    
    return 0;
  }
  
  sub logical_or_left_true : int () {
    if (1 || 0) {
      return 1;
    }
    
    return 0;
  }

  sub logical_or_right_true : int () {
    if (0 || 1) {
      return 1;
    }
    
    return 0;
  }

  sub logical_or_both_false : int () {
    if (0 || 0) {
      return 0;
    }
    
    return 1;
  }
  
  # logical and
  sub logical_and_both_true : int () {
    if (1 && 1) {
      return 1;
    }
    
    return 0;
  }
  
  sub logical_and_left_true : int () {
    if (1 && 0) {
      return 0;
    }
    
    return 1;
  }

  sub logical_and_right_true : int () {
    if (1 && 0) {
      return 0;
    }
    
    return 1;
  }

  sub logical_and_both_false : int () {
    if (0 && 0) {
      return 0;
    }
    
    return 1;
  }
  
  
  
  # SPVM Functions
  sub spvm_new_byte_array_string : int ($values : byte[]) {
    
    if ((int)$values->[0] == (int)(byte)0xE3) {
      if ((int)$values->[1] == (int)(byte)0x81) {
        if ((int)$values->[2] == (int)(byte)0x82) {
          if (@$values == 3) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_byte_array_bin : int ($values : byte[]) {
    
    if ($values->[0] == 97) {
      if ($values->[1] == 98) {
        if ($values->[2] == 99) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_byte_array_bin_pack : int ($values : byte[]) {
    
    if ($values->[0] == 97) {
      if ($values->[1] == 98) {
        if ($values->[2] == INT8_MAX()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_short_array_bin_pack : int ($values : short[]) {
    
    if ((int)$values->[0] == (int)(short)97) {
      if ((int)$values->[1] == (int)(short)98) {
        if ((int)$values->[2] == (int)(short)INT16_MAX()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }
  
  sub spvm_new_int_array_bin_pack : int ($values : int[]) {
    
    if ($values->[0] == (int)97) {
      if ($values->[1] == (int)98) {
        if ($values->[2] == (int)INT32_MAX()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_long_array_bin_pack : int ($values : long[]) {
    
    if ($values->[0] == (long)97) {
      if ($values->[1] == (long)98) {
        if ($values->[2] == (long)INT64_MAX()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }

  sub spvm_new_float_array_bin_pack : int ($values : float[]) {
    
    if ($values->[0] == (float)97) {
      if ($values->[1] == (float)98) {
        if ($values->[2] == (float)FLOAT_PRECICE()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }
  
  sub spvm_new_double_array_bin_pack : int ($values : double[]) {
    
    if ($values->[0] == (double)97) {
      if ($values->[1] == (double)98) {
        if ($values->[2] == (double)DOUBLE_PRECICE()) {
           if (@$values == 3) {
             return 1;
           }
        }
      }
    }
    
    return 0;
  }
  


  # constant int
  sub load_constant_int_min : int () {
   # LOAD_CONSTANT
    return -2147483647;
  }
  sub load_constant_int_m32769 : int () {
    # LOAD_CONSTANT
    return -32769;
  }
  sub load_constant_int_m32768 : int () {
    # PUSH_SHORT_TO_INT
    return -32768;
  }
  sub load_constant_int_m129 : int () {
    # PUSH_SHORT_TO_INT
    return -129;
  }
  sub load_constant_int_m128 : int () {
    # PUSH_BYTE_TO_INT
    return -128;
  }
  sub load_constant_int_m2 : int () {
    # PUSH_BYTE_TO_INT
    return -2;
  }
  sub load_constant_int_m1 : int () {
    # CONSTANT_INT_M1
    return -1;
  }
  sub load_constant_int_0 : int () {
    # CONSTANT_INT_0
    return 0;
  }
  sub load_constant_int_1 : int () {
    # CONSTANT_INT_1
    return 1;
  }
  sub load_constant_int_2 : int () {
    # CONSTANT_INT_2
    return 2;
  }
  sub load_constant_int_3 : int () {
    # CONSTANT_INT_3
    return 3;
  }
  sub load_constant_int_4 : int () {
    # CONSTANT_INT_4
    return 4;
  }
  sub load_constant_int_5 : int () {
    # CONSTANT_INT_5
    return 5;
  }
  sub load_constant_int_6 : int () {
    # PUSH_BYTE_TO_INT
    return 6;
  }
  sub load_constant_int_127 : int () {
    # PUSH_BYTE_TO_INT
    return 127;
  }
  sub load_constant_int_128 : int () {
    # PUSH_SHORT_TO_INT
    return 128;
  }
  sub load_constant_int_32767 : int () {
    # PUSH_SHORT_TO_INT
    return 32767;
  }
  sub load_constant_int_32768 : int () {
    # LOAD_CONSTANT
    return 32768;
  }
  sub load_constant_int_max : int () {
    # LOAD_CONSTANT
    return 2147483647;
  }

  # constant long
  sub load_constant_long_min : long () {
   # LOAD_CONSTANT
    return -9223372036854775808L;
  }
  sub load_constant_long_m32769 : long () {
    # LOAD_CONSTANT
    return -32769L;
  }
  sub load_constant_long_m32768 : long () {
    # PUSH_SHORT_TO_LONG
    return -32768L;
  }
  sub load_constant_long_m129 : long () {
    # PUSH_SHORT_TO_LONG
    return -129L;
  }
  sub load_constant_long_m128 : long () {
    # PUSH_BYTE_TO_LONG
    return -128L;
  }
  sub load_constant_long_m2 : long () {
    # PUSH_BYTE_TO_LONG
    return -2L;
  }
  sub load_constant_long_m1 : long () {
    # CONSTANT_LONG_M1
    return -1L;
  }
  sub load_constant_long_0 : long () {
    # CONSTANT_LONG_0
    return 0L;
  }
  sub load_constant_long_1 : long () {
    # CONSTANT_LONG_1
    return 1L;
  }
  sub load_constant_long_2 : long () {
    # CONSTANT_LONG_2
    return 2L;
  }
  sub load_constant_long_3 : long () {
    # CONSTANT_LONG_3
    return 3L;
  }
  sub load_constant_long_4 : long () {
    # CONSTANT_LONG_4
    return 4L;
  }
  sub load_constant_long_5 : long () {
    # CONSTANT_LONG_5
    return 5L;
  }
  sub load_constant_long_6 : long () {
    # PUSH_BYTE_TO_LONG
    return 6L;
  }
  sub load_constant_long_127 : long () {
    # PUSH_BYTE_TO_LONG
    return 127L;
  }
  sub load_constant_long_128 : long () {
    # PUSH_SHORT_TO_LONG
    return 128L;
  }
  sub load_constant_long_32767 : long () {
    # PUSH_SHORT_TO_LONG
    return 32767L;
  }
  sub load_constant_long_32768 : long () {
    # LOAD_CONSTANT2
    return 32768L;
  }
  sub load_constant_long_max : long () {
    # LOAD_CONSTANT2
    return 9223372036854775807L;
  }
  
  # constant float
  sub load_constant_float_0 : float () {
    # CONSTANT_FLOAT_0
    return 0.0f;
  }
  sub load_constant_float_1 : float () {
    # CONSTANT_FLOAT_1
    return 1.0f;
  }
  sub load_constant_float_0_5 : float () {
    # LOAD_CONSTANT
    return 0.5f;
  }
  sub load_constant_float_exponent_E_plus : float () {
    return 0.5E+3f;
  }
  sub load_constant_float_exponent_e_plus : float () {
    return 0.5e3f;
  }
  sub load_constant_float_exponent_E_minus : float () {
    return 62.5E-3f;
  }
  sub load_constant_float_exponent_e_minus : float () {
    return 62.5e-3f;
  }

  sub load_constant_double_exponent_E_plus : double () {
    return 0.5E+3;
  }
  sub load_constant_double_exponent_e_plus : double () {
    return 0.5e3;
  }
  sub load_constant_double_exponent_E_minus : double () {
    return 62.5E-3;
  }
  sub load_constant_double_exponent_e_minus : double () {
    return 62.5e-3;
  }
  
  # constant double
  sub load_constant_double_0 : double () {
    # CONSTANT_DOUBLE_0
    return 0.0;
  }
  sub load_constant_double_1 : double () {
    # CONSTANT_DOUBLE_1
    return 1.0;
  }
  sub load_constant_double_0_5 : double () {
    # LOAD_CONSTANT2
    return 0.5;
  }
  
  sub literal_character : int () {
    my $value = 'a';
    
    return 1;
  }
  
  sub number_literal_specifier : int () {
    my $value1 = 255f;
    my $value2 = 255d;
    my $value3 = 255L;
    my $value4 = (byte)-128;
    my $value5 = (short)-32768;
    my $value6 = (byte)127;
    my $value7 = (short)-128;
    
    if ($value1 == (float)255) {
      if ($value2 == (double)255) {
        if ($value3 == (long)255) {
          if ($value4 == -1) {
            if ($value5 == -1) {
              if ($value6 == 127) {
                if ($value7 == 32767) {
                  return 1;
                }
              }
            }
          }
        }
      }
    }
    
    return 0;
  }
  
  sub number_literal_underline : int () {
    my $value = 123_123;
    
    if ($value == 123123) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  sub number_literal_hex_specifier : int () {
    my $value3 = 0xFFL;
    my $value4 = (byte)0xFF;
    my $value5 = (short)0xFFFF;
    my $value6 = (byte)0x7F;
    my $value7 = (short)0x7FFF;
    
    if ($value3 == (long)255) {
      if ($value4 == -1) {
        if ($value5 == -1) {
          if ($value6 == 127) {
            if ($value7 == 32767) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }
  sub number_literal_hex_all_number : int () {
    my $value1 = 0x01234567;
    my $value2 = 0x00ABCDEF;
    my $value3 = 0x00abcdef;
    
    if ($value1 == 19088743) {
      if ($value2 == 11259375) {
        if ($value3 == 11259375) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  sub number_literal_underline_hex : int () {
    my $value = 0xFF_FF;
    
    if ($value == 0xFFFF) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  sub number_literal_hex_int : int () {
    my $value = 0xFF;
    
    if ($value == 255) {
      return 1;
    }
    else {
      return 0;
    }
  }
  sub number_literal_hex_int_max : int () {
    # 11111111 11111111 11111111 11111111
    my $value = 0xFFFFFFFF;
    
    if ($value == -1) {
      return 1;
    }
    else {
      return 0;
    }
  }
  sub number_literal_hex_long_max : int () {
    # 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111
    my $value = 0xFFFFFFFFFFFFFFFFL;
    
    if ($value == -1L) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub number_literal_octal_specifier : int () {
    my $value3 = 0377L;
    my $value4 = (byte)0377;
    my $value5 = (short)0177777;
    my $value6 = (byte)0177;
    my $value7 = (short)077777;
    
    if ($value3 == (long)255) {
      if ($value4 == -1) {
        if ($value5 == -1) {
          if ($value6 == 127) {
            if ($value7 == 32767) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub number_literal_octal_all_number : int () {
    my $value1 = 0110642547;
    
    if ($value1 == 19088743) {
      return 1;
    }
    
    return 0;
  }

  sub number_literal_binary_specifier : int () {
    my $value3 = 0b11111111L;
    my $value4 = (byte)0b11111111;
    my $value5 = (short)0b1111111111111111;
    my $value6 = (byte)0b1111111;
    my $value7 = (short)0b111111111111111;
    
    if ($value3 == (long)255) {
      if ($value4 == -1) {
        if ($value5 == -1) {
          if ($value6 == 127) {
            if ($value7 == 32767) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }
  sub number_literal_binary_all_number : int () {
    my $value1 = 0b1001000110100010101100111;
    
    if ($value1 == 19088743) {
      return 1;
    }
    
    return 0;
  }

  sub number_literal_underline_binary : int () {
    my $value = 0b11111111_11111111;
    
    if ($value == 0b1111111111111111) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  sub number_literal_binary_int : int () {
    my $value = 0b11111111;
    
    if ($value == 255) {
      return 1;
    }
    else {
      return 0;
    }
  }
  sub number_literal_binary_int_max : int () {
    # 11111111 11111111 11111111 11111111
    my $value = 0b11111111111111111111111111111111;
    
    if ($value == -1) {
      return 1;
    }
    else {
      return 0;
    }
  }
  sub number_literal_binary_long_max : int () {
    # 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111
    my $value = 0b1111111111111111111111111111111111111111111111111111111111111111L;
    
    if ($value == -1L) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  sub number_literal_underline_octal : int () {
    my $value = 0177_777;
    
    if ($value == 0177777) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  sub number_literal_octal_int : int () {
    my $value = 0377;
    
    if ($value == 255) {
      return 1;
    }
    else {
      return 0;
    }
  }
  sub number_literal_octal_int_max : int () {
    # 11111111 11111111 11111111 11111111
    my $value = 037777777777;
    
    if ($value == -1) {
      return 1;
    }
    else {
      return 0;
    }
  }
  sub number_literal_octal_long_max : int () {
    # 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111
    my $value = 01777777777777777777777L;
    
    if ($value == -1L) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  
  # Sum
  sub sum_byte : byte ($a : byte, $b :byte,) {
    
    my $total = (byte)((int)$a + (int)$b);
    
    return $total;
  }

  sub sum_short : short ($a : short, $b :short) {
    
    my $total = (short)((int)$a + (int)$b);
    
    return $total;
  }

  sub sum_int : int ($a : int, $b :int) {
    
    my $total = $a + $b;
    
    return $total;
  }

  sub sum_long : long ($a : long, $b :long) {
    
    my $total = $a + $b;
    
    return $total;
  }

  sub sum_float : float ($a : float, $b :float) {
    
    my $total = $a + $b;
    
    return $total;
  }

  sub sum_double : double ($a : double, $b :double) {
    
    my $total = $a + $b;
    
    return $total;
  }
  
  # For
  sub for_basic : int () {
  
    my $success_basic = 0;
    {
      my $total = 0;
      for (my $i = 1; $i <= 3; $i++) {
        $total = $total + $i;
      }
      
      if ($total == 6) {
        $success_basic = 1;
      }
    }
    
    my $success_last = 0;
    {
      my $total = 0;
      for (my $i = 0; $i < 10; $i++) {
        if ($i == 5) {
          last;
        }
        $total = $total + $i;
      }
      
      if ($total == 10) {
        $success_last = 1;
      }
    }

    my $success_next = 0;
    {
      my $total = 0;
      for (my $i = 0; $i < 10; $i++) {
        if ($i == 5) {
          next;
        }
        $total = $total + $i;
      }
      
      if ($total == 40) {
        $success_next = 1;
      }
    }

    my $success_while = 0;
    {
      my $total = 0;
      my $i = 0;
      while ($i <= 3) {
        $total = $total + $i;
        $i++;
      }
      
      if ($total == 6) {
        $success_while = 1;
      }
    }
    
    # Check also object count
    my $success_last_object = 0;
    {
      my $total = 0;
      for (my $i = 0; $i < 10; $i++) {
        my $minimal = TestCase::Minimal->new();
        if ($i == 5) {
          last;
        }
        $total = $total + $i;
      }
      
      if ($total == 10) {
        $success_last_object = 1;
      }
    }

    # Check also object count
    my $success_next_object = 0;
    {
      my $total = 0;
      for (my $i = 0; $i < 10; $i++) {
        my $minimal = TestCase::Minimal->new();
        if ($i == 5) {
          next;
        }
        $total = $total + $i;
      }
      
      if ($total == 40) {
        $success_next_object = 1;
      }
    }
    
    if ($success_basic) {
      if ($success_last) {
        if ($success_next) {
          if ($success_while) {
            if ($success_last_object) {
              if ($success_next_object) {
                return 1;
              }
            }
          }
        }
      }
    }
    
    return 0;
  }
}
