package TestCase::Math {
  use SPVM::Math;
  
  sub sin : int () {
    my $value = SPVM::Math->sin(SPVM::Math->PI());
    
    if ($value < 0.000001 && $value > -0.000001) {
      return 1;
    }
    return 0;
  }

  sub cos : int () {
    my $value = SPVM::Math->cos(SPVM::Math->PI() / 2.0);
    
    if ($value < 0.000001 && $value > -0.000001) {
      return 1;
    }
    return 0;
  }
  
  sub tan : int () {
    my $value = SPVM::Math->tan(SPVM::Math->PI() / 4.0);
    
    if ($value - 1.0 < 0.000001 && $value - 1.0 > -0.000001) {
      return 1;
    }
    return 0;
  }

  sub isinff: int () {
    if (SPVM::Math->isinff(SPVM::Math->INFINITYF())) {
      if (!SPVM::Math->isinff(SPVM::Math->NANF())) {
        if (!SPVM::Math->isinff(0.1f)) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  sub isfinitef: int () {
    if (!SPVM::Math->isfinitef(SPVM::Math->INFINITYF())) {
      if (!SPVM::Math->isfinitef(SPVM::Math->NANF())) {
        if (SPVM::Math->isfinitef(0.1f)) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  sub isnanf: int () {
    if (!SPVM::Math->isnanf(SPVM::Math->INFINITYF())) {
      if (SPVM::Math->isnanf(SPVM::Math->NANF())) {
        if (!SPVM::Math->isnanf(0.1f)) {
          return 1;
        }
      }
    }
    
    return 0;
  }
  
  sub float_pass_positive_infinity : int ($value : float) {
    if ($value == SPVM::Math->INFINITYF()) {
      return 1;
    }
    
    return 0;
  }
  
  sub float_pass_nan : int ($value : float) {
    if (SPVM::Math->isnanf($value)) {
      return 1;
    }
    
    return 0;
  }

  sub isinf : int () {
    if (SPVM::Math->isinf(SPVM::Math->INFINITY())) {
      if (!SPVM::Math->isinf(SPVM::Math->NAN())) {
        if (!SPVM::Math->isinf(0.1)) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  sub isfinite : int () {
    if (!SPVM::Math->isfinite(SPVM::Math->INFINITY())) {
      if (!SPVM::Math->isfinite(SPVM::Math->NAN())) {
        if (SPVM::Math->isfinite(0.1)) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  sub isnan : int () {
    if (!SPVM::Math->isnan(SPVM::Math->INFINITY())) {
      if (SPVM::Math->isnan(SPVM::Math->NAN())) {
        if (!SPVM::Math->isnan(0.1)) {
          return 1;
        }
      }
    }
    
    return 0;
  }
  
  sub double_pass_nan : int ($value : double) {
    if (SPVM::Math->isnan($value)) {
      return 1;
    }
    
    return 0;
  }
  
  sub double_pass_positive_infinity : int ($value : double) {
    if ($value == SPVM::Math->INFINITY()) {
      return 1;
    }
    
    return 0;
  }

  sub byte_constant : int () {
    if ((int)SPVM::Math->INT8_MIN() == (int)(byte)-128) {
      if ((int)SPVM::Math->INT8_MAX() == (int)(byte)127) {
        return 1;
      }
    }
    
    return 0;
  }

  sub short_constant : int () {
    if ((int)SPVM::Math->INT16_MIN() == (int)(short)-32768) {
      if ((int)SPVM::Math->INT16_MAX() == (int)(short)32767) {
        return 1;
      }
    }
    
    return 0;
  }

  sub int_constant : int () {
    if (SPVM::Math->INT32_MIN() == -2147483648) {
      if (SPVM::Math->INT32_MAX() == 2147483647) {
        return 1;
      }
    }
    
    return 0;
  }

  sub long_constant : int () {
    if (SPVM::Math->INT64_MIN() == -9223372036854775808L) {
      if (SPVM::Math->INT64_MAX() == 9223372036854775807L) {
        return 1;
      }
    }
    
    return 0;
  }
}
