package TestCase::ValueTArray {
  use TestCase::Point_b3;
  use TestCase::Point_s3;
  use TestCase::Point_i3;
  use TestCase::Point_l3;
  use TestCase::Point_f3;
  use TestCase::Point_d3;
  
  sub store_fetch_byte : int () {
    my $nums = new TestCase::Point_b3[10];
    $nums->[9]{x} = (byte)INT8_MIN();
    $nums->[9]{y} = (byte)(INT8_MIN() + 1);
    $nums->[9]{z} = (byte)(INT8_MIN() + 2);
    
    my $x = $nums->[9]{x};
    my $y = $nums->[9]{y};
    my $z = $nums->[9]{z};
    
    if ($x == INT8_MIN() && $y == (INT8_MIN() + 1) && $z == (INT8_MIN() + 2)) {
      return 1;
    }
    
    return 0;
  }

  sub store_fetch_short : int () {
    
    my $nums = new TestCase::Point_s3[10];
    $nums->[9]{x} = (short)INT16_MIN();
    $nums->[9]{y} = (short)(INT16_MIN() + 1);
    $nums->[9]{z} = (short)(INT16_MIN() + 2);
    
    my $x = $nums->[9]{x};
    my $y = $nums->[9]{y};
    my $z = $nums->[9]{z};
    
    if ($x == INT16_MIN() && $y == (INT16_MIN() + 1) && $z == (INT16_MIN() + 2)) {
      return 1;
    }
    
    return 0;
  }
  
  sub store_fetch_int : int () {
    my $nums = new TestCase::Point_i3[10];
    $nums->[9]{x} = INT32_MIN();
    $nums->[9]{y} = INT32_MIN() + 1;
    $nums->[9]{z} = INT32_MIN() + 2;
    
    my $x = $nums->[9]{x};
    my $y = $nums->[9]{y};
    my $z = $nums->[9]{z};
    
    if ($x == INT32_MIN() && $y == (INT32_MIN() + 1) && $z == (INT32_MIN() + 2)) {
      return 1;
    }
    
    return 0;
  }

  sub store_fetch_long : int () {
    my $nums = new TestCase::Point_l3[10];
    $nums->[9]{x} = INT64_MIN();
    $nums->[9]{y} = INT64_MIN() + 1;
    $nums->[9]{z} = INT64_MIN() + 2;
    
    my $x = $nums->[9]{x};
    my $y = $nums->[9]{y};
    my $z = $nums->[9]{z};
    
    if ($x == INT64_MIN() && $y == (INT64_MIN() + 1) && $z == (INT64_MIN() + 2)) {
      return 1;
    }
    
    return 0;
  }

}
