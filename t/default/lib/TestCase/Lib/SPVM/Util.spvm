package TestCase::Lib::SPVM::Util {
  use SPVM::Util(joino, split, copy_oarray, equals_oarray, sprintf);
  use TestCase::Minimal;

  sub test_equals_oarray : int () {
    my $minimal1 = TestCase::Minimal->new;
    my $minimal2 = TestCase::Minimal->new;
    my $minimal3 = TestCase::Minimal->new;
    my $minimal4 = TestCase::Minimal->new;
    my $nums1 = [$minimal1, $minimal2, $minimal3];
    my $nums2 = [$minimal1, $minimal2, $minimal3];
    my $nums3 = [$minimal1, $minimal2];
    my $nums4 = [$minimal1, $minimal2, $minimal4];
    my $nums5 = [(object)$minimal1, $minimal2, $minimal3];

    my $equality_checker = sub : int ($self : self, $obj1 : object, $obj2 : object) {
      my $minimal1 = (TestCase::Minimal)$obj1;
      my $minimal2 = (TestCase::Minimal)$obj2;
      
      if ($minimal1 == $minimal2) {
        return 1;
      }
      else {
        return 0;
      }
    };
    
    {
      my $is_equals = equals_oarray($nums1, $nums2, $equality_checker);
      unless ($is_equals) {
        return 0;
      }
    }
    {
      my $is_equals = equals_oarray($nums1, $nums3, $equality_checker);
      if ($is_equals) {
        return 0;
      }
    }
    {
      my $is_equals = equals_oarray($nums1, $nums4, $equality_checker);
      if ($is_equals) {
        return 0;
      }
    }
    {
      my $is_equals = equals_oarray($nums1, $nums5, $equality_checker);
      unless ($is_equals) {
        return 0;
      }
    }
    
    return 1;
  }

  sub test_copy_oarray : int () {
    my $objects = [(object)SPVM::Int->new(1), SPVM::Int->new(2), SPVM::Int->new(INT32_MIN())];
    my $objects_out = copy_oarray($objects, sub : object ($self : self, $obj : object) {
      my $int_obj = (SPVM::Int)$obj;
      my $new_int_obj = SPVM::Int->new($int_obj->val);
      return $new_int_obj;
    });

    if ($objects->[0] == $objects_out->[0]) {
      return 0;
    }
    
    if ($objects->[1] == $objects_out->[1]) {
      return 0;
    }
    
    if ($objects->[2] == $objects_out->[2]) {
      return 0;
    }
    
    unless ((int)$objects_out->[0] == 1) {
      return 0;
    }
    
    unless ((int)$objects_out->[1] == 2) {
      return 0;
    }
    
    unless ((int)$objects_out->[2] == INT32_MIN()) {
      return 0;
    }
    
    unless (@$objects_out == 3) {
      return 0;
    }
    
    unless ($objects != $objects_out) {
      return 0;
    }
    
    return 1;
  }
  
  sub test_joino : int () {
    
    my $minimals = [
      TestCase::Minimal->newp(1, 2),
      TestCase::Minimal->newp(3, 4),
      TestCase::Minimal->newp(5, 6)
    ];
    
    my $join = joino(",", $minimals, sub : string ($self : self, $obj : object) {
      my $minimal = (TestCase::Minimal)$obj;
      my $x = $minimal->x;
      my $y = $minimal->y;
      my $str = "($x,$y)";
      return $str;
    });
    
    if ($join eq "(1,2),(3,4),(5,6)") {
      return 1;
    }
    
    return 0;
  }

  sub test_split : int () {
    {
      my $str = "foo,bar,baz";
      my $split_strs = split(",", $str);
      unless (equals_strarray($split_strs, ["foo", "bar", "baz"])) {
        return 0;
      }
    }
    
    {
      my $str = "foo,bar,";
      my $split_strs = split(",", $str);
      unless (equals_strarray($split_strs, ["foo", "bar", ""])) {
        return 0;
      }
    }

    {
      my $str = ",foo,,bar,,";
      my $split_strs = split(",", $str);
      unless (equals_strarray($split_strs, ["", "foo", "", "bar", "", ""])) {
        return 0;
      }
    }

    {
      my $str = "foo : bar : baz";
      my $split_strs = split(" : ", $str);
      unless (equals_strarray($split_strs, ["foo", "bar", "baz"])) {
        return 0;
      }
    }
    {
      my $str = "foo : bar : ";
      my $split_strs = split(" : ", $str);
      unless (equals_strarray($split_strs, ["foo", "bar", ""])) {
        return 0;
      }
    }
    {
      my $str = " : foo :  : bar :  : ";
      my $split_strs = split(" : ", $str);
      unless (equals_strarray($split_strs, ["", "foo", "", "bar", "", ""])) {
        return 0;
      }
    }

    {
      my $str = "foo---bar---baz";
      my $split_strs = split("---", $str);
      unless (equals_strarray($split_strs, ["foo", "bar", "baz"])) {
        return 0;
      }
    }
    {
      my $str = "foo---bar---";
      my $split_strs = split("---", $str);
      unless (equals_strarray($split_strs, ["foo", "bar", ""])) {
        return 0;
      }
    }
    {
      my $str = "---foo------bar------";
      my $split_strs = split("---", $str);
      unless (equals_strarray($split_strs, ["", "foo", "", "bar", "", ""])) {
        return 0;
      }
    }

    {
      my $str = "foo--!bar---baz";
      my $split_strs = split("---", $str);
      unless (equals_strarray($split_strs, ["foo--!bar", "baz"])) {
        return 0;
      }
    }
    return 1;
  }

  sub test_sprintf_d : int () {
    my $tests = [
        [ sprintf("abc%d", 123),          "abc123"  ],
        [ sprintf("%dabc", 123),          "123abc"  ],
        [ sprintf("%dabc%d", 1, 10),      "1abc10"  ],
        [ sprintf("%d%d%d", 1, 10, 100),  "110100"  ],
    ];
    for (my $i = 0; $i < @$tests; ++$i) {
      unless ($tests->[$i][0] eq $tests->[$i][1]) {
        warn("got: '" . $tests->[$i][0] . "', expected: '" . $tests->[$i][1] . "'");
        return 0;
      }
    }
    {
      eval {
        sprintf("%d", "str");
      };
      unless ($@ && contains($@, "Can't cast")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    return 1;
  }

  sub test_sprintf_ld : int () {
    my $tests = [
        [ sprintf("abc%ld", 10000000000L),                                "abc10000000000"                    ],
        [ sprintf("%ldabc", 10000000000L),                                "10000000000abc"                    ],
        [ sprintf("%ldabc%ld", 10000000000L, 20000000000L),               "10000000000abc20000000000"         ],
        [ sprintf("%ld%ld%ld", 10000000000L, 20000000000L, 30000000000L), "100000000002000000000030000000000" ],
    ];
    for (my $i = 0; $i < @$tests; ++$i) {
      unless ($tests->[$i][0] eq $tests->[$i][1]) {
        warn("got: '" . $tests->[$i][0] . "', expected: '" . $tests->[$i][1] . "'");
        return 0;
      }
    }
    {
      eval {
        sprintf("%ld", "str");
      };
      unless ($@ && contains($@, "Can't cast")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    {
      eval {
        sprintf("%l", 1L);
      };
      unless ($@ && contains($@, "Invalid conversion in sprintf: \"%l\"")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    return 1;
  }

  sub test_sprintf_f : int () {
    my $tests = [
        [ sprintf("abc%f", 3.14),               "abc3.14"       ],
        [ sprintf("%fabc", 3.14),               "3.14abc"       ],
        [ sprintf("%fabc%f", 3.14, 2.71),       "3.14abc2.71"   ],
        [ sprintf("%f%f%f", 3.14, 2.71, 2.67),  "3.142.712.67"  ],
    ];
    for (my $i = 0; $i < @$tests; ++$i) {
      unless ($tests->[$i][0] eq $tests->[$i][1]) {
        warn("got: '" . $tests->[$i][0] . "', expected: '" . $tests->[$i][1] . "'");
        return 0;
      }
    }
    {
      eval {
        sprintf("%f", "str");
      };
      unless ($@ && contains($@, "Can't cast")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    return 1;
  }

  sub test_sprintf_c : int () {
    my $tests = [
        [ sprintf("abc%c", 'x'),            "abcx"  ],
        [ sprintf("%cabc", 'x'),            "xabc"  ],
        [ sprintf("%cabc%c", 'x', 'y'),     "xabcy" ],
        [ sprintf("%c%c%c", 'x', 'y', 'z'), "xyz"   ],
    ];
    for (my $i = 0; $i < @$tests; ++$i) {
      unless ($tests->[$i][0] eq $tests->[$i][1]) {
        warn("got: '" . $tests->[$i][0] . "', expected: '" . $tests->[$i][1] . "'");
        return 0;
      }
    }
    {
      eval {
        sprintf("%c", "str");
      };
      unless ($@ && contains($@, "Can't cast")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    return 1;
  }

  sub test_sprintf_s : int () {
    my $tests = [
        [ sprintf("abc%s", "ABC"),                "abcABC"    ],
        [ sprintf("%sabc", "ABC"),                "ABCabc"    ],
        [ sprintf("%sabc%s", "ABC", "XYZ"),       "ABCabcXYZ" ],
        [ sprintf("%s%s%s", "ABC", "XYZ", "123"), "ABCXYZ123" ],
    ];
    for (my $i = 0; $i < @$tests; ++$i) {
      unless ($tests->[$i][0] eq $tests->[$i][1]) {
        warn("got: '" . $tests->[$i][0] . "', expected: '" . $tests->[$i][1] . "'");
        return 0;
      }
    }
    {
      eval {
        sprintf("%s", 1);
      };
      unless ($@ && contains($@, "Can't cast")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    return 1;
  }

  sub test_sprintf_all : int () {
    {
      # Invalid conversion (end of string)
      eval {
        sprintf("%d%", 1);
      };
      unless ($@ && contains($@, "Invalid conversion in sprintf: end of string")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    {
      # Invalid conversion (unknown specifier)
      eval {
        sprintf("%d%k", 1, 2);
      };
      unless ($@ && contains($@, "Invalid conversion in sprintf: \"%k\"")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    {
      # Redundant argument
      eval {
        sprintf("%d", 1, 2);
      };
      unless ($@ && contains($@, "Redundant argument in sprintf")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    {
      # Missing argument
      eval {
        sprintf("%d%d", 1);
      };
      unless ($@ && contains($@, "Missing argument in sprintf")) {
        warn("got error: $@");
        return 0;
      }
      $@ = undef;
    }
    return 1;
  }
}
