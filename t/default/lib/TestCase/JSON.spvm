package TestCase::JSON {
  use SPVM::JSON;
  use SPVM::List;
  use SPVM::Int;
  use SPVM::Double;
  use SPVM::Bool;

  # TODO: Extract _object_equals, _hash_equals and _list_equals as test utilities, something like Test::More::is_deeply
  sub _object_equals : int ($lhs : object, $rhs : object) {
    if ($lhs isa SPVM::Hash) {
      unless ($rhs isa SPVM::Hash) {
        return 0;
      }
      my $x = (SPVM::Hash)$lhs;
      my $y = (SPVM::Hash)$rhs;
      unless (_hash_equals($x, $y)) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::List) {
      unless ($rhs isa SPVM::List) {
        return 0;
      }
      my $x = (SPVM::List)$lhs;
      my $y = (SPVM::List)$rhs;
      unless (_list_equals($x, $y)) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::Int) {
      unless ($rhs isa SPVM::Int) {
        return 0;
      }
      my $x = (SPVM::Int)$lhs;
      my $y = (SPVM::Int)$rhs;
      unless ($x->val == $y->val) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::Double) {
      unless ($rhs isa SPVM::Double) {
        return 0;
      }
      my $x = (SPVM::Double)$lhs;
      my $y = (SPVM::Double)$rhs;
      unless ($x->val == $y->val) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::Bool) {
      unless ($rhs isa SPVM::Bool) {
        return 0;
      }
      my $x = (SPVM::Bool)$lhs;
      my $y = (SPVM::Bool)$rhs;
      unless ($x->val == $y->val) {
        return 0;
      }
    }
    elsif ($lhs isa string) {
      unless ($rhs isa string) {
        return 0;
      }
      my $x = (string)$lhs;
      my $y = (string)$rhs;
      unless ($x eq $y) {
        return 0;
      }
    }
    else {
      warn("typename mismatch. lhs: " . type_name($lhs) . ", rhs: " . type_name($rhs));
      return 0;
    }
    return 1;
  }

  sub _hash_equals : int ($lhs : SPVM::Hash, $rhs : SPVM::Hash) {
    my $targets = [$lhs, $rhs];
    for (my $i = 0; $i < 2; $i++) {
      my $keys = $targets->[$i]->keys;
      for (my $j = 0; $j < @$keys; $j++) {
        unless (_object_equals($targets->[1 - $i]->get($keys->[$j]), $targets->[$i]->get($keys->[$j]))) {
          return 0;
        }
      }
    }
    return 1;
  }

  sub _list_equals : int ($lhs : SPVM::List, $rhs : SPVM::List) {
    unless ($lhs->length == $rhs->length) {
      return 0;
    }
    for (my $i = 0; $i < $lhs->length; $i++) {
      unless (_object_equals($lhs->get($i), $rhs->get($i))) {
        return 0;
      }
    }
    return 1;
  }

  sub _validate_json_text_strictly : int ($json : SPVM::JSON, $input : string[], $expected : string[]) {
    for (my $i = 0; $i < @$input; $i++) {
      my $decoded = $json->decode($input->[$i]);
      my $actual = $json->encode($decoded);
      unless ($actual eq $expected->[$i]) {
        warn("input: " . $input->[$i] . "\nexpected: " . $expected->[$i] . "\nactual: $actual");
        return 0;
      }
    }
    return 1;
  }

  sub _validate : int ($json : SPVM::JSON, $json_texts : string[], $objects : object[]) {
    unless (@$json_texts == @$objects) {
      croak "testcase json_texts and objects lengths are mismatch"; # FIXME: Invalid escape character in string literal at t/default/lib/TestCase/JSON.spvm line 115
    }
    for (my $i = 0; $i < @$json_texts; $i++) {
      my $decoded = $json->decode($json_texts->[$i]);
      unless (_object_equals($decoded, $objects->[$i])) {
        return 0;
      }
      # decode() returns valid object, and then check encode().
      my $encoded = $json->encode($decoded);
      my $restructured = $json->decode($encoded);
      unless (_object_equals($restructured, $objects->[$i])) {
        return 0;
      }
    }
    return 1;
  }

  sub test_empty : int () {
    my $json = SPVM::JSON->new;
    my $input = ["", "     "];
    my $expected = ["", ""];
    return _validate_json_text_strictly($json, $input, $expected);
  }

  sub test_hash : int () {
    my $json_texts = ["{}", "{\"digit\":123}", "{\"string\":\"vstr\"}", "{\"double\":0.123}", "{\"double2\":123.45}", "{\"bool_true\":true}", "{\"bool_false\":false}", "{\"a\":1,\"A\":0.1,\"ABC\":3.1415,\"qwerty\":\"asdfg\"}"];
    my $objects = [(object)
      SPVM::Hash->new_with_array(new object [0]),
      SPVM::Hash->new_with_array([(object) "digit",SPVM::Int->new(123)]),
      SPVM::Hash->new_with_array([(object) "string","vstr"]),
      SPVM::Hash->new_with_array([(object) "double",SPVM::Double->new(0.123)]),
      SPVM::Hash->new_with_array([(object) "double2",SPVM::Double->new(123.45)]),
      SPVM::Hash->new_with_array([(object) "bool_true",SPVM::Bool->TRUE]),
      SPVM::Hash->new_with_array([(object) "bool_false",SPVM::Bool->FALSE]),
      SPVM::Hash->new_with_array([(object) "a",SPVM::Int->new(1),"A",SPVM::Double->new(0.1),"ABC",SPVM::Double->new(3.1415),"qwerty","asdfg"])
    ];
    return _validate(SPVM::JSON->new, $json_texts, $objects);
  }

  sub test_list : int () {
    my $json_texts = ["[]", "[1,2,3]", "[\"abc\",\"123\"]", "[123,\"abc\",0,\"123abc\",0.123,3.1415]"];
    my $objects = [(object)
      SPVM::List->new_with_array(new object [0]),
      SPVM::List->new_with_array([(object) SPVM::Int->new(1), SPVM::Int->new(2), SPVM::Int->new(3)]),
      SPVM::List->new_with_array([(object) "abc", "123"]),
      SPVM::List->new_with_array([(object) SPVM::Int->new(123), "abc", SPVM::Int->new(0), "123abc", SPVM::Double->new(0.123), SPVM::Double->new(3.1415)])
    ];
    return _validate(SPVM::JSON->new, $json_texts, $objects);
  }
}
