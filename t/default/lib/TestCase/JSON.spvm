package TestCase::JSON {
  use SPVM::JSON;
  use SPVM::ObjectList;
  use SPVM::Int;
  use SPVM::Double;
  use SPVM::JSON::Bool;
  use SPVM::Hash;
  use SPVM::Sort (sortstr);

  our $DEFAULT_JSON : SPVM::JSON;

  BEGIN {
    $DEFAULT_JSON = SPVM::JSON->new;
    $DEFAULT_JSON->set_canonical(1);
  }

  sub _equals : int ($lhs : object, $rhs : object) {
    if ($lhs == undef) {
      unless ($rhs == undef) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::Hash) {
      unless ($rhs isa SPVM::Hash) {
        return 0;
      }

      my $l_hash = (SPVM::Hash)$lhs;
      my $r_hash = (SPVM::Hash)$lhs;

      my $l_keys = $l_hash->keys;
      my $r_keys = $r_hash->keys;

      if (@$l_keys == 0) {
        unless (@$r_keys == 0) {
          return 0;
        }
      }
      else {
        sortstr($l_keys);
        sortstr($r_keys);

        for (my $key_index = 0; $key_index < @$l_keys; ++$key_index) {
          my $key = $l_keys->[$key_index];
          unless ($l_keys->[$key_index] eq $r_keys->[$key_index]) {
            return 0;
          }
          unless (_equals($l_hash->get($key), $r_hash->get($key))) {
            return 0;
          }
        }
      }
    }
    elsif ($lhs isa SPVM::ObjectList) {
      unless ($rhs isa SPVM::ObjectList) {
        return 0;
      }

      my $l_list = (SPVM::ObjectList)$lhs;
      my $r_list = (SPVM::ObjectList)$rhs;

      unless ($l_list->length == $r_list->length) {
        return 0;
      }

      my $length = $l_list->length;
      for (my $list_index = 0; $list_index < $length; ++$list_index) {
        unless (_equals($l_list->get($list_index), $r_list->get($list_index))) {
          return 0;
        }
      }
    }
    elsif ($lhs isa string) {
      unless ($rhs isa string) {
        return 0;
      }

      my $l_str = (string)$lhs;
      my $r_str = (string)$rhs;

      unless ($l_str eq $r_str) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::Int) {
      unless ($rhs isa SPVM::Int) {
        return 0;
      }

      my $l_int = (SPVM::Int)$lhs;
      my $r_int = (SPVM::Int)$rhs;

      unless ($l_int->val == $r_int->val) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::JSON::Bool) {
      unless ($rhs isa SPVM::JSON::Bool) {
        return 0;
      }

      my $l_bool = (SPVM::JSON::Bool)$lhs;
      my $r_bool = (SPVM::JSON::Bool)$rhs;

      unless ($l_bool->val == $r_bool->val) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::Double) {
      unless ($rhs isa SPVM::Double) {
        return 0;
      }

      my $l_dbl = (SPVM::Double)$lhs;
      my $r_dbl = (SPVM::Double)$rhs;

      unless ($l_dbl->val == $r_dbl->val) {
        return 0;
      }
    }
    else {
      die "Not implemented type is used in \$lhs";
    }

    return 1;
  }

  sub _validate : int ($json : SPVM::JSON, $input : string[], $expected : string[]) {
    for (my $i = 0; $i < @$input; $i++) {
      my $decoded = $json->decode($input->[$i]);
      my $actual = $json->encode($decoded);
      unless ($actual eq $expected->[$i]) {
        warn("input: " . $input->[$i] . "\nexpected: " . $expected->[$i] . "\nactual: $actual");
        return 0;
      }
    }
    return 1;
  }

  sub test_flat_hash : int () {
    my $tests = ["{}", "{\"digit\":42}", "{\"string\":\"vstr\"}", "{\"double\":0.123}", "{\"bool_true\":true}", "{\"bool_false\":false}", "{\"A\":0.1,\"ABC\":false,\"a\":1,\"qwerty\":\"asdfg\"}"];
    return _validate($DEFAULT_JSON, $tests, $tests);
  }

  sub test_flat_list : int () {
    my $tests = ["[]", "[1,2,3]", "[\"abc\",\"123\"]", "[123,\"abc\",0,\"123abc\",3.1415]"];
    return _validate($DEFAULT_JSON, $tests, $tests);
  }

  sub test_digits_int : int () {
    my $tests = ["[0,1,-1]"];
    return _validate($DEFAULT_JSON, $tests, $tests);
  }

  sub test_digits_double : int () {
    my $input = [
      "0.123", "-0.123", "3.14", "-3.14", "123.987", "-123.987",
      "1.23456e+1", "1.23456e-1", "1.23456e+08", "1.23456e-08", "1.23456e+008", "1.23456e-008",
      "1.23456e+018", "1.23456e-018", "9.9e-100", "9.9e+300", "-1.23e+123"
    ];
    my $expected = [
      0.123, -0.123, 3.14, -3.14, 123.987, -123.987,
      1.23456e+1, 1.23456e-1, 1.23456e+08, 1.23456e-08, 1.23456e+008, 1.23456e-008,
      1.23456e+018, 1.23456e-018, 9.9e-100, 9.9e+300, -1.23e+123
    ];
    for (my $i = 0; $i < @$input; $i++) {
      my $got = (SPVM::Double)($DEFAULT_JSON->decode($input->[$i]));
      unless (("" . $got->val) eq ("" . $expected->[$i])) {
        return 0;
      }
      my $re_got = (SPVM::Double)($DEFAULT_JSON->decode($DEFAULT_JSON->encode($got)));
      unless (("" . $re_got->val) eq ("" . $expected->[$i])) {
        return 0;
      }
    }
    return 1;
  }

  sub test_root_is_primitive : int () {
    my $tests = ["\"abc\"", "123", "true"];
    return _validate($DEFAULT_JSON, $tests, $tests);
  }

  sub test_nest_object : int () {
    my $tests = [
      "{\"A\":{\"B\":1,\"C\":{\"D\":0.1,\"E\":true,\"F\":\"str\",\"G\":[\"elem\",\"ents\",{\"key\":\"value\"}]}},\"end\":\"eof\"}"
    ];
    unless (_validate($DEFAULT_JSON, $tests, $tests)) {
      return 0;
    }
    return 1;
  }

  sub test_spaces : int () {
    my $inputs = [
      # Root type is "hash"
      " { \"key\" \n\t: 123\t,\n\t\t\"list\" :\n[\t1\t,\r2\t,\t3\n]}\r\r",
      # Root type is "list"
      " [ 1, 3.14\n, true \t , \"a\" ] " # primitives: Int, Double, Bool, string
    ];
    my $outputs = [
      "{\"key\":123,\"list\":[1,2,3]}",
      "[1,3.14,true,\"a\"]"
    ];
    return _validate($DEFAULT_JSON, $inputs, $outputs);
  }

  sub test_format_name_separator : int () {
    my $hash = SPVM::Hash->newa([(object) "key", "value"]);
    my $json = SPVM::JSON->new;
    unless ($json->encode($hash) eq "{\"key\":\"value\"}") {
      return 0;
    }
    return 1;
  }

  sub test_special_chars : int () {
    my $tests = ["\"\\\"\\\\\\t\\n\\r\""];
    unless (_validate($DEFAULT_JSON, $tests, $tests)) {
      return 0;
    }
    return 1;
  }

  sub encode_null : int () {
    unless ($DEFAULT_JSON->encode(undef) eq "null") {
      return 0;
    }
    return 1;
  }
  
  sub decode_null : int () {
    unless ($DEFAULT_JSON->decode("null") == undef) {
      return 0;
    }
    return 1;
  }

  sub test_map_inf_nan_to_undef : int () {
    my $inputs = ["inf", "-inf", "nan"];
    for (my $i = 0; $i < @$inputs; ++$i) {
      unless ($DEFAULT_JSON->decode($inputs->[$i]) == undef) {
        return 0;
      }
    }
    return 1;
  }
}
