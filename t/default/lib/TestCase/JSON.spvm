package TestCase::JSON {
  use SPVM::JSON;
  use SPVM::List;
  use SPVM::Int;
  use SPVM::Double;
  use SPVM::Bool;

  sub _validate : int ($json : SPVM::JSON, $input : string[], $expected : string[]) {
    for (my $i = 0; $i < @$input; $i++) {
      my $decoded = $json->decode($input->[$i]);
      my $actual = $json->encode($decoded);
      unless ($actual eq $expected->[$i]) {
        warn("input: " . $input->[$i] . "\nexpected: " . $expected->[$i] . "\nactual: $actual");
        return 0;
      }
    }
    return 1;
  }

  sub _primitive_equals : int ($lhs : object, $rhs : object) {
    if ($lhs isa SPVM::Int) {
      unless ($rhs isa SPVM::Int) {
        return 0;
      }
      my $x = (SPVM::Int)$lhs;
      my $y = (SPVM::Int)$rhs;
      unless ($x->val == $y->val) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::Double) {
      unless ($rhs isa SPVM::Double) {
        return 0;
      }
      my $x = (SPVM::Double)$lhs;
      my $y = (SPVM::Double)$rhs;
      unless ($x->val == $y->val) {
        return 0;
      }
    }
    elsif ($lhs isa SPVM::Bool) {
      unless ($rhs isa SPVM::Bool) {
        return 0;
      }
      my $x = (SPVM::Bool)$lhs;
      my $y = (SPVM::Bool)$rhs;
      unless ($x->val == $y->val) {
        return 0;
      }
    }
    elsif ($lhs isa string) {
      unless ($rhs isa string) {
        return 0;
      }
      my $x = (string)$lhs;
      my $y = (string)$rhs;
      unless ($x eq $y) {
        return 0;
      }
    }
    else {
      return 0;
    }
    return 1;
  }

  sub _hash_equals : int ($lhs : SPVM::Hash, $rhs : SPVM::Hash) {
    my $targets = [$lhs, $rhs];
    for (my $i = 0; $i < 2; $i++) {
      my $keys = $targets->[$i]->keys;
      for (my $j = 0; $j < @$keys; $j++) {
        unless (_primitive_equals($targets->[1 - $i]->get($keys->[$j]), $targets->[$i]->get($keys->[$j]))) {
          return 0;
        }
      }
    }
    return 1;
  }

  sub test_empty : int () {
    my $json = SPVM::JSON->new;
    my $input = ["", "     "];
    my $expected = ["", ""];
    return _validate($json, $input, $expected);
  }

  sub test_hash : int () {
    my $input = ["{}", "{\"digit\":123}", "{\"string\":\"vstr\"}", "{\"double\":0.123}", "{\"double2\":123.45}", "{\"bool_true\":true}", "{\"bool_false\":false}", "{\"a\":1,\"A\":0.1,\"ABC\":3.1415,\"qwerty\":\"asdfg\"}"];
    my $expected = [
      SPVM::Hash->new_with_array(new object [0]),
      SPVM::Hash->new_with_array([(object) "digit",SPVM::Int->new(123)]),
      SPVM::Hash->new_with_array([(object) "string","vstr"]),
      SPVM::Hash->new_with_array([(object) "double",SPVM::Double->new(0.123)]),
      SPVM::Hash->new_with_array([(object) "double2",SPVM::Double->new(123.45)]),
      SPVM::Hash->new_with_array([(object) "bool_true",SPVM::Bool->TRUE]),
      SPVM::Hash->new_with_array([(object) "bool_false",SPVM::Bool->FALSE]),
      SPVM::Hash->new_with_array([(object) "a",SPVM::Int->new(1),"A",SPVM::Double->new(0.1),"ABC",SPVM::Double->new(3.1415),"qwerty","asdfg"])
    ];
    unless (@$input == @$expected) {
      croak "input and expected sizes are mismatch";
    }
    my $json = SPVM::JSON->new;
    for (my $i = 0; $i < @$input; $i++) {
      my $o = $json->decode($input->[$i]);
      unless ($o isa SPVM::Hash) {
        warn("Cannot decode testcase as SPVM::Hash");
        return 0;
      }
      unless (_hash_equals((SPVM::Hash)$o, (SPVM::Hash)$expected->[$i])) {
        return 0;
      }
      # decode() returns valid object, and then check encode().
      my $encoded = $json->encode($o);
      my $o2 = $json->decode($encoded);
      unless (_hash_equals((SPVM::Hash)$o2, (SPVM::Hash)$expected->[$i])) {
        return 0;
      }
    }
    return 1;
  }

  sub test_list : int () {
    my $tests = ["[]", "[1,2,3]", "[\"abc\",\"123\"]", "[123,\"abc\",0,\"123abc\",0.123,3.1415]"];
    my $json = SPVM::JSON->new;
    return _validate($json, $tests, $tests);
  }
}
