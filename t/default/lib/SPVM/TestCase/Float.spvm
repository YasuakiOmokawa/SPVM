use Float;

package TestCase::Float {

  # SPVM::Float
  sub constant: int () {
    if (Float->MIN_EXPONENT() == -126) {
      if (Float->MAX_EXPONENT() == 127) {
        if (Float->BYTES() == 4) {
          if (Float->SIZE() == 32) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub float_to_raw_int_bits: int () {
    
    my $float_value = 0.5f;
    
    my $int_bits = Float::float_to_raw_int_bits($float_value);
    
    if ($int_bits == 0x3F000000) {
      return 1;
    }
    
    return 0;
  }
  
  sub float_to_raw_int_bits_nan: int () {
    
    my $float_value = 0.0f / 0.0f;
    
    if (Float::is_nan($float_value)) {
      my $int_bits = Float::float_to_raw_int_bits($float_value);
      
      if ($int_bits != 0x7FC00000) {
        return 1;
      }
    }
    
    return 0;
  }

  sub float_to_int_bits: int () {
    
    my $float_value = 0.5f;
    
    my $int_bits = Float::float_to_int_bits($float_value);
    
    if ($int_bits == 0x3F000000) {
      return 1;
    }
    
    return 0;
  }
  
  sub float_to_int_bits_nan: int () {
    
    my $float_value = 0.0f / 0.0f;
    
    if (Float::is_nan($float_value)) {
      my $int_bits = Float::float_to_int_bits($float_value);
      
      if ($int_bits == 0x7FC00000) {
        return 1;
      }
    }
    
    return 0;
  }
    
  sub int_bits_to_float: int () {
    
    my $int_bits = 0x3F000000;
    
    my $float_value = Float::int_bits_to_float($int_bits);
    
    if ($float_value == 0.5f) {
      return 1;
    }
    
    return 0;
  }
  
  sub int_bits_to_float_nan_first_condition: int () {
    
    if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0x7F800000)) == 0x7F800000) {
      if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0x7F800001)) == 0x7FC00000) {
        if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0x7F800002)) == 0x7FC00000) {
          if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0x7FFFFFFF)) == 0x7FC00000) {
            if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0x80000000)) == 0x80000000) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub int_bits_to_float_nan_first_condition_is_nan: int () {
    
    if (!Float::is_nan(Float::int_bits_to_float(0x7F800000))) {
      if (Float::is_nan(Float::int_bits_to_float(0x7F800001))) {
        if (Float::is_nan(Float::int_bits_to_float(0x7F800002))) {
          if (Float::is_nan(Float::int_bits_to_float(0x7FFFFFFF))) {
            if (!Float::is_nan(Float::int_bits_to_float(0x80000000))) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }
  
  sub int_bits_to_float_nan_second_condition: int () {
    
    if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0xFF800000)) == 0xFF800000) {
      if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0xFF800001)) == 0x7FC00000) {
        if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0xFF800002)) == 0x7FC00000) {
          if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0xFFFFFFFF)) == 0x7FC00000) {
            if (Float::float_to_raw_int_bits(Float::int_bits_to_float(0x00000000)) == 0x00000000) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub int_bits_to_float_nan_second_condition_is_nan: int () {
    
    if (!Float::is_nan(Float::int_bits_to_float(0xFF800000))) {
      if (Float::is_nan(Float::int_bits_to_float(0xFF800001))) {
        if (Float::is_nan(Float::int_bits_to_float(0xFF800002))) {
          if (Float::is_nan(Float::int_bits_to_float(0xFFFFFFFF))) {
            if (!Float::is_nan(Float::int_bits_to_float(0x00000000))) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub is_infinite: int () {
    if (Float::is_infinite(Float::POSITIVE_INFINITY())) {
      if (Float::is_infinite(Float::NEGATIVE_INFINITY())) {
        if (!Float::is_infinite(Float::NaN())) {
          if (!Float::is_infinite(0.1f)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub is_finite: int () {
    if (!Float::is_finite(Float::POSITIVE_INFINITY())) {
      if (!Float::is_finite(Float::NEGATIVE_INFINITY())) {
        if (!Float::is_finite(Float::NaN())) {
          if (Float::is_finite(0.1f)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub is_nan: int () {
    if (!Float::is_nan(Float::POSITIVE_INFINITY())) {
      if (!Float::is_nan(Float::NEGATIVE_INFINITY())) {
        if (Float::is_nan(Float::NaN())) {
          if (!Float::is_nan(0.1f)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }
  
  sub pass_positive_infinity : int ($value : float) {
    if ($value == Float::POSITIVE_INFINITY()) {
      return 1;
    }
    
    return 0;
  }
  
  sub pass_negative_infinity : int ($value : float) {
    if ($value == Float::NEGATIVE_INFINITY()) {
      return 1;
    }
    
    return 0;
  }
  
  sub pass_nan : int ($value : float) {
    if (Float::is_nan($value)) {
      if (Float::float_to_raw_int_bits($value) == 0x7FC00000) {
        return 1;
      }
    }
    
    return 0;
  }
}
