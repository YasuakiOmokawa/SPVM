use Float;

package TestCase::Float {

  # SPVM::Float
  sub constant() : int {
    if (Float->MIN_EXPONENT == -126) {
      if (Float->MAX_EXPONENT == 127) {
        if (Float->BYTES == 4) {
          if (Float->SIZE == 32) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub int_bits_to_float() : int {
    
    my $int_bits = 0x3F000000;
    
    my $float_value = Float->int_bits_to_float($int_bits);
    
    if ($float_value == 0.5f) {
      return 1;
    }
    
    return 0;
  }

  sub int_bits_to_float_nan_first_condition() : int {
    
    if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0x7F800000)) == 0x7F800000) {
      if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0x7F800001)) == 0x7FC00000) {
        if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0x7F800002)) == 0x7FC00000) {
          if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0x7FFFFFFF)) == 0x7FC00000) {
            if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0x80000000)) == 0x80000000) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

=pod

  sub int_bits_to_float_nan_first_condition_is_nan() : int {
    
    if (!Float->is_nan(Float->int_bits_to_float(0x7FF0000000000000L))) {
      if (Float->is_nan(Float->int_bits_to_float(0x7FF0000000000001L))) {
        if (Float->is_nan(Float->int_bits_to_float(0x7FF0000000000002L))) {
          if (Float->is_nan(Float->int_bits_to_float(0x7FFFFFFFFFFFFFFFL))) {
            if (!Float->is_nan(Float->int_bits_to_float(0x8000000000000000L))) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }
  
  sub int_bits_to_float_nan_second_condition() : int {
    
    if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0xFFF0000000000000L)) == 0xFFF0000000000000L) {
      if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0xFFF0000000000001L)) == 0x7FF8000000000000L) {
        if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0xFFF0000000000002L)) == 0x7FF8000000000000L) {
          if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0xFFFFFFFFFFFFFFFFL)) == 0x7FF8000000000000L) {
            if (Float->float_to_raw_int_bits(Float->int_bits_to_float(0x0000000000000000L)) == 0x0000000000000000L) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  sub int_bits_to_float_nan_second_condition_is_nan() : int {
    
    if (!Float->is_nan(Float->int_bits_to_float(0xFFF0000000000000L))) {
      if (Float->is_nan(Float->int_bits_to_float(0xFFF0000000000001L))) {
        if (Float->is_nan(Float->int_bits_to_float(0xFFF0000000000002L))) {
          if (Float->is_nan(Float->int_bits_to_float(0xFFFFFFFFFFFFFFFFL))) {
            if (!Float->is_nan(Float->int_bits_to_float(0x0000000000000000L))) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

=cut
  sub is_infinite() : int {
    if (Float->is_infinite(Float->POSITIVE_INFINITY)) {
      if (Float->is_infinite(Float->NEGATIVE_INFINITY)) {
        if (!Float->is_infinite(Float->NaN)) {
          if (!Float->is_infinite(0.1f)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub is_finite() : int {
    if (!Float->is_finite(Float->POSITIVE_INFINITY)) {
      if (!Float->is_finite(Float->NEGATIVE_INFINITY)) {
        if (!Float->is_finite(Float->NaN)) {
          if (Float->is_finite(0.1f)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub is_nan() : int {
    if (!Float->is_nan(Float->POSITIVE_INFINITY)) {
      if (!Float->is_nan(Float->NEGATIVE_INFINITY)) {
        if (Float->is_nan(Float->NaN)) {
          if (!Float->is_nan(0.1f)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }
  
  sub pass_positive_infinity($value : float) : int {
    if ($value == Float->POSITIVE_INFINITY) {
      return 1;
    }
    
    return 0;
  }
  
  sub pass_negative_infinity($value : float) : int {
    if ($value == Float->NEGATIVE_INFINITY) {
      return 1;
    }
    
    return 0;
  }
  
  sub pass_nan($value : float) : int {
    if (Float->is_nan($value)) {
      if (Float->float_to_raw_int_bits($value) == 0x7FC00000) {
        return 1;
      }
    }
    
    return 0;
  }
}
