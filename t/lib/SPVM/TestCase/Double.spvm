use Double;

package TestCase::Double {
  sub constant() : int {
    if (Double->MIN_EXPONENT == -1022) {
      if (Double->MAX_EXPONENT == 1023) {
        if (Double->BYTES == 8) {
          if (Double->SIZE == 64) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }
  
  sub long_bits_to_double() : int {
    
    my $long_bits = 0x3FE0000000000000L;
    
    my $double_value = Double->long_bits_to_double($long_bits);
    
    if ($double_value == 0.5) {
      return 1;
    }
    
    return 0;
  }

  sub is_infinite() : int {
    if (Double->is_infinite(Double->POSITIVE_INFINITY)) {
      if (Double->is_infinite(Double->NEGATIVE_INFINITY)) {
        if (!Double->is_infinite(Double->NaN)) {
          if (!Double->is_infinite(0.1)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub is_finite() : int {
    if (!Double->is_finite(Double->POSITIVE_INFINITY)) {
      if (!Double->is_finite(Double->NEGATIVE_INFINITY)) {
        if (!Double->is_finite(Double->NaN)) {
          if (Double->is_finite(0.1)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  sub is_nan() : int {
    if (!Double->is_nan(Double->POSITIVE_INFINITY)) {
      if (!Double->is_nan(Double->NEGATIVE_INFINITY)) {
        if (Double->is_nan(Double->NaN)) {
          if (!Double->is_nan(0.1)) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }
  
  sub pass_nan($value : double) : int {
    if (Double->is_nan($value)) {
      if (Double->double_to_raw_long_bits($value) == 0x7FF8000000000000L) {
        return 1;
      }
    }
    
    return 0;
  }
  
  sub pass_positive_infinity($value : double) : int {
    if ($value == Double->POSITIVE_INFINITY) {
      return 1;
    }
    
    return 0;
  }

  sub pass_negative_infinity($value : double) : int {
    if ($value == Double->NEGATIVE_INFINITY) {
      return 1;
    }
    
    return 0;
  }
}
