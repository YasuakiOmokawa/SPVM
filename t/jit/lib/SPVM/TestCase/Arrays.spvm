use Arrays;
use Byte;

package TestCase::Arrays {

  jit sub equals_byte : int () {
    my $x1 = new byte[] {(byte)1, (byte)2, (byte)3};
    my $x2 = new byte[] {(byte)1, (byte)2, (byte)3};
    my $x3 = new byte[] {(byte)1, (byte)2};
    
    if (Arrays::equals_byte($x1, $x2)) {
      if (!Arrays::equals_byte($x1, $x3)) {
        if (Arrays::equals_byte(undef, undef)) {
          if (!Arrays::equals_byte($x1, undef)) {
            if (!Arrays::equals_byte(undef, $x1)) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub equals_short : int () {
    my $x1 = new short[] {(short)1, (short)2, (short)3};
    my $x2 = new short[] {(short)1, (short)2, (short)3};
    my $x3 = new short[] {(short)1, (short)2};
    
    if (Arrays::equals_short($x1, $x2)) {
      if (!Arrays::equals_short($x1, $x3)) {
        if (Arrays::equals_short(undef, undef)) {
          if (!Arrays::equals_short($x1, undef)) {
            if (!Arrays::equals_short(undef, $x1)) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub equals_int : int () {
    my $x1 = new int[] {1, 2, 3};
    my $x2 = new int[] {1, 2, 3};
    my $x3 = new int[] {1, 2};
    
    if (Arrays::equals_int($x1, $x2)) {
      if (!Arrays::equals_int($x1, $x3)) {
        if (Arrays::equals_int(undef, undef)) {
          if (!Arrays::equals_int($x1, undef)) {
            if (!Arrays::equals_int(undef, $x1)) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub equals_long : int () {
    my $x1 = new long[] {1L, 2L, 3L};
    my $x2 = new long[] {1L, 2L, 3L};
    my $x3 = new long[] {1L, 2L};
    
    if (Arrays::equals_long($x1, $x2)) {
      if (!Arrays::equals_long($x1, $x3)) {
        if (Arrays::equals_long(undef, undef)) {
          if (!Arrays::equals_long($x1, undef)) {
            if (!Arrays::equals_long(undef, $x1)) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub equals_float : int () {
    my $x1 = new float[] {1f, 0.5f, 0.025f};
    my $x2 = new float[] {1f, 0.5f, 0.025f};
    my $x3 = new float[] {1f, 0.5f};
    
    if (Arrays::equals_float($x1, $x2)) {
      if (!Arrays::equals_float($x1, $x3)) {
        if (Arrays::equals_float(undef, undef)) {
          if (!Arrays::equals_float($x1, undef)) {
            if (!Arrays::equals_float(undef, $x1)) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub equals_double : int () {
    my $x1 = new double[] {1d, 0.5d, 0.025d};
    my $x2 = new double[] {1d, 0.5d, 0.025d};
    my $x3 = new double[] {1d, 0.5d};
    
    if (Arrays::equals_double($x1, $x2)) {
      if (!Arrays::equals_double($x1, $x3)) {
        if (Arrays::equals_double(undef, undef)) {
          if (!Arrays::equals_double($x1, undef)) {
            if (!Arrays::equals_double(undef, $x1)) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_byte : int () {
    
    my $values = new byte[] {(byte)0, (byte)1, (byte)2};
    
    my $values2 = Arrays::copy_of_byte($values, len $values);
    
    if (@$values2 == 3) {
      if ((int)$values2->[0] == (int)(byte)0) {
        if ((int)$values2->[1] == (int)(byte)1) {
          if ((int)$values2->[2] == (int)(byte)2) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_byte_over : int () {
    
    my $values = new byte[] {(byte)0, (byte)1, (byte)2};
    
    my $length = len $values + 1;
    my $values2 = Arrays::copy_of_byte($values, $length);
    
    if (@$values2 == 4) {
      if ((int)$values2->[0] == (int)(byte)0) {
        if ((int)$values2->[1] == (int)(byte)1) {
          if ((int)$values2->[2] == (int)(byte)2) {
            if ((int)$values2->[3] == (int)(byte)0) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_byte_less : int () {
    
    my $values = new byte[] {(byte)0, (byte)1, (byte)2};
    
    my $length = len $values - 1;
    my $values2 = Arrays::copy_of_byte($values, $length);
    
    if (@$values2 == 2) {
      if ((int)$values2->[0] == (int)(byte)0) {
        if ((int)$values2->[1] == (int)(byte)1) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_byte_undef : int () {
    
    eval {
      Arrays::copy_of_byte(undef, 1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_byte_negative : int () {
    
    eval {
      my $values = new byte[] {(byte)0, (byte)1, (byte)2};
      Arrays::copy_of_byte(undef, -1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_short : int () {
    
    my $values = new short[] {(short)0, (short)1, (short)2};
    
    my $values2 = Arrays::copy_of_short($values, len $values);
    
    if (@$values2 == 3) {
      if ((int)$values2->[0] == (int)(short)0) {
        if ((int)$values2->[1] == (int)(short)1) {
          if ((int)$values2->[2] == (int)(short)2) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_short_over : int () {
    
    my $values = new short[] {(short)0, (short)1, (short)2};
    
    my $length = len $values + 1;
    my $values2 = Arrays::copy_of_short($values, $length);
    
    if (@$values2 == 4) {
      if ((int)$values2->[0] == (int)(short)0) {
        if ((int)$values2->[1] == (int)(short)1) {
          if ((int)$values2->[2] == (int)(short)2) {
            if ((int)$values2->[3] == (int)(short)0) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_short_less : int () {
    
    my $values = new short[] {(short)0, (short)1, (short)2};
    
    my $length = len $values - 1;
    my $values2 = Arrays::copy_of_short($values, $length);
    
    if (@$values2 == 2) {
      if ((int)$values2->[0] == (int)(short)0) {
        if ((int)$values2->[1] == (int)(short)1) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_short_undef : int () {
    
    eval {
      Arrays::copy_of_short(undef, 1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_short_negative : int () {
    
    eval {
      my $values = new short[] {(short)0, (short)1, (short)2};
      Arrays::copy_of_short(undef, -1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }


  jit sub copy_of_int : int () {
    
    my $values = new int[] {0, 1, 2};
    
    my $values2 = Arrays::copy_of_int($values, len $values);
    
    if (@$values2 == 3) {
      if ($values2->[0] == 0) {
        if ($values2->[1] == 1) {
          if ($values2->[2] == 2) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_int_over : int () {
    
    my $values = new int[] {0, 1, 2};
    
    my $length = len $values + 1;
    my $values2 = Arrays::copy_of_int($values, $length);
    
    if (@$values2 == 4) {
      if ($values2->[0] == 0) {
        if ($values2->[1] == 1) {
          if ($values2->[2] == 2) {
            if ($values2->[3] == 0) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_int_less : int () {
    
    my $values = new int[] {0, 1, 2};
    
    my $length = len $values - 1;
    my $values2 = Arrays::copy_of_int($values, $length);
    
    if (@$values2 == 2) {
      if ($values2->[0] == 0) {
        if ($values2->[1] == 1) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_int_undef : int () {
    
    eval {
      Arrays::copy_of_int(undef, 1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_int_negative : int () {
    
    eval {
      my $values = new int[] {0, 1, 2};
      Arrays::copy_of_int(undef, -1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_long : int () {
    
    my $values = new long[] {0L, 1L, 2L};
    
    my $values2 = Arrays::copy_of_long($values, len $values);
    
    if (@$values2 == 3) {
      if ($values2->[0] == 0L) {
        if ($values2->[1] == 1L) {
          if ($values2->[2] == 2L) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_long_over : int () {
    
    my $values = new long[] {0L, 1L, 2L};
    
    my $length = len $values + 1;
    my $values2 = Arrays::copy_of_long($values, $length);
    
    if (@$values2 == 4) {
      if ($values2->[0] == 0L) {
        if ($values2->[1] == 1L) {
          if ($values2->[2] == 2L) {
            if ($values2->[3] == 0L) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_long_less : int () {
    
    my $values = new long[] {0L, 1L, 2L};
    
    my $length = len $values - 1;
    my $values2 = Arrays::copy_of_long($values, $length);
    
    if (@$values2 == 2) {
      if ($values2->[0] == 0L) {
        if ($values2->[1] == 1L) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_long_undef : int () {
    
    eval {
      Arrays::copy_of_long(undef, 1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_long_negative : int () {
    
    eval {
      my $values = new long[] {0L, 1L, 2L};
      Arrays::copy_of_long(undef, -1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_float : int () {
    
    my $values = new float[] {0f, 1f, 2f};
    
    my $values2 = Arrays::copy_of_float($values, len $values);
    
    if (@$values2 == 3) {
      if ($values2->[0] == 0f) {
        if ($values2->[1] == 1f) {
          if ($values2->[2] == 2f) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_float_over : int () {
    
    my $values = new float[] {0f, 1f, 2f};
    
    my $length = len $values + 1;
    my $values2 = Arrays::copy_of_float($values, $length);
    
    if (@$values2 == 4) {
      if ($values2->[0] == 0f) {
        if ($values2->[1] == 1f) {
          if ($values2->[2] == 2f) {
            if ($values2->[3] == 0f) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_float_less : int () {
    
    my $values = new float[] {0f, 1f, 2f};
    
    my $length = len $values - 1;
    my $values2 = Arrays::copy_of_float($values, $length);
    
    if (@$values2 == 2) {
      if ($values2->[0] == 0f) {
        if ($values2->[1] == 1f) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_float_undef : int () {
    
    eval {
      Arrays::copy_of_float(undef, 1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_float_negative : int () {
    
    eval {
      my $values = new float[] {0f, 1f, 2f};
      Arrays::copy_of_float(undef, -1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_double : int () {
    
    my $values = new double[] {0d, 1d, 2d};
    
    my $values2 = Arrays::copy_of_double($values, len $values);
    
    if (@$values2 == 3) {
      if ($values2->[0] == 0d) {
        if ($values2->[1] == 1d) {
          if ($values2->[2] == 2d) {
            return 1;
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_double_over : int () {
    
    my $values = new double[] {0d, 1d, 2d};
    
    my $length = len $values + 1;
    my $values2 = Arrays::copy_of_double($values, $length);
    
    if (@$values2 == 4) {
      if ($values2->[0] == 0d) {
        if ($values2->[1] == 1d) {
          if ($values2->[2] == 2d) {
            if ($values2->[3] == 0d) {
              return 1;
            }
          }
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_double_less : int () {
    
    my $values = new double[] {0d, 1d, 2d};
    
    my $length = len $values - 1;
    my $values2 = Arrays::copy_of_double($values, $length);
    
    if (@$values2 == 2) {
      if ($values2->[0] == 0d) {
        if ($values2->[1] == 1d) {
          return 1;
        }
      }
    }
    
    return 0;
  }

  jit sub copy_of_double_undef : int () {
    
    eval {
      Arrays::copy_of_double(undef, 1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }

  jit sub copy_of_double_negative : int () {
    
    eval {
      my $values = new double[] {0d, 1d, 2d};
      Arrays::copy_of_double(undef, -1);
    };
    
    if ($@) {
      return 1;
    }
    
    return 0;
  }
}
