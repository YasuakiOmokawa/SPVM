package TestCase {
  use Std;
  use TestCase::EnumA;
  use TestCase::EnumB;
  use TestCase::EnumC;
  use TestCase::EnumD;
  use TestCase::Simple;
  use TestCase::Minimal;
  use TestCase::Destructor;
  use TestCase::Interface;
  use TestCase::ImplementInterface1;
  use TestCase::ImplementInterface2;
  use TestCase::Comparator;

=pod

ABCDE

=cut ppppp

=head1 NAME

SPVM::Test - SPVM test module

=cut

  
  our $PACKAGE_VAR_INT : int;
  our $PACKAGE_VAR_TEST_CASE : TestCase;
  
  has next_test : TestCase;
  has minimal : TestCase::Minimal;
  has x_byte : byte;
  has x_short : short;
  has x_int : int;
  has x_long : long;
  has x_float : float;
  has x_double : double;
  has private_field : int;
  
  sub BYTE_MAX : byte () { return (byte)127; }
  sub BYTE_MIN : byte () { return (byte)-128; }
  sub SHORT_MAX : short () { return (short)32767; }
  sub SHORT_MIN : short () { return (short)-32768; }
  sub INT_MAX : int () { return 2147483647; }
  sub INT_MIN : int () { return -2147483648; }
  sub LONG_MAX : long () { return 9223372036854775807L; }
  sub LONG_MIN : long () { return -9223372036854775808L; }
  sub FLOAT_PRECICE : float () { return 32767f; }
  sub DOUBLE_PRECICE : double () { return 2147483647.0; }
  
  sub main : int ($mvar : int) {
    {
      my $nums = new byte[3];
      $nums->[0] = 1;
      $nums->[1] = 2;
      $nums->[2] = 3;
      my $nums_str = (String[])$nums;
      print($nums_str->[0]);
      print($nums_str->[1]);
      print($nums_str->[2]);
      print("\n");
    }
    {
      my $nums = new short[3];
      $nums->[0] = 1;
      $nums->[1] = 2;
      $nums->[2] = 3;
      my $nums_str = (String[])$nums;
      print($nums_str->[0]);
      print($nums_str->[1]);
      print($nums_str->[2]);
      print("\n");
    }
    {
      my $nums = new int[3];
      $nums->[0] = 1;
      $nums->[1] = 2;
      $nums->[2] = 3;
      my $nums_str = (String[])$nums;
      print($nums_str->[0]);
      print($nums_str->[1]);
      print($nums_str->[2]);
      print("\n");
    }
    {
      my $nums = new long[3];
      $nums->[0] = 1;
      $nums->[1] = 2;
      $nums->[2] = 3;
      my $nums_str = (String[])$nums;
      print($nums_str->[0]);
      print($nums_str->[1]);
      print($nums_str->[2]);
      print("\n");
    }
    {
      my $nums = new float[3];
      $nums->[0] = 1.5;
      $nums->[1] = 2.5;
      $nums->[2] = 3.5;
      my $nums_str = (String[])$nums;
      print($nums_str->[0]);
      print($nums_str->[1]);
      print($nums_str->[2]);
      print("\n");
    }
    {
      my $nums = new double[3];
      $nums->[0] = 1.5;
      $nums->[1] = 2.5;
      $nums->[2] = 3.5;
      my $nums_str = (String[])$nums;
      print($nums_str->[0]);
      print($nums_str->[1]);
      print($nums_str->[2]);
      print("\n");
    }
    
    print((String)2.23e-9 . "\n");
    
    # sort
    {
      my $comparator = new package {
        sub compare : int ($self : self, $object1 : Object, $object2 : Object) {
          my $minimal1 = (TestCase::Minimal)$object1;
          my $minimal2 = (TestCase::Minimal)$object2;
          
          my $x1 = $minimal1->{x};
          my $x2 = $minimal2->{x};
          
          if ($x1 > $x2) {
            return 1;
          }
          elsif ($x1 < $x2) {
            return -1;
          }
          else {
            return 0;
          }
        }
      };
      
      my $minimals = new TestCase::Minimal[3];
      $minimals->[0] = new TestCase::Minimal;
      $minimals->[0]{x} = 3;
      $minimals->[1] = new TestCase::Minimal;
      $minimals->[1]{x} = 1;
      $minimals->[2] = new TestCase::Minimal;
      $minimals->[2]{x} = 2;
      
      sort_obj($minimals, $comparator);
      print((String)$minimals->[0]{x} . " " . (String)$minimals->[1]{x} . " " . (String)$minimals->[2]{x} . "\n");
    }
    
    # Anon package
    {
      my $point = new package {
        has x : int;
        has y : int;
        sub clear : void ($self : self) {
          $self->{x} = 0;
          $self->{y} = 0;
        }
      };
      
      $point->{x} = 3;
      print((String)$point->{x} . "\n");
      $point->clear;
      print((String)$point->{x} . "\n");
    }
    
    return $mvar + 3;
  }

  # Call void function
  sub call_void_sub : void ($nums : int[]) {
    $nums->[0] = 5;
  }
  sub call_void : int () {
    my $nums = new int[] {1};
    
    call_void_sub($nums);
    
    if ($nums->[0] == 5) {
      return 1;
    }
    return 0;
  }
  
  sub test1 : int () {
    my $num0 = 1;
    my $num1 = 2;
    my $num2 = 3;
    my $num3 = 4;
    my $num4 = 5;
    
    return 0;
  }
  
  sub sum4 : long ($num1 : long, $num2 : long) {
    return $num1 + $num2;
  }
  
  sub sum3 : int ($simple : TestCase::Simple, $foo : long, $bar : float) {
    
    if (3) {
    
    }
    
    if (3) {
      1;
    }
    elsif (4) {
      4;
    }
    else {
      
    }

    if (3) {
      1;
    }
    elsif (4) {
      4;
    }
    elsif (5) {
    
    }
    else {
      
    }
    
    if (1) {
      
    }
    else {
      
    }
    
    array_new();
    
    return 2;
  }
  
  sub sum1 : long ($num1 : long, $num2 : long) {
    return $num1 + $num2;
  }
  sub sum0 : int ($num1 : int, $num2 : int) {
    return $num1 + $num2;
  }
  
  sub sum2 : int ($num1 : int, $num2 : int) {
    # croak "Error";
    
    my $num3 = sum0($num1, $num2);
    
    return $num3 + 3;
  }

  sub increfcount : int ($test : TestCase::Minimal, $num : int) {
    
    my $aaa = TestCase::Minimal->new();
  }

  sub decinctest : int ($num1 : TestCase::Minimal, $num2 : int, $num3 : TestCase::Minimal) {
    {
      my $num4 = TestCase::Minimal->new();
      my $num5 = TestCase::Minimal->new();
    }
    return 2;
  }

  sub return_object : TestCase::Minimal () {
    my $obj0 = TestCase::Minimal->new();
    {
      my $obj1 = TestCase::Minimal->new();
      
      my $obj2 : TestCase::Minimal;
      
      my $obj3 : TestCase::Minimal = undef;

      return $obj2;
    }
  }

  sub eval_block : void () {
    my $obj0 = TestCase::Minimal->new();
    
    eval {
      my $obj1 = TestCase::Minimal->new();
      
      my $obj2 : TestCase::Minimal;
      
      my $obj3 : TestCase::Minimal = undef;
      
      my $obj_error1 = "Error1";
      
      croak $obj_error1;
    };
    
    {
      my $obj4 = TestCase::Minimal->new();
      
      my $obj5 : TestCase::Minimal;
      
      my $obj6 : TestCase::Minimal = undef;
      
      my $obj_error2 = "Error2";
      
      croak $obj_error2;
    }
  }
  sub array_new : int () {
    
    my $nums = new int[3];
    
    return @$nums;
  }
  sub check_freelist : int[] () {
    my $result = new int[63];
    my $true_result = new int[1];
    return $true_result;
  }
  sub default_return_value_object_sub : TestCase () {
    1;
  }
  sub default_return_value_object_sub_empty : TestCase () {
    
  }
  sub weaken_reference_count1_object : int (){
    my $minimal = TestCase::Minimal->new();
    my $test = new TestCase;
    
    $test->{minimal} = $minimal;
    $minimal = undef;
    weaken $test->{minimal};
    
    if ($test->{minimal} == undef) {
      return 1;
    }
    
    return 0;
  }
  
  sub error : int () {
    croak "ERROR";
  }
  
  sub error_call_stack : int () {
    error();
  }

  sub error_eval : int () {
    eval {
      croak "ERROR";
    };
    
    if ($@) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub error_eval_call : int () {
    eval {
      error();
    };
    
    if ($@) {
      return 1;
    }
    else {
      return 0;
    }
  }
  sub exception_croak_return_object : TestCase::Minimal () {
    croak "Error";
  }
  sub new : TestCase () {
    return new TestCase;
  }

  sub call_sub_args_convertion_stab1 : double ($var6 : double) {
    return ($var6);
  }
  
  sub call_sub_args_convertion : int () {
    my $return_value1 = call_sub_args_convertion_stab1(16);
    return 0;
  }

  sub sort_obj : void ($values : Object[], $comparator : TestCase::Comparator) {

    my $change_cnt = @$values - 1;
    while( $change_cnt > 0){
      for (my $i = 0; $i < $change_cnt; $i++) {
        my $ret = $comparator->compare($values->[$i], $values->[$i + 1]);
        
        if ($comparator->compare($values->[$i], $values->[$i + 1]) == 1) {
          my $tmp_value = $values->[$i];
          $values->[$i] = $values->[$i + 1];
          $values->[$i + 1] = $tmp_value;
        }
      }
      $change_cnt--;
    }
  }
}

=head1 NAME

SPVM::Test - SPVM test module

